[
  {
    "objectID": "api/gene_info_region.html",
    "href": "api/gene_info_region.html",
    "title": "gene_info_region",
    "section": "",
    "text": "geneinfo.gene_info_region(\n    chrom\n    window_start\n    window_end\n    assembly='GRCh38'\n    db='ncbiRefSeq'\n)\nDisplays HTML formatted information about genes in a chromosomal region.\n\n\n\nchrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : str = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : str = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’",
    "crumbs": [
      "Gene information",
      "gene_info_region"
    ]
  },
  {
    "objectID": "api/gene_info_region.html#parameters",
    "href": "api/gene_info_region.html#parameters",
    "title": "gene_info_region",
    "section": "",
    "text": "chrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : str = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : str = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’",
    "crumbs": [
      "Gene information",
      "gene_info_region"
    ]
  },
  {
    "objectID": "api/go_term2name.html",
    "href": "api/go_term2name.html",
    "title": "go_term2name",
    "section": "",
    "text": "geneinfo.ontology.go_term2name(term)\nConverts a GO term to its name.\n\n\n\nterm : str\n\nGO term\n\n\n\n\n\n\n : str\n\nGO term name.",
    "crumbs": [
      "GO information",
      "go_term2name"
    ]
  },
  {
    "objectID": "api/go_term2name.html#parameters",
    "href": "api/go_term2name.html#parameters",
    "title": "go_term2name",
    "section": "",
    "text": "term : str\n\nGO term",
    "crumbs": [
      "GO information",
      "go_term2name"
    ]
  },
  {
    "objectID": "api/go_term2name.html#returns",
    "href": "api/go_term2name.html#returns",
    "title": "go_term2name",
    "section": "",
    "text": ": str\n\nGO term name.",
    "crumbs": [
      "GO information",
      "go_term2name"
    ]
  },
  {
    "objectID": "api/show_go_dag_for_gene.html",
    "href": "api/show_go_dag_for_gene.html",
    "title": "show_go_dag_for_gene",
    "section": "",
    "text": "geneinfo.ontology.show_go_dag_for_gene(\n    gene\n    taxid=9606\n    evidence=None\n    add_relationships=True\n)\nDisplays GO graph for a given gene.\n\n\n\ngene : str\n\nGene symbol\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human\n\nevidence : list = None\n\nLimiting list of evidence categories to include, by default None. See show_go_evidence_codes().\n\nadd_relationships : bool = True\n\nAdd edges representing relationships between GO terms, by default True",
    "crumbs": [
      "GO graphs",
      "show_go_dag_for_gene"
    ]
  },
  {
    "objectID": "api/show_go_dag_for_gene.html#parameters",
    "href": "api/show_go_dag_for_gene.html#parameters",
    "title": "show_go_dag_for_gene",
    "section": "",
    "text": "gene : str\n\nGene symbol\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human\n\nevidence : list = None\n\nLimiting list of evidence categories to include, by default None. See show_go_evidence_codes().\n\nadd_relationships : bool = True\n\nAdd edges representing relationships between GO terms, by default True",
    "crumbs": [
      "GO graphs",
      "show_go_dag_for_gene"
    ]
  },
  {
    "objectID": "api/stairs.html",
    "href": "api/stairs.html",
    "title": "stairs",
    "section": "",
    "text": "stairs\ngeneinfo.utils.stairs(df, start='start', end='end', pos='pos', endtrim=0)\nTurn a df with start, end into one with pos to plot as stairs",
    "crumbs": [
      "Utilities",
      "stairs"
    ]
  },
  {
    "objectID": "api/GoogleSheet.html",
    "href": "api/GoogleSheet.html",
    "title": "GoogleSheet",
    "section": "",
    "text": "GoogleSheet\ngeneinfo.utils.GoogleSheet(\n    self\n    SHEET_ID='1JSjSLuto3jqdEnnG7JqzeC_1pUZw76n7XueVAYrUOpk'\n    SHEET_NAME='Sheet1'\n)",
    "crumbs": [
      "Utilities",
      "GoogleSheet"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieve information summaries, for named genes or genes in a defined genomic range, and displays it as rendered Markdown in the output cell.\n\n\n\ngene_info\nDisplays HTML formatted information about one or more genes.\n\n\ngene_info_region\nDisplays HTML formatted information about genes in a chromosomal region.\n\n\n\n\n\n\nThese functions display information graphically together with each either gene structures in a genomic region (gene_plot) or chromosomal ideograms (chrom_ideogram).\n\n\n\ngene_plot\nPlots gene ideograms for a chromosomal region and returns axes for\n\n\nGenomeIdeogram\nClass to plot ideograms of chromosomes in a genome assembly.\n\n\nChromIdeogram\nChild class of GenomeIdeogram for plotting single chromosome ideograms.\n\n\n\n\n\n\nThese functions retrieve coordinates of named genes or genes in a chromosomal region.\n\n\n\ngene_coord\nRetrieves genome coordinates one or more genes.\n\n\nget_genes_region\nGets gene structure information for genes in a chromosomal region.\n\n\nget_genes_region_dataframe\nGets gene structure information for genes in a chromosomal region in the form\n\n\n\n\n\n\nThese functions converts between NCBI, ENSEMBL and HGCN gene identifiers.\n\n\n\nensembl_id\nGet ENSEMBL ID for some gene identifier\n\n\nhgcn_symbol\nGet HGCN gene symbol for some gene identifier\n\n\nensembl2symbol\nConverts ENSEMBL ID to gene HGCN gene symbol\n\n\nensembl2ncbi\nConverts ENSEMBL ID to gene NCBI ID\n\n\n\n\n\n\nThese functions retrieve and display STRING network information.\n\n\n\nstring_network_table\nRetrieves STRING network for a list of genes and returns it as a pandas.DataFrame.\n\n\nshow_string_network\nDisplay STRING network for a list of genes.\n\n\n\n\n\n\nThese functions retrieve gene ontology information.\n\n\n\ngo_info\nDisplays HML formatted information about the given GO terms.\n\n\ngo_term2name\nConverts a GO term to its name.\n\n\ngo_name2term\nConverts a GO term name to its term.\n\n\nget_go_terms_for_genes\nGet the union of GO terms for a list of genes.\n\n\nget_terms_for_go_regex\nGet GO terms for terms matching a regular expression in their description string.\n\n\ngo_annotation_table\nGO annotations for a given taxonomy id as a pandas.DataFrame.\n\n\n\n\n\n\nThese functions allow gene ontology enrichment analyses.\n\n\n\ngo_enrichment\nRuns a GO enrichment analysis.\n\n\nshow_go_evidence_codes\nDisplay list of GO evidence categories and their codes.\n\n\nsymbols_protein_coding\nList of protein coding gene symbols for a given taxonomy id.\n\n\ndownload_data\n\n\n\n\n\n\n\nThese functions display directed graphs representing sets of connected GO terms.\n\n\n\nemail\nRegisters your email address for Entrez queries. Thay way, NCBI will contect you\n\n\nshow_go_dag_for_gene\nDisplays GO graph for a given gene.\n\n\nshow_go_dag_for_terms\nDisplay GO graph for a list of GO terms.\n\n\nshow_go_dag_enrichment_results\nDisplays a GO enrichment analysis results.\n\n\n\n\n\n\nThese functions retrieves genes based on their GO annotation.\n\n\n\nget_genes_for_go_regex\nGet gene information for GO terms matching a regular expression in their description string.\n\n\nget_genes_for_go_terms\nGet gene information for genes with specified GO terms.\n\n\ngene_annotation_table\nGene annotations for a given taxonomy id as a pandas.DataFrame.\n\n\n\n\n\n\nThese are utility functions to record your email in queries and to tabulate genes.\n\n\n\ntabulate_genes\n\n\n\nhorizon\nHorizon bar plot made allowing multiple chromosomes and multiple samples.\n\n\nstairs\nTurn a df with start, end into one with pos to plot as stairs\n\n\nclear_cache\nClear the cache of a shelve file.\n\n\nGeneList\n\n\n\nGoogleSheet",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#gene-information",
    "href": "api/index.html#gene-information",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieve information summaries, for named genes or genes in a defined genomic range, and displays it as rendered Markdown in the output cell.\n\n\n\ngene_info\nDisplays HTML formatted information about one or more genes.\n\n\ngene_info_region\nDisplays HTML formatted information about genes in a chromosomal region.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#gene-plots",
    "href": "api/index.html#gene-plots",
    "title": "Function reference",
    "section": "",
    "text": "These functions display information graphically together with each either gene structures in a genomic region (gene_plot) or chromosomal ideograms (chrom_ideogram).\n\n\n\ngene_plot\nPlots gene ideograms for a chromosomal region and returns axes for\n\n\nGenomeIdeogram\nClass to plot ideograms of chromosomes in a genome assembly.\n\n\nChromIdeogram\nChild class of GenomeIdeogram for plotting single chromosome ideograms.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#gene-coordinates",
    "href": "api/index.html#gene-coordinates",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieve coordinates of named genes or genes in a chromosomal region.\n\n\n\ngene_coord\nRetrieves genome coordinates one or more genes.\n\n\nget_genes_region\nGets gene structure information for genes in a chromosomal region.\n\n\nget_genes_region_dataframe\nGets gene structure information for genes in a chromosomal region in the form",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#id-conversion",
    "href": "api/index.html#id-conversion",
    "title": "Function reference",
    "section": "",
    "text": "These functions converts between NCBI, ENSEMBL and HGCN gene identifiers.\n\n\n\nensembl_id\nGet ENSEMBL ID for some gene identifier\n\n\nhgcn_symbol\nGet HGCN gene symbol for some gene identifier\n\n\nensembl2symbol\nConverts ENSEMBL ID to gene HGCN gene symbol\n\n\nensembl2ncbi\nConverts ENSEMBL ID to gene NCBI ID",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#string-networks",
    "href": "api/index.html#string-networks",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieve and display STRING network information.\n\n\n\nstring_network_table\nRetrieves STRING network for a list of genes and returns it as a pandas.DataFrame.\n\n\nshow_string_network\nDisplay STRING network for a list of genes.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#go-information",
    "href": "api/index.html#go-information",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieve gene ontology information.\n\n\n\ngo_info\nDisplays HML formatted information about the given GO terms.\n\n\ngo_term2name\nConverts a GO term to its name.\n\n\ngo_name2term\nConverts a GO term name to its term.\n\n\nget_go_terms_for_genes\nGet the union of GO terms for a list of genes.\n\n\nget_terms_for_go_regex\nGet GO terms for terms matching a regular expression in their description string.\n\n\ngo_annotation_table\nGO annotations for a given taxonomy id as a pandas.DataFrame.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#go-enrichment",
    "href": "api/index.html#go-enrichment",
    "title": "Function reference",
    "section": "",
    "text": "These functions allow gene ontology enrichment analyses.\n\n\n\ngo_enrichment\nRuns a GO enrichment analysis.\n\n\nshow_go_evidence_codes\nDisplay list of GO evidence categories and their codes.\n\n\nsymbols_protein_coding\nList of protein coding gene symbols for a given taxonomy id.\n\n\ndownload_data",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#go-graphs",
    "href": "api/index.html#go-graphs",
    "title": "Function reference",
    "section": "",
    "text": "These functions display directed graphs representing sets of connected GO terms.\n\n\n\nemail\nRegisters your email address for Entrez queries. Thay way, NCBI will contect you\n\n\nshow_go_dag_for_gene\nDisplays GO graph for a given gene.\n\n\nshow_go_dag_for_terms\nDisplay GO graph for a list of GO terms.\n\n\nshow_go_dag_enrichment_results\nDisplays a GO enrichment analysis results.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#gene-annotation",
    "href": "api/index.html#gene-annotation",
    "title": "Function reference",
    "section": "",
    "text": "These functions retrieves genes based on their GO annotation.\n\n\n\nget_genes_for_go_regex\nGet gene information for GO terms matching a regular expression in their description string.\n\n\nget_genes_for_go_terms\nGet gene information for genes with specified GO terms.\n\n\ngene_annotation_table\nGene annotations for a given taxonomy id as a pandas.DataFrame.",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/index.html#utilities",
    "href": "api/index.html#utilities",
    "title": "Function reference",
    "section": "",
    "text": "These are utility functions to record your email in queries and to tabulate genes.\n\n\n\ntabulate_genes\n\n\n\nhorizon\nHorizon bar plot made allowing multiple chromosomes and multiple samples.\n\n\nstairs\nTurn a df with start, end into one with pos to plot as stairs\n\n\nclear_cache\nClear the cache of a shelve file.\n\n\nGeneList\n\n\n\nGoogleSheet",
    "crumbs": [
      "Function reference"
    ]
  },
  {
    "objectID": "api/gene_info.html",
    "href": "api/gene_info.html",
    "title": "gene_info",
    "section": "",
    "text": "geneinfo.gene_info(query, species='human', scopes='hgnc')\nDisplays HTML formatted information about one or more genes.\n\n\n\nquery : Union[str, List[str]]\n\nGene symbol or list of gene symbols\n\nspecies : optional = 'human'\n\nSpecies, by default ‘human’\n\nscopes : optional = 'hgnc'\n\nScopes for information search, by default ‘hgnc’",
    "crumbs": [
      "Gene information",
      "gene_info"
    ]
  },
  {
    "objectID": "api/gene_info.html#parameters",
    "href": "api/gene_info.html#parameters",
    "title": "gene_info",
    "section": "",
    "text": "query : Union[str, List[str]]\n\nGene symbol or list of gene symbols\n\nspecies : optional = 'human'\n\nSpecies, by default ‘human’\n\nscopes : optional = 'hgnc'\n\nScopes for information search, by default ‘hgnc’",
    "crumbs": [
      "Gene information",
      "gene_info"
    ]
  },
  {
    "objectID": "api/ensembl2ncbi.html",
    "href": "api/ensembl2ncbi.html",
    "title": "ensembl2ncbi",
    "section": "",
    "text": "geneinfo.information.ensembl2ncbi(ensembl_id)\nConverts ENSEMBL ID to gene NCBI ID\n\n\n\nensembl_id : \n\nENSEMBL ID\n\n\n\n\n\n\n : \n\nNCBI ID\n\n\n\n\n\n\n: [](~geneinfo.NotFound)\n\nRaises exception if no NCBI ID can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl2ncbi"
    ]
  },
  {
    "objectID": "api/ensembl2ncbi.html#parameters",
    "href": "api/ensembl2ncbi.html#parameters",
    "title": "ensembl2ncbi",
    "section": "",
    "text": "ensembl_id : \n\nENSEMBL ID",
    "crumbs": [
      "ID conversion",
      "ensembl2ncbi"
    ]
  },
  {
    "objectID": "api/ensembl2ncbi.html#returns",
    "href": "api/ensembl2ncbi.html#returns",
    "title": "ensembl2ncbi",
    "section": "",
    "text": ": \n\nNCBI ID",
    "crumbs": [
      "ID conversion",
      "ensembl2ncbi"
    ]
  },
  {
    "objectID": "api/ensembl2ncbi.html#raises",
    "href": "api/ensembl2ncbi.html#raises",
    "title": "ensembl2ncbi",
    "section": "",
    "text": ": [](~geneinfo.NotFound)\n\nRaises exception if no NCBI ID can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl2ncbi"
    ]
  },
  {
    "objectID": "api/string_network_table.html",
    "href": "api/string_network_table.html",
    "title": "string_network_table",
    "section": "",
    "text": "geneinfo.string.string_network_table(my_genes, nodes=10)\nRetrieves STRING network for a list of genes and returns it as a pandas.DataFrame.\n\n\n\nmy_genes : list\n\nList of gene symbols\n\nnodes : int = 10\n\nNumber of nodes to show, by default 10\n\n\n\n\n\n\n : pd.DataFrame\n\nSTRING network information for specified genes.",
    "crumbs": [
      "STRING networks",
      "string_network_table"
    ]
  },
  {
    "objectID": "api/string_network_table.html#parameters",
    "href": "api/string_network_table.html#parameters",
    "title": "string_network_table",
    "section": "",
    "text": "my_genes : list\n\nList of gene symbols\n\nnodes : int = 10\n\nNumber of nodes to show, by default 10",
    "crumbs": [
      "STRING networks",
      "string_network_table"
    ]
  },
  {
    "objectID": "api/string_network_table.html#returns",
    "href": "api/string_network_table.html#returns",
    "title": "string_network_table",
    "section": "",
    "text": ": pd.DataFrame\n\nSTRING network information for specified genes.",
    "crumbs": [
      "STRING networks",
      "string_network_table"
    ]
  },
  {
    "objectID": "api/gene_annotation_table.html",
    "href": "api/gene_annotation_table.html",
    "title": "gene_annotation_table",
    "section": "",
    "text": "geneinfo.ontology.gene_annotation_table(taxid=9606)\nGene annotations for a given taxonomy id as a pandas.DataFrame.\n\n\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human\n\n\n\n\n\n\n : pd.DataFrame\n\nGene annotations for the specified taxonomy id.",
    "crumbs": [
      "Gene annotation",
      "gene_annotation_table"
    ]
  },
  {
    "objectID": "api/gene_annotation_table.html#parameters",
    "href": "api/gene_annotation_table.html#parameters",
    "title": "gene_annotation_table",
    "section": "",
    "text": "taxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human",
    "crumbs": [
      "Gene annotation",
      "gene_annotation_table"
    ]
  },
  {
    "objectID": "api/gene_annotation_table.html#returns",
    "href": "api/gene_annotation_table.html#returns",
    "title": "gene_annotation_table",
    "section": "",
    "text": ": pd.DataFrame\n\nGene annotations for the specified taxonomy id.",
    "crumbs": [
      "Gene annotation",
      "gene_annotation_table"
    ]
  },
  {
    "objectID": "api/show_string_network.html",
    "href": "api/show_string_network.html",
    "title": "show_string_network",
    "section": "",
    "text": "geneinfo.string.show_string_network(my_genes, nodes=10)\nDisplay STRING network for a list of genes.\n\n\n\nmy_genes : Union[list, str]\n\nList of gene symbols\n\nnodes : int = 10\n\nNumber of nodes to show, by default 10",
    "crumbs": [
      "STRING networks",
      "show_string_network"
    ]
  },
  {
    "objectID": "api/show_string_network.html#parameters",
    "href": "api/show_string_network.html#parameters",
    "title": "show_string_network",
    "section": "",
    "text": "my_genes : Union[list, str]\n\nList of gene symbols\n\nnodes : int = 10\n\nNumber of nodes to show, by default 10",
    "crumbs": [
      "STRING networks",
      "show_string_network"
    ]
  },
  {
    "objectID": "api/tabulate_genes.html",
    "href": "api/tabulate_genes.html",
    "title": "tabulate_genes",
    "section": "",
    "text": "tabulate_genes\ngeneinfo.utils.tabulate_genes(words, ncols=None)",
    "crumbs": [
      "Utilities",
      "tabulate_genes"
    ]
  },
  {
    "objectID": "api/show_go_evidence_codes.html",
    "href": "api/show_go_evidence_codes.html",
    "title": "show_go_evidence_codes",
    "section": "",
    "text": "show_go_evidence_codes\ngeneinfo.ontology.show_go_evidence_codes()\nDisplay list of GO evidence categories and their codes.",
    "crumbs": [
      "GO enrichment",
      "show_go_evidence_codes"
    ]
  },
  {
    "objectID": "api/get_genes_region_dataframe.html",
    "href": "api/get_genes_region_dataframe.html",
    "title": "get_genes_region_dataframe",
    "section": "",
    "text": "geneinfo.information.get_genes_region_dataframe(\n    chrom\n    window_start\n    window_end\n    assembly='GRCh38'\n    db='ncbiRefSeq'\n)\nGets gene structure information for genes in a chromosomal region in the form of a pandas.DataFrame.\n\n\n\nchrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : optional = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : optional = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’\n\n\n\n\n\n\n : pd.DataFrame\n\npandas.DataFrame with the following colunms: - name: gene name - start: gene start - end: gene end - strand: gene strand",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region_dataframe"
    ]
  },
  {
    "objectID": "api/get_genes_region_dataframe.html#parameters",
    "href": "api/get_genes_region_dataframe.html#parameters",
    "title": "get_genes_region_dataframe",
    "section": "",
    "text": "chrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : optional = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : optional = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region_dataframe"
    ]
  },
  {
    "objectID": "api/get_genes_region_dataframe.html#returns",
    "href": "api/get_genes_region_dataframe.html#returns",
    "title": "get_genes_region_dataframe",
    "section": "",
    "text": ": pd.DataFrame\n\npandas.DataFrame with the following colunms: - name: gene name - start: gene start - end: gene end - strand: gene strand",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region_dataframe"
    ]
  },
  {
    "objectID": "api/download_data.html",
    "href": "api/download_data.html",
    "title": "download_data",
    "section": "",
    "text": "download_data\ngeneinfo.ontology.download_data(prt=sys.stdout)",
    "crumbs": [
      "GO enrichment",
      "download_data"
    ]
  },
  {
    "objectID": "api/GenomeIdeogram.html",
    "href": "api/GenomeIdeogram.html",
    "title": "GenomeIdeogram",
    "section": "",
    "text": "geneinfo.plot.GenomeIdeogram(\n    self\n    axes_height_inches=0.5\n    axes_width_inches=12\n    hspace=0\n    ylim=(0, 10)\n    rel_font_height=0.07\n    assembly='hg38'\n)\nClass to plot ideograms of chromosomes in a genome assembly.\n\n\n\n\n\nName\nDescription\n\n\n\n\nadd_horizon\nAdds a horizon plot to the chromosome ideograms.\n\n\nadd_labels\nAdd text labels to the chromosome ideograms.\n\n\nadd_legend\nAdds a legend to the chromosome ideograms.\n\n\nadd_segments\nAdd segments (rectangles) to the chromosome ideograms.\n\n\nadd_vlines\nAdds vertical lines to the chromosome ideograms.\n\n\ndraw_chromosomes\nDraws chromosome ideograms.\n\n\ndraw_text\nDraws text with a line pointing to a position on the y-axis.\n\n\nget_polygon\nComputes polygon for rotated text label.\n\n\nmap_fun\nMap a plotting function like seaborn.scatterplot to each ideogram panel (axis).\n\n\nmap_method\nMap a matplotib axes method like plot and scatter to each ideogram panel (axis).\n\n\nmap_y\nMaps y-axis values from user-specified ylim to actual plotting coordinates.\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_horizon(\n    data=None\n    ch='chrom'\n    y='y'\n    x='x'\n    cut=None\n    quantile_span=None\n    beginzero=True\n    base=None\n    height=None\n    colors=['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue', '#F2DE9A', '#DA8630', '#972428', 'darkred', '#D3D3D3']\n    **kwargs\n)\nAdds a horizon plot to the chromosome ideograms.\n\n\n\ndata : pd.DataFrame = None\n\nPandas DataFrame with sorted x and y data grouped by chromosome\n\nch : str = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : str = 'x'\n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : str = 'y'\n\nName of data frame column holding y coordinates, by default ‘y’\n\ncut : float = None\n\nLower and upper y values for folding the horizon plot. Default for each chromosome is a third of the y range on each side of zero.\n\nquantile_span : float = None\n\nLower and upper quantiles of y values for each chromosome to include in the horizon plot. quantile_span=(0, 1) produces the same result as cut=None. Outlier values below and above this range is assigned separate darker colors.\n\nbeginzero : bool = True\n\nPad to make the x axis begin at zero, by default True\n\nbase : float = None\n\nY coordinate for lower edge of horizon plot, by default None. If None, the lower edge of ideogram is used.\n\nheight : float = None\n\nHeight of horizon plot in y coordinates, by default None. If None, the ideogram height is used.\n\ncolors : List[str] = ['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue', '#F2DE9A', '#DA8630', '#972428', 'darkred', '#D3D3D3']\n\ndescription, by default [ ‘#CCE2DF’, ‘#59A9A8’, ‘#374E9B’, ‘midnightblue’, ‘#F2DE9A’, ‘#DA8630’, ‘#972428’, ‘darkred’, ‘#D3D3D3’]\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_labels(\n    annot\n    base=None\n    min_height=None\n    bold=[]\n    italic=[]\n    colored=[]\n    framed=[]\n    filled=[]\n    pad=0\n    **kwargs\n)\nAdd text labels to the chromosome ideograms.\n\n\n\nannot : MutableSequence\n\nList of gene names or tuples of HGCN gene symbols and tuples with chromosome name, gene position, text label, and optionally text color, text size, and line color: (&lt;chrom&gt;, &lt;position&gt;, &lt;text&gt;, [&lt;textcolor&gt;, [ [textsize] [&lt;linecolor&gt;] ] ]). Text size values are scaled to make the largest one 1 and font size is then computed as self.font_size * textsize. That way font sizes can only be smaller than the default.\n\nbase : float = None\n\nY coordinate for lower end of vertical line, by default None. If None, the upper edge of ideogram is used.\n\nmin_height : float = None\n\nMinimum length of vertical line in y coordinates, by default None, If None, half the ideogram height is used.\n\nbold : MutableSequence = []\n\nList of genes to highlight with bold text, by default []\n\nitalic : MutableSequence = []\n\nList of genes to highlight with italic text, by default []\n\ncolored : MutableSequence = []\n\nList of genes to highlight with color, by default []\n\nframed : MutableSequence = []\n\nList of genes to highlight with framed label, by default []\n\nfilled : MutableSequence = []\n\nList of genes to highlight with filled label, by default []\n\npad : float = 0\n\nText padding, by default 0\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_legend(**kwargs)\nAdds a legend to the chromosome ideograms.\n\n\n\n****kwargs** : dict = {}\n\nKeyword arguments are passed to matplotlib’s legend. Defaults to {‘loc’: ‘center left’, ‘bbox_to_anchor’: (1.02, 0.5), ‘frameon’: False}.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_segments(\n    annot\n    base=None\n    height=None\n    label=None\n    min_visible_width=200000\n    **kwargs\n)\nAdd segments (rectangles) to the chromosome ideograms.\n\n\n\nannot : MutableSequence\n\nList of tuples with chromosome name, start and end positions of each segment: (&lt;chrom&gt;, &lt;start&gt;, &lt;end&gt;, [&lt;alpha&gt;])\n\nbase : float = None\n\nY coordinate for lower edge of rectangles, by default None. If None, the lower edge of ideogram is used.\n\nheight : float = None\n\nHeight of rectangles in y coordinates, by default None. If None, the ideogram height is used.\n\nlabel : str = None\n\nLabel for plot legend, by default None\n\nmin_visible_width : int = 200000\n\nMinimum with of rendered rectangles ensuring that very short segments remain visible, by default 200000\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments for matplotlib.patches.Rectangle (defaults ot {facecolor=‘black’, edgecolor=‘none’})\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_vlines(\n    step=1000000\n    color='black'\n    linewidth=0.1\n    zorder=100\n    **kwargs\n)\nAdds vertical lines to the chromosome ideograms.\n\n\n\nstep : int = 1000000\n\nNumber of bases between lines, by default 1000000\n\ncolor : str = 'black'\n\nColor of lines, by default ‘black’\n\nlinewidth : float = 0.1\n\nWidth of lines, by default 0.1\n\nzorder : float = 100\n\nzorder of lines, by default 100\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.draw_chromosomes(\n    base=4\n    height=2\n    facecolor='#EBEAEA'\n    edgecolor='black'\n    linewidth=0.7\n    **kwargs\n)\nDraws chromosome ideograms.\n\n\n\nbase : float = 4\n\nPlacement of ideogram lower edge on y-axis scale, by default 4\n\nheight : float = 2\n\nHeight of ideogram on y-axis scale, by default 2\n\nfacecolor : str = '#EBEAEA'\n\nIdeogram fill color, by default ‘#EBEAEA’\n\nedgecolor : str = 'black'\n\nIdeogram edge color, by default ‘black’\n\nlinewidth : float = 0.7\n\nIdeogram edge width, by default 0.7\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments for matplotlib.patches.Rectangle\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.draw_text(\n    x_pos\n    y_pos\n    text\n    textcolor\n    textsize\n    linecolor\n    ax=None\n    y_line_bottom=0\n    highlight=None\n    **kwargs\n)\nDraws text with a line pointing to a position on the y-axis.\n\n\n\nx_pos : float\n\nX-axis position\n\ny_pos : float\n\nY-axis position\n\ntext : str\n\nText to display\n\ntextcolor : str\n\nText color, by default ‘black’\n\nlinecolor : str\n\nLine color, by default ‘lightgray’\n\nax : matplotlib.axes.Axes = None\n\nMatplotlib axes, by default None\n\ny_line_bottom : float = 0\n\ny coordinate for bottom of line, by default 0\n\nhighlight : dict = None\n\nDictionary for styling text labels, by default None\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.get_polygon(text, x_pos, y_pos, ax, pad=0)\nComputes polygon for rotated text label.\n\n\n\ntext : str\n\nText to display\n\nx_pos : int\n\nX-axis position\n\ny_pos : float\n\nY-axis position\n\nax : matplotlib.axes.Axes\n\nMatplotlib axes\n\npad :  = 0\n\nText padding, by default 0\n\n\n\n\n\n\n : matplotlib.patches.Polygon\n\nMaplotlib polygon object\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_fun(\n    fun\n    data=None\n    ch='chrom'\n    yaxis=(0.5, 3.5)\n    **kwargs\n)\nMap a plotting function like seaborn.scatterplot to each ideogram panel (axis).\n\n\n\nfun : Callable\n\nFunction to apply to each ideogram panel (E.g. seaborn.scatterplot).\n\ndata : pd.DataFrame = None\n\nData frame with with data for x and y coordinates by chromsome.\n\nch :  = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : \n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : \n\nName of data frame column holding y coordinates, by default ‘y’\n\nyaxis : tuple = (0.5, 3.5)\n\nY interval of ideogram panel axis ideogram to map data to, by default (0.5, 3.5)\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments are passed to the plotting function as keyword arguments.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_method(\n    method\n    data=None\n    ch='chrom'\n    yaxis=(0.5, 3.5)\n    **kwargs\n)\nMap a matplotib axes method like plot and scatter to each ideogram panel (axis).\n\n\n\nmethod : Callable\n\nMethod of matplotib.axes.Axes to apply to each ideogram panel (E.g. Axes.scatter).\n\ndata : pd.DataFrame = None\n\nData frame with with data for x and y coordinates by chromsome.\n\nch : str = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : \n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : \n\nName of data frame column holding y coordinates, by default ‘y’\n\nyaxis : tuple = (0.5, 3.5)\n\nY interval of ideogram panel axis ideogram to map data to, by default (0.5, 3.5)\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments are passed to the plotting function as keyword arguments.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_y(y, ax, bottom=0, top=1)\nMaps y-axis values from user-specified ylim to actual plotting coordinates.\n\n\n\ny : float\n\nY-axis value\n\nax : matplotlib.axes.Axes\n\nMatplotlib axes object\n\n\n\n\n\n\n : float\n\ny-axis value in plotting coordinates",
    "crumbs": [
      "Gene plots",
      "GenomeIdeogram"
    ]
  },
  {
    "objectID": "api/GenomeIdeogram.html#methods",
    "href": "api/GenomeIdeogram.html#methods",
    "title": "GenomeIdeogram",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nadd_horizon\nAdds a horizon plot to the chromosome ideograms.\n\n\nadd_labels\nAdd text labels to the chromosome ideograms.\n\n\nadd_legend\nAdds a legend to the chromosome ideograms.\n\n\nadd_segments\nAdd segments (rectangles) to the chromosome ideograms.\n\n\nadd_vlines\nAdds vertical lines to the chromosome ideograms.\n\n\ndraw_chromosomes\nDraws chromosome ideograms.\n\n\ndraw_text\nDraws text with a line pointing to a position on the y-axis.\n\n\nget_polygon\nComputes polygon for rotated text label.\n\n\nmap_fun\nMap a plotting function like seaborn.scatterplot to each ideogram panel (axis).\n\n\nmap_method\nMap a matplotib axes method like plot and scatter to each ideogram panel (axis).\n\n\nmap_y\nMaps y-axis values from user-specified ylim to actual plotting coordinates.\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_horizon(\n    data=None\n    ch='chrom'\n    y='y'\n    x='x'\n    cut=None\n    quantile_span=None\n    beginzero=True\n    base=None\n    height=None\n    colors=['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue', '#F2DE9A', '#DA8630', '#972428', 'darkred', '#D3D3D3']\n    **kwargs\n)\nAdds a horizon plot to the chromosome ideograms.\n\n\n\ndata : pd.DataFrame = None\n\nPandas DataFrame with sorted x and y data grouped by chromosome\n\nch : str = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : str = 'x'\n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : str = 'y'\n\nName of data frame column holding y coordinates, by default ‘y’\n\ncut : float = None\n\nLower and upper y values for folding the horizon plot. Default for each chromosome is a third of the y range on each side of zero.\n\nquantile_span : float = None\n\nLower and upper quantiles of y values for each chromosome to include in the horizon plot. quantile_span=(0, 1) produces the same result as cut=None. Outlier values below and above this range is assigned separate darker colors.\n\nbeginzero : bool = True\n\nPad to make the x axis begin at zero, by default True\n\nbase : float = None\n\nY coordinate for lower edge of horizon plot, by default None. If None, the lower edge of ideogram is used.\n\nheight : float = None\n\nHeight of horizon plot in y coordinates, by default None. If None, the ideogram height is used.\n\ncolors : List[str] = ['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue', '#F2DE9A', '#DA8630', '#972428', 'darkred', '#D3D3D3']\n\ndescription, by default [ ‘#CCE2DF’, ‘#59A9A8’, ‘#374E9B’, ‘midnightblue’, ‘#F2DE9A’, ‘#DA8630’, ‘#972428’, ‘darkred’, ‘#D3D3D3’]\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_labels(\n    annot\n    base=None\n    min_height=None\n    bold=[]\n    italic=[]\n    colored=[]\n    framed=[]\n    filled=[]\n    pad=0\n    **kwargs\n)\nAdd text labels to the chromosome ideograms.\n\n\n\nannot : MutableSequence\n\nList of gene names or tuples of HGCN gene symbols and tuples with chromosome name, gene position, text label, and optionally text color, text size, and line color: (&lt;chrom&gt;, &lt;position&gt;, &lt;text&gt;, [&lt;textcolor&gt;, [ [textsize] [&lt;linecolor&gt;] ] ]). Text size values are scaled to make the largest one 1 and font size is then computed as self.font_size * textsize. That way font sizes can only be smaller than the default.\n\nbase : float = None\n\nY coordinate for lower end of vertical line, by default None. If None, the upper edge of ideogram is used.\n\nmin_height : float = None\n\nMinimum length of vertical line in y coordinates, by default None, If None, half the ideogram height is used.\n\nbold : MutableSequence = []\n\nList of genes to highlight with bold text, by default []\n\nitalic : MutableSequence = []\n\nList of genes to highlight with italic text, by default []\n\ncolored : MutableSequence = []\n\nList of genes to highlight with color, by default []\n\nframed : MutableSequence = []\n\nList of genes to highlight with framed label, by default []\n\nfilled : MutableSequence = []\n\nList of genes to highlight with filled label, by default []\n\npad : float = 0\n\nText padding, by default 0\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_legend(**kwargs)\nAdds a legend to the chromosome ideograms.\n\n\n\n****kwargs** : dict = {}\n\nKeyword arguments are passed to matplotlib’s legend. Defaults to {‘loc’: ‘center left’, ‘bbox_to_anchor’: (1.02, 0.5), ‘frameon’: False}.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_segments(\n    annot\n    base=None\n    height=None\n    label=None\n    min_visible_width=200000\n    **kwargs\n)\nAdd segments (rectangles) to the chromosome ideograms.\n\n\n\nannot : MutableSequence\n\nList of tuples with chromosome name, start and end positions of each segment: (&lt;chrom&gt;, &lt;start&gt;, &lt;end&gt;, [&lt;alpha&gt;])\n\nbase : float = None\n\nY coordinate for lower edge of rectangles, by default None. If None, the lower edge of ideogram is used.\n\nheight : float = None\n\nHeight of rectangles in y coordinates, by default None. If None, the ideogram height is used.\n\nlabel : str = None\n\nLabel for plot legend, by default None\n\nmin_visible_width : int = 200000\n\nMinimum with of rendered rectangles ensuring that very short segments remain visible, by default 200000\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments for matplotlib.patches.Rectangle (defaults ot {facecolor=‘black’, edgecolor=‘none’})\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.add_vlines(\n    step=1000000\n    color='black'\n    linewidth=0.1\n    zorder=100\n    **kwargs\n)\nAdds vertical lines to the chromosome ideograms.\n\n\n\nstep : int = 1000000\n\nNumber of bases between lines, by default 1000000\n\ncolor : str = 'black'\n\nColor of lines, by default ‘black’\n\nlinewidth : float = 0.1\n\nWidth of lines, by default 0.1\n\nzorder : float = 100\n\nzorder of lines, by default 100\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.draw_chromosomes(\n    base=4\n    height=2\n    facecolor='#EBEAEA'\n    edgecolor='black'\n    linewidth=0.7\n    **kwargs\n)\nDraws chromosome ideograms.\n\n\n\nbase : float = 4\n\nPlacement of ideogram lower edge on y-axis scale, by default 4\n\nheight : float = 2\n\nHeight of ideogram on y-axis scale, by default 2\n\nfacecolor : str = '#EBEAEA'\n\nIdeogram fill color, by default ‘#EBEAEA’\n\nedgecolor : str = 'black'\n\nIdeogram edge color, by default ‘black’\n\nlinewidth : float = 0.7\n\nIdeogram edge width, by default 0.7\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments for matplotlib.patches.Rectangle\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.draw_text(\n    x_pos\n    y_pos\n    text\n    textcolor\n    textsize\n    linecolor\n    ax=None\n    y_line_bottom=0\n    highlight=None\n    **kwargs\n)\nDraws text with a line pointing to a position on the y-axis.\n\n\n\nx_pos : float\n\nX-axis position\n\ny_pos : float\n\nY-axis position\n\ntext : str\n\nText to display\n\ntextcolor : str\n\nText color, by default ‘black’\n\nlinecolor : str\n\nLine color, by default ‘lightgray’\n\nax : matplotlib.axes.Axes = None\n\nMatplotlib axes, by default None\n\ny_line_bottom : float = 0\n\ny coordinate for bottom of line, by default 0\n\nhighlight : dict = None\n\nDictionary for styling text labels, by default None\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.get_polygon(text, x_pos, y_pos, ax, pad=0)\nComputes polygon for rotated text label.\n\n\n\ntext : str\n\nText to display\n\nx_pos : int\n\nX-axis position\n\ny_pos : float\n\nY-axis position\n\nax : matplotlib.axes.Axes\n\nMatplotlib axes\n\npad :  = 0\n\nText padding, by default 0\n\n\n\n\n\n\n : matplotlib.patches.Polygon\n\nMaplotlib polygon object\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_fun(\n    fun\n    data=None\n    ch='chrom'\n    yaxis=(0.5, 3.5)\n    **kwargs\n)\nMap a plotting function like seaborn.scatterplot to each ideogram panel (axis).\n\n\n\nfun : Callable\n\nFunction to apply to each ideogram panel (E.g. seaborn.scatterplot).\n\ndata : pd.DataFrame = None\n\nData frame with with data for x and y coordinates by chromsome.\n\nch :  = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : \n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : \n\nName of data frame column holding y coordinates, by default ‘y’\n\nyaxis : tuple = (0.5, 3.5)\n\nY interval of ideogram panel axis ideogram to map data to, by default (0.5, 3.5)\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments are passed to the plotting function as keyword arguments.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_method(\n    method\n    data=None\n    ch='chrom'\n    yaxis=(0.5, 3.5)\n    **kwargs\n)\nMap a matplotib axes method like plot and scatter to each ideogram panel (axis).\n\n\n\nmethod : Callable\n\nMethod of matplotib.axes.Axes to apply to each ideogram panel (E.g. Axes.scatter).\n\ndata : pd.DataFrame = None\n\nData frame with with data for x and y coordinates by chromsome.\n\nch : str = 'chrom'\n\nName of data frame column holding chromosome names, by default ‘chrom’\n\nx : \n\nName of data frame column holding x coordinates, by default ‘x’\n\ny : \n\nName of data frame column holding y coordinates, by default ‘y’\n\nyaxis : tuple = (0.5, 3.5)\n\nY interval of ideogram panel axis ideogram to map data to, by default (0.5, 3.5)\n\n****kwargs** : dict = {}\n\nAdditional keyword arguments are passed to the plotting function as keyword arguments.\n\n\n\n\n\n\ngeneinfo.plot.GenomeIdeogram.map_y(y, ax, bottom=0, top=1)\nMaps y-axis values from user-specified ylim to actual plotting coordinates.\n\n\n\ny : float\n\nY-axis value\n\nax : matplotlib.axes.Axes\n\nMatplotlib axes object\n\n\n\n\n\n\n : float\n\ny-axis value in plotting coordinates",
    "crumbs": [
      "Gene plots",
      "GenomeIdeogram"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_terms.html",
    "href": "api/get_genes_for_go_terms.html",
    "title": "get_genes_for_go_terms",
    "section": "",
    "text": "geneinfo.ontology.get_genes_for_go_terms(terms, taxid=9606)\nGet gene information for genes with specified GO terms.\n\n\n\nterms : \n\nList of GO terms\n\ntaxid :  = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)\n\n\n\n\n\n\n : pd.DataFrame\n\nColumns: symbol, name, chrom, start, end.",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_terms"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_terms.html#parameters",
    "href": "api/get_genes_for_go_terms.html#parameters",
    "title": "get_genes_for_go_terms",
    "section": "",
    "text": "terms : \n\nList of GO terms\n\ntaxid :  = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_terms"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_terms.html#returns",
    "href": "api/get_genes_for_go_terms.html#returns",
    "title": "get_genes_for_go_terms",
    "section": "",
    "text": ": pd.DataFrame\n\nColumns: symbol, name, chrom, start, end.",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_terms"
    ]
  },
  {
    "objectID": "api/gene_plot.html",
    "href": "api/gene_plot.html",
    "title": "gene_plot",
    "section": "",
    "text": "geneinfo.plot.gene_plot(\n    chrom\n    start\n    end\n    assembly\n    highlight=[]\n    db='ncbiRefSeq'\n    collapse_splice_var=True\n    hard_limits=False\n    exact_exons=False\n    figsize=None\n    aspect=1\n    despine=False\n    clip_on=True\n    gene_density=60\n    font_size=None\n    return_axes=1\n)\nPlots gene ideograms for a chromosomal region and returns axes for plotting along the same chromosome coordinates.\n\n\n\nchrom : str\n\nChromosome identifier\n\nstart : str\n\nStart of region\n\nend : str\n\nEnd of region (end base not included)\n\nassembly : str\n\nGenome assembly identifier\n\nhighlight : List[Dict] = []\n\nList or dictionary of genes to highlight on gene plot (see Examples), by default []\n\ndb : str = 'ncbiRefSeq'\n\nDatabase to search, by default ‘ncbiRefSeq’\n\ncollapse_splice_var : bool = True\n\nWhether to collapse splice variants into a single string of exons, by default True\n\nhard_limits : bool = False\n\nWhether to truncate plot in the middle of a gene, by default False so that genes are fully plotted.\n\nexact_exons : bool = False\n\nWhether to plot exon coordinates exatly, by default False so that exons are plotted as a minimum width.\n\nfigsize : tuple = None\n\nFigure size specifified as a (width, height) tuple, by default None honering the default matplotlib settings.\n\naspect : float = 1\n\nSize of gene plot height relative to the total height of the other axes, by default 1\n\ndespine : bool = False\n\nWheher to remove top and right frame borders, by default False\n\nclip_on : bool = True\n\nArgument passed to axes.Text, by default True\n\ngene_density : float = 60\n\nControls the density of gene ideograms in the plot, by default 60\n\nfont_size : int = None\n\nGene label font size, by default None, in which case it is calculated based on the region size.\n\nreturn_axes : int = 1\n\nThe number of vertically stacked axes to return for plotting over the gene plot, by default 1\n\n\n\n\n\n\n : Union[matplotlib.axes.Axes, List[matplotlib.axes.Axes]]\n\nA single axes or a list of axes for plotting data over the gene plot.\n\n\n\n\n\nimport geneinfo as gi\n# Set email for Entrez queries\ngi.email('your@email.com')\n\n# Highlight a single gene\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight='TP53')\nax.scatter(chrom_coordinates, values)\n\n# Highlight multiple genes\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight=['TP53', 'BRCA1'])\nax.scatter(chrom_coordinates, values)\n\n# Highlight genes with custom styles\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight={'TP53': {'color': 'blue', 'weight': 'bold'}})\nax.scatter(chrom_coordinates, values)\n\n# Muli-gene highlight with custom styles\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight={'TP53': {'color': 'blue', 'weight': 'bold'}, 'BRCA1': {'color': 'red'}})\nax.scatter(chrom_coordinates, values)\n\n# Multipel axes for plotting over gene plot\naxes = gene_plot('chr1', 1000000, 2000000, 'hg38', return_axes=2)\nax1, ax2 = axes\nax1.scatter(chrom_coordinates, values1)\nax2.scatter(chrom_coordinates, values2)\n\n# Custom figure size and aspect ratio\naxes = gene_plot('chr1', 1000000, 2000000, 'hg38', figsize=(10, 4), aspect=0.5)\nax1, ax2 = axes\nax1.scatter(chrom_coordinates, values1)\nax2.scatter(chrom_coordinates, values2)",
    "crumbs": [
      "Gene plots",
      "gene_plot"
    ]
  },
  {
    "objectID": "api/gene_plot.html#parameters",
    "href": "api/gene_plot.html#parameters",
    "title": "gene_plot",
    "section": "",
    "text": "chrom : str\n\nChromosome identifier\n\nstart : str\n\nStart of region\n\nend : str\n\nEnd of region (end base not included)\n\nassembly : str\n\nGenome assembly identifier\n\nhighlight : List[Dict] = []\n\nList or dictionary of genes to highlight on gene plot (see Examples), by default []\n\ndb : str = 'ncbiRefSeq'\n\nDatabase to search, by default ‘ncbiRefSeq’\n\ncollapse_splice_var : bool = True\n\nWhether to collapse splice variants into a single string of exons, by default True\n\nhard_limits : bool = False\n\nWhether to truncate plot in the middle of a gene, by default False so that genes are fully plotted.\n\nexact_exons : bool = False\n\nWhether to plot exon coordinates exatly, by default False so that exons are plotted as a minimum width.\n\nfigsize : tuple = None\n\nFigure size specifified as a (width, height) tuple, by default None honering the default matplotlib settings.\n\naspect : float = 1\n\nSize of gene plot height relative to the total height of the other axes, by default 1\n\ndespine : bool = False\n\nWheher to remove top and right frame borders, by default False\n\nclip_on : bool = True\n\nArgument passed to axes.Text, by default True\n\ngene_density : float = 60\n\nControls the density of gene ideograms in the plot, by default 60\n\nfont_size : int = None\n\nGene label font size, by default None, in which case it is calculated based on the region size.\n\nreturn_axes : int = 1\n\nThe number of vertically stacked axes to return for plotting over the gene plot, by default 1",
    "crumbs": [
      "Gene plots",
      "gene_plot"
    ]
  },
  {
    "objectID": "api/gene_plot.html#returns",
    "href": "api/gene_plot.html#returns",
    "title": "gene_plot",
    "section": "",
    "text": ": Union[matplotlib.axes.Axes, List[matplotlib.axes.Axes]]\n\nA single axes or a list of axes for plotting data over the gene plot.",
    "crumbs": [
      "Gene plots",
      "gene_plot"
    ]
  },
  {
    "objectID": "api/gene_plot.html#examples",
    "href": "api/gene_plot.html#examples",
    "title": "gene_plot",
    "section": "",
    "text": "import geneinfo as gi\n# Set email for Entrez queries\ngi.email('your@email.com')\n\n# Highlight a single gene\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight='TP53')\nax.scatter(chrom_coordinates, values)\n\n# Highlight multiple genes\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight=['TP53', 'BRCA1'])\nax.scatter(chrom_coordinates, values)\n\n# Highlight genes with custom styles\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight={'TP53': {'color': 'blue', 'weight': 'bold'}})\nax.scatter(chrom_coordinates, values)\n\n# Muli-gene highlight with custom styles\nax = gene_plot('chr1', 1000000, 2000000, 'hg38', highlight={'TP53': {'color': 'blue', 'weight': 'bold'}, 'BRCA1': {'color': 'red'}})\nax.scatter(chrom_coordinates, values)\n\n# Multipel axes for plotting over gene plot\naxes = gene_plot('chr1', 1000000, 2000000, 'hg38', return_axes=2)\nax1, ax2 = axes\nax1.scatter(chrom_coordinates, values1)\nax2.scatter(chrom_coordinates, values2)\n\n# Custom figure size and aspect ratio\naxes = gene_plot('chr1', 1000000, 2000000, 'hg38', figsize=(10, 4), aspect=0.5)\nax1, ax2 = axes\nax1.scatter(chrom_coordinates, values1)\nax2.scatter(chrom_coordinates, values2)",
    "crumbs": [
      "Gene plots",
      "gene_plot"
    ]
  },
  {
    "objectID": "api/go_info.html",
    "href": "api/go_info.html",
    "title": "go_info",
    "section": "",
    "text": "geneinfo.ontology.go_info(terms)\nDisplays HML formatted information about the given GO terms.\n\n\n\nterms : Union[str, List[str]]\n\nA GO term or list of GO terms to display information for.",
    "crumbs": [
      "GO information",
      "go_info"
    ]
  },
  {
    "objectID": "api/go_info.html#parameters",
    "href": "api/go_info.html#parameters",
    "title": "go_info",
    "section": "",
    "text": "terms : Union[str, List[str]]\n\nA GO term or list of GO terms to display information for.",
    "crumbs": [
      "GO information",
      "go_info"
    ]
  },
  {
    "objectID": "pages/gene_coord.html",
    "href": "pages/gene_coord.html",
    "title": "Gene coordinates",
    "section": "",
    "text": "import geneinfo as gi\ngi.email('your@email.com')"
  },
  {
    "objectID": "pages/gene_coord.html#get-coordinates-for-genes-in-a-region",
    "href": "pages/gene_coord.html#get-coordinates-for-genes-in-a-region",
    "title": "Gene coordinates",
    "section": "Get coordinates for genes in a region",
    "text": "Get coordinates for genes in a region\n\ngi.get_genes_region('chrX', 76500000, 77000000, assembly='hg19')\n\n[('FGF16',\n  76709642,\n  76712769,\n  '+',\n  [(76709642, 76709751), (76711767, 76712769)]),\n ('ATRX',\n  76760357,\n  77041702,\n  '-',\n  [(76760357, 76764107),\n   (76776265, 76776394),\n   (76776880, 76776976),\n   (76777740, 76777866),\n   (76778729, 76778879),\n   (76812921, 76813116),\n   (76814139, 76814317),\n   (76829714, 76829823),\n   (76845303, 76845410),\n   (76849165, 76849319),\n   (76854879, 76855049),\n   (76855200, 76855289),\n   (76855902, 76856033),\n   (76872080, 76872198),\n   (76874273, 76874449),\n   (76875862, 76876000),\n   (76888694, 76888872),\n   (76889053, 76889200),\n   (76890084, 76890194),\n   (76891405, 76891547),\n   (76907603, 76907843),\n   (76909587, 76909690),\n   (76912049, 76912143),\n   (76918870, 76919047),\n   (76920133, 76920267),\n   (76931720, 76931793),\n   (76937011, 76940085),\n   (76940430, 76940498),\n   (76944310, 76944420),\n   (76949312, 76949426),\n   (76952064, 76952192),\n   (76953070, 76953123),\n   (76954061, 76954117),\n   (76972607, 76972720),\n   (77041467, 77041702)]),\n ('ATRX',\n  76760357,\n  77041702,\n  '-',\n  [(76760357, 76764107),\n   (76776265, 76776394),\n   (76776880, 76776976),\n   (76777740, 76777866),\n   (76778729, 76778879),\n   (76812921, 76813116),\n   (76814139, 76814317),\n   (76829714, 76829823),\n   (76845303, 76845410),\n   (76849165, 76849319),\n   (76854879, 76855049),\n   (76855200, 76855289),\n   (76855902, 76856033),\n   (76872080, 76872198),\n   (76874273, 76874449),\n   (76875862, 76876000),\n   (76888694, 76888872),\n   (76889053, 76889200),\n   (76890084, 76890194),\n   (76891405, 76891547),\n   (76907603, 76907843),\n   (76909587, 76909690),\n   (76912049, 76912143),\n   (76918870, 76919047),\n   (76920133, 76920267),\n   (76931720, 76931793),\n   (76937011, 76940085),\n   (76940430, 76940498),\n   (76944310, 76944420),\n   (76952064, 76952192),\n   (76953070, 76953123),\n   (76954061, 76954117),\n   (76972607, 76972720),\n   (77041467, 77041702)])]"
  },
  {
    "objectID": "pages/go_info.html",
    "href": "pages/go_info.html",
    "title": "GO information",
    "section": "",
    "text": "import pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport geneinfo as gi\ngi.email('your@email.com')\nclass left:\n    def __rlshift__(self, df):\n        \"Left align columns of data frame: df &lt;&lt; left()\"\n        left_aligned_df = df.style.set_properties(**{'text-align': 'left'})\n        left_aligned_df = left_aligned_df.set_table_styles(\n        [dict(selector = 'th', props=[('text-align', 'left')])])\n        display(left_aligned_df)\n        \ndf = pd.DataFrame(dict(name=['A', 'B'], desc=['bla bla bla bla', 'bla']))\ndf\n\n\n\n\n\n\n\n\nname\ndesc\n\n\n\n\n0\nA\nbla bla bla bla\n\n\n1\nB\nbla\nNB: The first time you use the GO utilities, it will spend a very long time downloading data. If you do not want to wait that out in the notebook, you can execute this command in the folder where you store your notebooks:\nGet info for one or more GO terms:\ngi.go_info('GO:0000776')\n\nGO:0000776: kinetochore\nA multisubunit complex that is located at the centromeric region of DNA and provides an attachment point for the spindle microtubules.\ngi.go_info(['GO:0000776', 'GO:0005634'])\n\nGO:0000776: kinetochore\nA multisubunit complex that is located at the centromeric region of DNA and provides an attachment point for the spindle microtubules.\n\n\n\nGO:0005634: nucleus\nA membrane-bounded organelle of eukaryotic cells in which chromosomes are housed and replicated. In most cells, the nucleus contains all of the cell’s chromosomes except the organellar chromosomes, and is the site of RNA synthesis and processing. In some species, or in specialized cell types, RNA metabolism or DNA replication may be absent.\nGet GO terms for a one or more genes:\ngo_terms = gi.get_go_terms_for_genes(['DYNLT3'])\ngo_terms[:10]\n\n10741    6990\nName: GeneID, dtype: int64\n\n\n['GO:0000776',\n 'GO:0005515',\n 'GO:0005634',\n 'GO:0005737',\n 'GO:0005868',\n 'GO:0007018',\n 'GO:0007346',\n 'GO:0042802',\n 'GO:0045505',\n 'GO:0045931']\nDescriptions for GO terms for one or more genes:\ngi.go_info(gi.get_go_terms_for_genes(['DYNLT3']))\n\n10741    6990\nName: GeneID, dtype: int64\n\n\nGO:0000776: kinetochore\nA multisubunit complex that is located at the centromeric region of DNA and provides an attachment point for the spindle microtubules.\n\n\n\nGO:0005515: protein binding\nBinding to a protein.\n\n\n\nGO:0005634: nucleus\nA membrane-bounded organelle of eukaryotic cells in which chromosomes are housed and replicated. In most cells, the nucleus contains all of the cell’s chromosomes except the organellar chromosomes, and is the site of RNA synthesis and processing. In some species, or in specialized cell types, RNA metabolism or DNA replication may be absent.\n\n\n\nGO:0005737: cytoplasm\nThe contents of a cell excluding the plasma membrane and nucleus, but including other subcellular structures.\n\n\n\nGO:0005868: cytoplasmic dynein complex\nAny dynein complex with a homodimeric dynein heavy chain core that catalyzes movement along a microtubule. Cytoplasmic dynein complexes participate in many cytoplasmic transport activities in eukaryotes, such as mRNA localization, intermediate filament transport, nuclear envelope breakdown, apoptosis, transport of centrosomal proteins, mitotic spindle assembly, virus transport, kinetochore functions, and movement of signaling and spindle checkpoint proteins. Some complexes participate in intraflagellar transport. Subunits associated with the dynein heavy chain mediate association between dynein heavy chain and cargoes, and may include light chains and light intermediate chains.\n\n\n\nGO:0007018: microtubule-based movement\nA microtubule-based process that results in the movement of organelles, other microtubules, or other cellular components. Examples include motor-driven movement along microtubules and movement driven by polymerization or depolymerization of microtubules.\n\n\n\nGO:0007346: regulation of mitotic cell cycle\nAny process that modulates the rate or extent of progress through the mitotic cell cycle.\n\n\n\nGO:0042802: identical protein binding\nBinding to an identical protein or proteins.\n\n\n\nGO:0045505: dynein intermediate chain binding\nBinding to an intermediate chain of the dynein complex.\n\n\n\nGO:0045931: positive regulation of mitotic cell cycle\nAny process that activates or increases the rate or extent of progression through the mitotic cell cycle.\n\n\n\nGO:0051301: cell division\nThe process resulting in division and partitioning of components of a cell to form more cells; may or may not be accompanied by the physical separation of a cell into distinct, individually membrane-bounded daughter cells.\n\n\n\nGO:0061673: mitotic spindle astral microtubule\nAny of the mitotic spindle microtubules that radiate in all directions from the spindle poles and are thought to contribute to the forces that separate the poles and position them in relation to the rest of the cell.",
    "crumbs": [
      "Gene ontology",
      "GO information"
    ]
  },
  {
    "objectID": "pages/go_info.html#go-graphs",
    "href": "pages/go_info.html#go-graphs",
    "title": "GO information",
    "section": "GO graphs",
    "text": "GO graphs\nShow the sub-graph for a list of GO terms:\n\nimport geneinfo\nimport importlib\nimportlib.reload(geneinfo)\n#geneinfo.go_info('GO:0000776')\ngeneinfo.show_go_dag_for_terms(go_terms)\n\n\n\n\n\n\n\n\n\ngi.show_go_dag_for_terms(go_terms)\n\n\n\n\n\n\n\n\nShow the sub-graph for the GO terms of a single gene:\n\ngi.show_go_dag_for_gene('DYNLT3')\n\n10741    6990\nName: GeneID, dtype: int64\n\n\n\n\n\n\n\n\n\nSame but using GO annotation backed by certain kinds of evidence:\n\ngi.show_go_dag_for_gene('DYNLT3', evidence=['IDA', 'EXP', 'HTP'])\n\n10741    6990\nName: GeneID, dtype: int64\n\n\n\n\n\n\n\n\n\nShow the categories of evidence backing GO annotations:\n\ngi.show_go_evidence_codes()\n\nExperimental evidence codes:  Inferred from Experiment (EXP)  Inferred from Direct Assay (IDA)  Inferred from Physical Interaction (IPI)  Inferred from Mutant Phenotype (IMP)  Inferred from Genetic Interaction (IGI)  Inferred from Expression Pattern (IEP)  Inferred from High Throughput Experiment (HTP)  Inferred from High Throughput Direct Assay (HDA)  Inferred from High Throughput Mutant Phenotype (HMP)  Inferred from High Throughput Genetic Interaction (HGI)  Inferred from High Throughput Expression Pattern (HEP)\nPhylogenetically-inferred annotations:  Inferred from Biological aspect of Ancestor (IBA)  Inferred from Biological aspect of Descendant (IBD)  Inferred from Key Residues (IKR)  Inferred from Rapid Divergence (IRD)\nComputational analysis evidence codes  Inferred from Sequence or structural Similarity (ISS)  Inferred from Sequence Orthology (ISO)  Inferred from Sequence Alignment (ISA)  Inferred from Sequence Model (ISM)  Inferred from Genomic Context (IGC)  Inferred from Reviewed Computational Analysis (RCA)\nAuthor statement evidence codes:  Traceable Author Statement (TAS)  Non-traceable Author Statement (NAS)\nCurator statement evidence codes:  Inferred by Curator (IC)  No biological Data available (ND)\nElectronic annotation evidence code:  Inferred from Electronic Annotation (IEA)",
    "crumbs": [
      "Gene ontology",
      "GO information"
    ]
  },
  {
    "objectID": "pages/go_info.html#find-genes-based-on-go-info",
    "href": "pages/go_info.html#find-genes-based-on-go-info",
    "title": "GO information",
    "section": "Find genes based on GO info",
    "text": "Find genes based on GO info\nFind genes matching a regular expression in any associated GO term description:\n\nmotor_genes_df = gi.get_genes_for_go_regex('kinesin|dynein')\nmotor_genes_df.head() &lt;&lt; left()\n\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-10-27) 44,017 Terms; optional_attrs(comment def relationship synonym xref)\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-10-27) 44,017 Terms; optional_attrs(comment def relationship synonym xref)\n\n\n\n\n\n\n\n \nsymbol\nname\nchrom\nstart\nend\n\n\n\n\n0\nSPAG1\nsperm associated antigen 1\n8\n100158037\n100241903\n\n\n1\nBLOC1S2\nbiogenesis of lysosomal organelles complex 1 subunit 2\n10\n100286679\n100273277\n\n\n2\nLZTS2\nleucine zipper tumor suppressor 2\n10\n100996587\n101007832\n\n\n3\nDYNC1H1\ndynein cytoplasmic 1 heavy chain 1\n14\n101964572\n102056442\n\n\n4\nKIF1B\nkinesin family member 1B\n1\n10210569\n10381602",
    "crumbs": [
      "Gene ontology",
      "GO information"
    ]
  },
  {
    "objectID": "pages/gene_information.html",
    "href": "pages/gene_information.html",
    "title": "Gene information",
    "section": "",
    "text": "import geneinfo as gi\n#gi.email('your@email.com')\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 import geneinfo as gi\n\nModuleNotFoundError: No module named 'geneinfo'",
    "crumbs": [
      "Gene information",
      "Gene information"
    ]
  },
  {
    "objectID": "pages/gene_information.html#summary-gene-information",
    "href": "pages/gene_information.html#summary-gene-information",
    "title": "Gene information",
    "section": "Summary gene information",
    "text": "Summary gene information\nUsing gene symbol:\n\ngi.gene_info('USP4')\n\nSymbol: USP4 (protein-coding)         Aliases: UNP, Unph\nubiquitin specific peptidase 4\nSummary: The protein encoded by this gene is a protease that deubiquitinates target proteins such as ADORA2A and TRIM21. The encoded protein shuttles between the nucleus and cytoplasm and is involved in maintaining operational fidelity in the endoplasmic reticulum. Three transcript variants encoding different isoforms have been found for this gene. [provided by RefSeq, Oct 2011].\nGenomic position: 3:49277144-49340712 (hg38), 3:49315264-49378145 (hg19)\nGene card\n\n\n\nUsing NCBI ID:\n\ngi.gene_info(7157)\n\nSymbol: TP53 (protein-coding)         Aliases: BCC7, BMFS5, LFS1, P53, TRP53\ntumor protein p53\nSummary: This gene encodes a tumor suppressor protein containing transcriptional activation, DNA binding, and oligomerization domains. The encoded protein responds to diverse cellular stresses to regulate expression of target genes, thereby inducing cell cycle arrest, apoptosis, senescence, DNA repair, or changes in metabolism. Mutations in this gene are associated with a variety of human cancers, including hereditary cancers such as Li-Fraumeni syndrome. Alternative splicing of this gene and the use of alternate promoters result in multiple transcript variants and isoforms. Additional isoforms have also been shown to result from the use of alternate translation initiation codons from identical transcript variants (PMIDs: 12032546, 20937277). [provided by RefSeq, Dec 2016].\nGenomic position: 17:7661779-7687546 (hg38), 17:7565097-7590856 (hg19)\nGene card\n\n\n\nFor a a list of genes:\n\ngi.gene_info(['LARS2', 'XCR1'])\n\nSymbol: LARS2 (protein-coding)         Aliases: HLASA, LEURS, PRLTS4, mtLeuRS\nleucyl-tRNA synthetase 2, mitochondrial\nSummary: This gene encodes a class 1 aminoacyl-tRNA synthetase, mitochondrial leucyl-tRNA synthetase. Each of the twenty aminoacyl-tRNA synthetases catalyzes the aminoacylation of a specific tRNA or tRNA isoaccepting family with the cognate amino acid. [provided by RefSeq, Jul 2008].\nGenomic position: 3:45388561-45554726 (hg38), 3:45429998-45590913 (hg19)\nGene card\n\n\n\nSymbol: XCR1 (protein-coding)         Aliases: CCXCR1, GPR5\nX-C motif chemokine receptor 1\nSummary: The protein encoded by this gene is a chemokine receptor belonging to the G protein-coupled receptor superfamily. The family members are characterized by the presence of 7 transmembrane domains. The encoded protein transduces a signal by increasing the intracellular calcium ion level. The viral macrophage inflammatory protein-II is an antagonist of this receptor and blocks signaling. Some studies have implicated a cluster of genes at 3p21.31, including this gene, as associated with COVID-19 risk. The encoded protein may also play a role in cell proliferation and migration in several types of cancer. [provided by RefSeq, Jan 2023].\nGenomic position: 3:46016990-46085825 (hg38), 3:46058516-46069234 (hg19)\nGene card\n\n\n\nFor genes a region:\n\ngi.gene_info_region('chrX', 76500000, 77000000, assembly='hg19')\n\nSymbol: FGF16 (protein-coding)         Aliases: FGF-16, MF4\nfibroblast growth factor 16\nSummary: This gene encodes a member of a family of proteins that are involved in a variety of biological processes, including embryonic development, cell growth, morphogenesis, tissue repair, tumor growth and invasion. This gene is expressed in cardiac cells and is required for proper heart development. Mutation in this gene was also observed in individuals with metacarpal 4-5 fusion. [provided by RefSeq, Mar 2014].\nGene card\n\n\n\nSymbol: ATRX (protein-coding)         Aliases: JMS, MRX52, RAD54, RAD54L, XH2, XNP, ZNF-HX\nATRX chromatin remodeler\nSummary: The protein encoded by this gene contains an ATPase/helicase domain, and thus it belongs to the SWI/SNF family of chromatin remodeling proteins. This protein is found to undergo cell cycle-dependent phosphorylation, which regulates its nuclear matrix and chromatin association, and suggests its involvement in the gene regulation at interphase and chromosomal segregation in mitosis. Mutations in this gene are associated with X-linked syndromes exhibiting cognitive disabilities as well as alpha-thalassemia (ATRX) syndrome. These mutations have been shown to cause diverse changes in the pattern of DNA methylation, which may provide a link between chromatin remodeling, DNA methylation, and gene expression in developmental processes. Multiple alternatively spliced transcript variants encoding distinct isoforms have been reported. [provided by RefSeq, Jul 2017].\nGenomic position: X:77504880-77786233 (hg38), HG1426_PATCH:76765832-77047170, X:76760356-77041702 (hg19)\nGene card\n\n\n\nSymbol: ATRX (protein-coding)         Aliases: JMS, MRX52, RAD54, RAD54L, XH2, XNP, ZNF-HX\nATRX chromatin remodeler\nSummary: The protein encoded by this gene contains an ATPase/helicase domain, and thus it belongs to the SWI/SNF family of chromatin remodeling proteins. This protein is found to undergo cell cycle-dependent phosphorylation, which regulates its nuclear matrix and chromatin association, and suggests its involvement in the gene regulation at interphase and chromosomal segregation in mitosis. Mutations in this gene are associated with X-linked syndromes exhibiting cognitive disabilities as well as alpha-thalassemia (ATRX) syndrome. These mutations have been shown to cause diverse changes in the pattern of DNA methylation, which may provide a link between chromatin remodeling, DNA methylation, and gene expression in developmental processes. Multiple alternatively spliced transcript variants encoding distinct isoforms have been reported. [provided by RefSeq, Jul 2017].\nGenomic position: X:77504880-77786233 (hg38), HG1426_PATCH:76765832-77047170, X:76760356-77041702 (hg19)\nGene card\n\n\n\nFor species other than human:\n\ngi.gene_info('DYNLT3', species='mouse', scopes=['mgi'])\n\nSymbol: Dynlt3 (protein-coding)         Aliases: 2310075M16Rik, Tcte1l\ndynein light chain Tctex-type 3\nGene card",
    "crumbs": [
      "Gene information",
      "Gene information"
    ]
  },
  {
    "objectID": "pages/gene_information.html#get-the-hgcn-symbol-for-an-alias",
    "href": "pages/gene_information.html#get-the-hgcn-symbol-for-an-alias",
    "title": "Gene information",
    "section": "Get the HGCN symbol for an alias",
    "text": "Get the HGCN symbol for an alias\n\ngi.hgcn_symbol(['CXorf23', 'BCLAF3'])\n\n['BCLAF3', 'BCLAF3']",
    "crumbs": [
      "Gene information",
      "Gene information"
    ]
  },
  {
    "objectID": "pages/gene_information.html#gene-coordinates",
    "href": "pages/gene_information.html#gene-coordinates",
    "title": "Gene information",
    "section": "Gene coordinates",
    "text": "Gene coordinates\nFor a list of genes:\n\ngi.gene_coord(['ATRX', 'MAGT1', 'FOXP2'], assembly='GRCh38')\n\n{'FOXP2': ('chr7', 114086327, 114693772, '+'),\n 'ATRX': ('chrX', 77504880, 77786233, '-'),\n 'MAGT1': ('chrX', 77825747, 77899271, '-')}\n\n\nFor the genes in a genomic region:\n\ngi.get_genes_region('chrX', 76500000, 77000000, assembly='hg19')\n\n[('FGF16',\n  76709642,\n  76712769,\n  '+',\n  [(76709642, 76709751), (76711767, 76712769)]),\n ('ATRX',\n  76760357,\n  77041702,\n  '-',\n  [(76760357, 76764107),\n   (76776265, 76776394),\n   (76776880, 76776976),\n   (76777740, 76777866),\n   (76778729, 76778879),\n   (76812921, 76813116),\n   (76814139, 76814317),\n   (76829714, 76829823),\n   (76845303, 76845410),\n   (76849165, 76849319),\n   (76854879, 76855049),\n   (76855200, 76855289),\n   (76855902, 76856033),\n   (76872080, 76872198),\n   (76874273, 76874449),\n   (76875862, 76876000),\n   (76888694, 76888872),\n   (76889053, 76889200),\n   (76890084, 76890194),\n   (76891405, 76891547),\n   (76907603, 76907843),\n   (76909587, 76909690),\n   (76912049, 76912143),\n   (76918870, 76919047),\n   (76920133, 76920267),\n   (76931720, 76931793),\n   (76937011, 76940085),\n   (76940430, 76940498),\n   (76944310, 76944420),\n   (76949312, 76949426),\n   (76952064, 76952192),\n   (76953070, 76953123),\n   (76954061, 76954117),\n   (76972607, 76972720),\n   (77041467, 77041702)]),\n ('ATRX',\n  76760357,\n  77041702,\n  '-',\n  [(76760357, 76764107),\n   (76776265, 76776394),\n   (76776880, 76776976),\n   (76777740, 76777866),\n   (76778729, 76778879),\n   (76812921, 76813116),\n   (76814139, 76814317),\n   (76829714, 76829823),\n   (76845303, 76845410),\n   (76849165, 76849319),\n   (76854879, 76855049),\n   (76855200, 76855289),\n   (76855902, 76856033),\n   (76872080, 76872198),\n   (76874273, 76874449),\n   (76875862, 76876000),\n   (76888694, 76888872),\n   (76889053, 76889200),\n   (76890084, 76890194),\n   (76891405, 76891547),\n   (76907603, 76907843),\n   (76909587, 76909690),\n   (76912049, 76912143),\n   (76918870, 76919047),\n   (76920133, 76920267),\n   (76931720, 76931793),\n   (76937011, 76940085),\n   (76940430, 76940498),\n   (76944310, 76944420),\n   (76952064, 76952192),\n   (76953070, 76953123),\n   (76954061, 76954117),\n   (76972607, 76972720),\n   (77041467, 77041702)])]",
    "crumbs": [
      "Gene information",
      "Gene information"
    ]
  },
  {
    "objectID": "pages/gene_plots.html",
    "href": "pages/gene_plots.html",
    "title": "Gene plots",
    "section": "",
    "text": "from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('white')\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport geneinfo as gi\ngi.email('your@email.com')",
    "crumbs": [
      "Gene plots",
      "Gene plots"
    ]
  },
  {
    "objectID": "pages/gene_plots.html#plot-data-over-gene-annotation",
    "href": "pages/gene_plots.html#plot-data-over-gene-annotation",
    "title": "Gene plots",
    "section": "Plot data over gene annotation",
    "text": "Plot data over gene annotation\n\n# x = np.linspace(1, 1520300000, 100000)\n# y = np.random.random(100000)\n# dummy manhattan data\nx = np.linspace(76500000, 77500000, 10000)\nrng = np.random.default_rng()\ny = rng.exponential(scale=1, size=x.size)\n\nStandard plot:\n\nax = gi.gene_plot('chrX', 76500000, 77500000, 'hg38')\nax.scatter(x, y, s=2)\nplt.tight_layout()\n\n\n\n\n\n\n\n\nSame on older hg19 assembly:\n\nax = gi.gene_plot('chrX', 76500000, 77500000, assembly='hg19')\nax.scatter(x, y, s=2)\nplt.tight_layout()\n\n\n\n\n\n\n\n\nTwo subplots for data:\n\nax1, ax2 = gi.gene_plot('chrX', 76500000, 77500000, assembly='hg38', return_axes=2)\nax1.scatter(x, y, s=2)\nax2.scatter(x, y, s=2)\nplt.tight_layout()\n\n\n\n\n\n\n\n\nThree subplots for data and adjusted aspect ratio:\n\nax1, ax2, ax3 = gi.gene_plot('chrX', 76500000, 77500000, assembly='hg38', return_axes=3, aspect=0.5)\nax1.scatter(x, y, s=2)\nax2.scatter(x, y, s=2)\nax3.scatter(x, y, s=2)\nplt.tight_layout()\n\n\n\n\n\n\n\n\nHighlight a list of genes:\n\nax = gi.gene_plot('chrX', 76500000, 77500000, 'hg19', highlight=['ATRX', 'ATP7A'])\nax.scatter(x, y, s=2)\nsns.despine(ax=ax) # make it look nicer\nplt.tight_layout()\n\n\n\n\n\n\n\n\nCombinatorial hightlighting:\nCombining text weight, style, color and bbox:\n\nhighlight = defaultdict(dict)\nfor gene in ['ATRX', 'COX7B', 'PGK1']:\n    highlight[gene].update(dict(weight='bold'))\nfor gene in ['MAGT1']:\n    highlight[gene].update(dict(style='italic'))\nfor gene in ['ATP7A', 'ATRX']:\n    highlight[gene].update(dict(color='red'))\nfor gene in ['PGK1', 'ATRX']:\n    highlight[gene].update(dict(bbox=dict(edgecolor='black', facecolor='none', linewidth=0.2)))\n\n\nax = gi.gene_plot('chrX', 76500000, 77500000, 'hg19', highlight=highlight)\nax.scatter(x, y, s=2)\nsns.despine(ax=ax) # make it look nicer\nplt.tight_layout()\n\n\n\n\n\n\n\n\n\nhighlight = defaultdict(dict)\nfor gene in gene_list('xi_any_evidence'):\n    highlight[gene].update(dict(weight='bold'))\nfor gene in gene_list('ech75_regions'):\n    highlight[gene].update(dict(style='italic'))\nfor gene in gene_list('sfari_all_conf') + gene_list('intelect_disabil'):\n    highlight[gene].update(dict(color='red'))\nfor gene in gene_list('gametologs') +  gene_list('mult_copy') + gene_list('xi_escape') + gene_list('cDEG') + gene_list('nDEG'):\n    highlight[gene].update(dict(bbox=dict(edgecolor='black', facecolor='none', linewidth=0.2)))\n\n\nax = gi.gene_plot('chrX', 76500000, 77500000, 'hg19', highlight=highlight)\n\nax.scatter(x, y, s=2)\nsns.despine(ax=ax) # make it look nicer\nplt.tight_layout()\n\n\n\n\n\n\n\n\nLarger with colors:\n\nax = gi.gene_plot('chrX', 76500000, 77500000, 'hg19', highlight=highlight, figsize=(7, 4))\n\nax.scatter(x, y, s=2, c=y, cmap='viridis_r')\nsns.despine(ax=ax) # make it look nicer\nplt.tight_layout()\n\n\n\n\n\n\n\n\nOther features:\n\nax = gi.gene_plot('chrX', 76500000, 77500000, assembly='hg19',\n                  figsize=(7, 4),          # larger figure\n                  collapse_splice_var=False, # show all splice variants separately\n                  exact_exons=False,        # allow exons to be wide enough to be visible on large plots\n                  hard_limits=True,          # truncate genes that overlap the borders of the specified range\n                 )\n\nax.scatter(x, y, s=2)\nsns.despine(ax=ax) # make it look nicer\nplt.tight_layout()",
    "crumbs": [
      "Gene plots",
      "Gene plots"
    ]
  },
  {
    "objectID": "pages/google_sheets.html",
    "href": "pages/google_sheets.html",
    "title": "Gene lists",
    "section": "",
    "text": "import geneinfo as gi\ngi.email('your@email.com')\n\nLoad Google spreadsheet with gene lists\n\ngene_lists = gi.GoogleSheet()\ngene_lists\n\n\n\n\n\n\n\n\nlabel\ndescription\n\n\n\n\nall_npx\nall NPX genes\n\n\nneuron_genome_proteome\nNeuron proteome (whole genome)\n\n\nneuron_npx_proteome\nNPX neuron proteome\n\n\nmatos_neuron\nMatos neuron genes\n\n\nmatos_common\nMatos neuron genes expressed in spermatids\n\n\nhpa_brain_prot\nBrain genes form Human protein atlas\n\n\nmeritxell_spermatid_expr\n\n\n\nintersection(nDEG, matos_neuron)\n\n\n\nunion(H,matos_common)\n\n\n\nmult_copy\n\n\n\nall_post_mei_expr\nMulti copy genes\n\n\nmsci\nall post.mei.expr. X genes\n\n\nmsci_esc\nMSCI genes\n\n\nmy_primate_codeml\nMSCI-escaping\n\n\ncDEG\nPrimate codeml site model\n\n\nnDEG\ncDEG\n\n\nprimate_ampl_multi\nnDEG\n\n\ngametologs\nAmpliconic or multicopy in some primates\n\n\nxi\nGametologs in some primates\n\n\nxi_escape\nSubject to somatic X inactivation (XI)\n\n\nxi_uncertain\nEscaping somatic X inactivation (XI)\n\n\nxi_any_evidence\nX genes uncertain XI status\n\n\nexpr_mod_xi_copynr_fibrobl\nUnion of certain and uncertain XI status\n\n\nexpr_mod_xi_copynr_lcl\nExpression modulated by Xi copy number (Fibroblast)\n\n\nreg_sa_pheno\nExpression modulated by Xi copy number (LCL)\n\n\nari_relate_EUR\nX-chromosome genes associated with regional SA phenotypes\n\n\nari_relate_ASIA\n\n\n\nari_relate_AFR\n\n\n\nari_nonPUR\n\n\n\nari_relate_PUR\n\n\n\nari_all\n\n\n\ncandidates\n\n\n\nech75_regions\nCandidate for explaining human and baboon sweeps\n\n\nech90_regions\nOverlapping human sweeps (75% ECH regions)\n\n\naccel_reg_simiiformes_br\nOverlapping human sweeps (90% ECH regions)\n\n\nsfari_all_conf\nGenes with accelerated regions Simiiformes branch\n\n\nintel_seiz_lang\nX SFARI genes (including all confidence levels)\n\n\nintelect_disabil\nIntellectual disability or Seizures or Language impairment\n\n\nmatos_common_no_xy_gametologs\nIntelectual disbility\n\n\n\n\n\n\n\n\nIndividual gene lists behaves like normal lists, but when displayed they render in columns to make them easier to read:\n\nech90_regions = gene_lists.get('ech90_regions')\nech90_regions\n\nABCB7        CNKSR2       FRMD8P1      LOC101928627 MIR500A      PGAM4        TRPC5        \nACTRT1       COX7B        FTX          LOC729609    MIR500B      PHF8         TSIX         \nAKAP4        CYBB         FUNDC2       LRCH2        MIR501       PRRG1        UPRT         \nALG13        DCX          GAB3         MAGT1        MIR502       RAB39B       USP27X       \nARHGAP36     DKC1         GPC3         MAP7D2       MIR660       RAP2C        USP27X-DT    \nATP7A        DYNLT3       H2AB1        MBNL3        MIR664B      RAP2C-AS1    VBP1         \nATRX         ENOX2        HTR2C        MIR1184-1    MPP1         RLIM         WNK3         \nBCLAF3       ENOX2-AS1    IL13RA2      MIR188       MSN          SERTM2       XIST         \nBRCC3        EZHIP        JPX          MIR23C       MTCP1        SH3KBP1      XK           \nCAPN6        F8           LANCL3       MIR362       NEXMIF       SMIM9        ZC3H12B      \nCCNB3        F8A1         LAS1L        MIR374B      NUDT10       SNORA35B                  \nCFAP47       FAM120C      LINC01201    MIR374C      NUDT11       SNORA36A                  \nCLCN5        FGF16        LINC01284    MIR421       PAGE4        SNORA56                   \nCMC4         FRMD7        LINC01496    MIR448       PAK3         STK26"
  },
  {
    "objectID": "pages/chrom_plots.html",
    "href": "pages/chrom_plots.html",
    "title": "Chromosome ideograms",
    "section": "",
    "text": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nsns.set_style('white')\n\n%matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\n%config InlineBackend.figure_format = 'svg'\n\nimport geneinfo as gi\nfrom geneinfo.plot import chrom_ideogram, GenomeIdeogram, ChromIdeogram\n#gi.email('your@email.com')\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 10\n      7 # %config InlineBackend.figure_format = 'retina'\n      8 get_ipython().run_line_magic('config', \"InlineBackend.figure_format = 'svg'\")\n---&gt; 10 import geneinfo as gi\n     11 from geneinfo.plot import chrom_ideogram, GenomeIdeogram, ChromIdeogram\n\nModuleNotFoundError: No module named 'geneinfo'\n\n\n\n\nannotation = [\n    ('chr1', 50000000, 50001000),                          # segment color defaults to red\n    ('chr2', 10000000, 1000000, 'green'),                  # with segment color\n    ('chr3', 45000000, 55000000, 'blue', 'NAME'),          # with name label\n    ('chr6', 10000000, 15000000, 'magenta', None, 0, 0.5), # with base and height\n    ('chr6', 10000000, 15000000, 'pink', None, 0.5, 0.5),  # with base and height\n]\n\nchrom_ideogram(annotation, figsize=(8, 8)) ;\n\n\n\n\n\n\n\n\nTo make sure segments are visible on the plot, the default minimal size of plotteed segments are 200000. This can be changed like this (notice how the chr1 segment is no longer visible):\n\nchrom_ideogram(annotation, figsize=(8, 8), min_visible_width=1, hspace=0)\n\n\n\n\n\n\n\n\nOther assembly, figure dimentions:\n\nchrom_ideogram(annotation, assembly='hg19', figsize=(8, 8))\n\n\n\n\n\n\n\n\nYou can add position markers along a chromosome like this to better see the location of some segments:\n\nchrom = 'chr3'\nstart = 100000000\nend = 200000000\nwidth = 10000000\nannotation2 = annotation + [(chrom, x[0], x[1], 'black', str(x[2]/width)) for x in zip(\n    range(start, end, width), \n    range(start+1, end, width), \n    range(start, end, width)\n)]\nchrom_ideogram(annotation2, figsize=(8, 8))\n\n\n\n\n\n\n\n\n\ngene_lists = gi.GoogleSheet()\nprint(gene_lists)\n\n\n\n\n\ndef gene_list_coords(gene_list):\n    append_list = []\n    for gene in gene_list:\n        coord = gi.gene_coord(gene, assembly='hg38')\n        if coord:\n            chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n            append_list.append((chrom, (start + end)/2, gene))\n        else:\n            print('skipped', gene)\n    return append_list\n    \nxi_escape_genes = gene_lists.get('xi_escape')\n# annot_xi_escape = gene_list_coords(xi_escape_genes)\n\nsfari_genes = gene_lists.get('sfari_all_conf')\n# annot_sfari_all_conf = gene_list_coords(sfari_genes)\n\ncDEG_genes = gene_lists.get('cDEG')\n# annot_cDEG_genes = gene_list_coords(cDEG_genes)\n\nnDEG_genes = gene_lists.get('nDEG')\n# annot_nDEG_genes = gene_list_coords(nDEG_genes)\n\nspermatid_expr_genes = gene_lists.get('meritxell_spermatid_expr')\nannot_spermatid_expr_genes = gene_list_coords(spermatid_expr_genes)\n\naccel_reg_genes = gene_lists.get('accel_reg_simiiformes_br')\n# annot_accel_reg_genes = gene_list_coords(accel_reg_genes)\n\nskipped BHLHB9\nskipped CA5BP1-CA5B\nskipped CH17-340M24.3\nskipped FAM104B\nskipped FLJ44635\nskipped IDS2\nskipped LINC00893\nskipped LINC00894\nskipped LOC101928128\nskipped LOC101928336\nskipped LOC101928415\nskipped LOC101928437\nskipped LOC101928832\nskipped LOC102724150\nskipped LOC105373133\nskipped LOC105373137\nskipped LOC105373146\nskipped LOC105373150\nskipped LOC105373151\nskipped LOC105373153\nskipped LOC105373154\nskipped LOC105373155\nskipped LOC105373182\nskipped LOC105373184\nskipped LOC105373188\nskipped LOC105373191\nskipped LOC105373194\nskipped LOC105373195\nskipped LOC105373292\nskipped LOC105373298\nskipped LOC105373302\nskipped LOC105373303\nskipped LOC105373313\nskipped LOC105373323\nskipped LOC105373335\nskipped LOC105373347\nskipped LOC105373369\nskipped LOC105373370\nskipped LOC105373383\nskipped LOC105373386\nskipped LOC105373387\nskipped LOC107985634\nskipped LOC107985664\nskipped LOC107985675\nskipped LOC107985678\nskipped LOC107985694\nskipped LOC107985695\nskipped LOC107985698\nskipped LOC107985701\nskipped LOC107985704\nskipped LOC107985707\nskipped LOC107985713\nskipped LOC107985714\nskipped LOC107985717\nskipped LOC107985719\nskipped LOC112268302\nskipped LOC728660\nskipped MAGEA10-MAGEA5\nskipped MTRNR2L10\nskipped PIR-FIGF\nskipped amplicon_chrX_CPXCR1_0\nskipped amplicon_chrX_CSAG1/2/3_0\nskipped amplicon_chrX_CSAG1/2/3_1\nskipped amplicon_chrX_CSAG1/2/3_2\nskipped amplicon_chrX_CSAG1/2/3_3\nskipped amplicon_chrX_CSAG1/2/3_4\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_0\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_1\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_10\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_11\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_12\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_13\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_14\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_15\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_16\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_2\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_3\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_4\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_5\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_6\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_7\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_8\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_9\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_0\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_1\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_10\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_11\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_12\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_13\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_2\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_3\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_4\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_5\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_6\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_7\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_8\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_9\nskipped amplicon_chrX_CT55_0\nskipped amplicon_chrX_CT55_1\nskipped amplicon_chrX_CT55_2\nskipped amplicon_chrX_CT83_0\nskipped amplicon_chrX_CT83_1\nskipped amplicon_chrX_CTAG1A/1B/2_0\nskipped amplicon_chrX_CTAG1A/1B/2_1\nskipped amplicon_chrX_CTAG1A/1B/2_2\nskipped amplicon_chrX_CXorf49/B_0\nskipped amplicon_chrX_CXorf49/B_1\nskipped amplicon_chrX_CXorf49/B_2\nskipped amplicon_chrX_CXorf49/B_3\nskipped amplicon_chrX_CXorf49/B_4\nskipped amplicon_chrX_CXorf49/B_5\nskipped amplicon_chrX_CXorf49/B_6\nskipped amplicon_chrX_CXorf49/B_7\nskipped amplicon_chrX_CXorf51A/B_0\nskipped amplicon_chrX_CXorf51A/B_1\nskipped amplicon_chrX_DDX53_0\nskipped amplicon_chrX_DMRTC1/B/FAM236A/B/C/D_0\nskipped amplicon_chrX_EOLA1/2/HSFX3/4_0\nskipped amplicon_chrX_EOLA1/2/HSFX3/4_1\nskipped amplicon_chrX_ETD1/B/ZNF75D_0\nskipped amplicon_chrX_ETD1/B/ZNF75D_1\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_0\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_1\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_2\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_3\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_4\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_5\nskipped amplicon_chrX_FAM156A/B_0\nskipped amplicon_chrX_FAM156A/B_1\nskipped amplicon_chrX_FAM47A/B/C_0\nskipped amplicon_chrX_FAM47A/B/C_1\nskipped amplicon_chrX_FAM47A/B/C_2\nskipped amplicon_chrX_G6PD/IKBKG_0\nskipped amplicon_chrX_G6PD/IKBKG_1\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_0\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_1\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_10\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_11\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_12\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_2\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_3\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_4\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_5\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_6\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_7\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_8\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_9\nskipped amplicon_chrX_HSFX1/2_0\nskipped amplicon_chrX_HSFX1/2_1\nskipped amplicon_chrX_IL3RA/P2RY8/SLC25A6_0\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_0\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_1\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_2\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_3\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_4\nskipped amplicon_chrX_MAGEA4_0\nskipped amplicon_chrX_MAGEA9/9B_0\nskipped amplicon_chrX_MAGEA9/9B_1\nskipped amplicon_chrX_MAGEB6_0\nskipped amplicon_chrX_MAGEB6_1\nskipped amplicon_chrX_MAGEC1_0\nskipped amplicon_chrX_MBTPS2/YY2_0\nskipped amplicon_chrX_MBTPS2/YY2_1\nskipped amplicon_chrX_NSDHL_0\nskipped amplicon_chrX_NUDT10/11_0\nskipped amplicon_chrX_NUDT10/11_1\nskipped amplicon_chrX_NXF2/2B/5_0\nskipped amplicon_chrX_NXF2/2B/5_1\nskipped amplicon_chrX_NXF2/2B/5_2\nskipped amplicon_chrX_PABPC1L2A/B_0\nskipped amplicon_chrX_PABPC1L2A/B_1\nskipped amplicon_chrX_PAGE2/2B/5_0\nskipped amplicon_chrX_PAGE2/2B/5_1\nskipped amplicon_chrX_PAGE2/2B/5_2\nskipped amplicon_chrX_PAGE2/2B/5_3\nskipped amplicon_chrX_RHOXF2/B_0\nskipped amplicon_chrX_RHOXF2/B_1\nskipped amplicon_chrX_SPACA5/B_0\nskipped amplicon_chrX_SPACA5/B_1\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_0\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_1\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_2\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_3\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_4\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_5\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_6\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_0\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_1\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_10\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_11\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_12\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_13\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_14\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_15\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_16\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_17\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_18\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_19\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_2\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_20\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_21\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_22\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_23\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_24\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_25\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_26\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_27\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_28\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_29\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_3\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_30\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_31\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_4\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_5\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_6\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_7\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_8\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_9\nskipped amplicon_chrX_SUPT20HL1/2_0\nskipped amplicon_chrX_SUPT20HL1/2_1\nskipped amplicon_chrX_TCEAL2/3/4/5/6_0\nskipped amplicon_chrX_TCEAL2/3/4/5/6_1\nskipped amplicon_chrX_TCEAL2/3/4/5/6_2\nskipped amplicon_chrX_TCEAL2/3/4/5/6_3\nskipped amplicon_chrX_TCEAL2/3/4/5/6_4\nskipped amplicon_chrX_TCP11X1/2_0\nskipped amplicon_chrX_TCP11X1/2_1\nskipped amplicon_chrX_TCP11X1/2_2\nskipped amplicon_chrX_TCP11X1/2_3\nskipped amplicon_chrX_TEX28_0\nskipped amplicon_chrX_TEX28_1\nskipped amplicon_chrX_TEX28_2\nskipped amplicon_chrX_TMEM185A_0\nskipped amplicon_chrX_TMEM185A_1\nskipped amplicon_chrX_VCX/2/3A/3B_0\nskipped amplicon_chrX_VCX/2/3A/3B_1\nskipped amplicon_chrX_VCX/2/3A/3B_2\nskipped amplicon_chrX_VCX/2/3A/3B_3\nskipped amplicon_chrX_XAGE1A/B_0\nskipped amplicon_chrX_XAGE1A/B_1\nskipped amplicon_chrX_XAGE3_0\nskipped amplicon_chrX_XAGE3_1\nskipped amplicon_chrX_XAGE3_2\nskipped amplicon_chrX_XAGE5_0\nskipped amplicon_chrX_XAGE5_1\n\n\n\nannot = annot_spermatid_expr_genes\nannot = [a[:3] for a in annot if a[0] == 'chrX']\nannot = sorted(list(set(annot)))\n\n\nfrom geneinfo.utils import stairs\nsample = 1000\nFs = 153000000\nf = np.linspace(5, 50, sample)\nx = np.linspace(0, Fs, sample)\ny = np.sin(2* np.pi * f * x / Fs)\nchrom = ['chrX']*sample\ndf = pd.DataFrame(dict(x=x, y=y, chrom=chrom)).sort_values('x')\ndf['start'] = df.x.shift()\ndf['end'] = df.x\ndf = df.iloc[1:-1, :]\ndf = stairs(df)\ndf.head()\n\n\n\n\n\n\n\n\nx\ny\nchrom\nstart\nend\npos\n\n\n\n\n1\n153153.153153\n0.031725\nchrX\n0.000000\n153153.153153\n0.000000\n\n\n1\n153153.153153\n0.031725\nchrX\n0.000000\n153153.153153\n153153.153153\n\n\n2\n306306.306306\n0.063984\nchrX\n153153.153153\n306306.306306\n153153.153153\n\n\n2\n306306.306306\n0.063984\nchrX\n153153.153153\n306306.306306\n306306.306306\n\n\n3\n459459.459459\n0.096740\nchrX\n306306.306306\n459459.459459\n306306.306306\n\n\n\n\n\n\n\n\nci = ChromIdeogram('chrX', axes_width_inches=18, axes_height_inches=4, ylim=(0, 10), \n                   rel_font_height=0.01, hspace=0.2, wspace=None,\n                   zooms=[(45_000_000, 55_000_000), \n                          # (65_000_000, 90_000_000), \n                           (115_000_000, 125_000_000),\n                         ]) \n\nci.draw_chromosomes(base=3.5, height=0.5, facecolor='none')\n\n# ci.add_labels(annot, \n#               colored = xi_escape_genes,\n#               bold = accel_reg_genes,\n# #              italic = spermatid_expr_genes,\n#               filled = cDEG_genes,\n# #              bold = nDEG_genes + nDEG_genes,\n#               # bold=['ZNF711', 'COX7B', 'PGK1'], \n#               # italic = ['TBX22'], \n#               # colored = ['NEXMIF', 'ATRX'],\n#               # framed = ['MAOA', 'ATRX'],\n#               # filled = ['PCDH19', 'ATRX'],\n#              )\n\n# ci.map_fun(horizonplot, data=df, x='x', y='y', offset=0, height=1000000)\nci.horizon(data=df, x='x', y='y', base=3.5, height=0.5, alpha=0.2)\n\n\n\n\nci.add_segments([('chrX', 25e6, 55e6), \n                 ('chrX', 98e6, 102e6)], label='segments', alpha=0.7)\nci.add_segments([('chrX', 115e6, 135e6)], facecolor='red', base=3.5, height=0.25, label='red segments', alpha=0.7)\nci.add_segments([('chrX', 125e6, 145e6)], facecolor='green', base=3.75, height=0.25, label='green segments', alpha=0.7)\nci.add_segments([('chrX', 35e6, 45e6), \n                 ('chrX', 100e6, 102e6), \n                 ('chrX', 120e6, 132e6)], facecolor='blue', base=3, height=0.25, label='blue segments', alpha=0.7)\n\nci.add_vlines()\nci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 1), s=5, c='C1', label='seaborn')\nci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(1.5, 2.4), s=5, c='C2', label='matplotlib')\nci.legend()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 39\n     37 ci.add_vlines()\n     38 ci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 1), s=5, c='C1', label='seaborn')\n---&gt; 39 ci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(1.5, 2.4), s=5, c='C2', label='matplotlib')\n     40 ci.legend()\n\nNameError: name 'Axes' is not defined\n\n\n\n\n\n\n\n\n\n\n\n##########################################################################################\n# interface\n##########################################################################################\n\nci = ChromIdeogram('chrX', axes_width_inches=18, axes_height_inches=3, ylim=(0, 3), rel_font_height=0.03) # plots chromosome\n\n# ci.draw_chromosomes(base=1, height=0.10, facecolor='lightgray')\nci.draw_chromosomes(base=1, height=0.20, facecolor='none')\n\nci.add_labels(annot)\n\nci.add_segments([('chrX', 25e6, 55e6), \n                 ('chrX', 98e6, 102e6)], label='segments', alpha=0.7)\nci.add_segments([('chrX', 115e6, 135e6)], facecolor='red', base=1, height=0.1, label='red segments', alpha=0.7)\nci.add_segments([('chrX', 125e6, 145e6)], facecolor='green', base=1.1, height=0.1, label='green segments', alpha=0.7)\nci.add_segments([('chrX', 35e6, 45e6), \n                 ('chrX', 100e6, 102e6), \n                 ('chrX', 120e6, 132e6)], facecolor='blue', base=0.8, height=0.1, label='blue segments', alpha=0.7)\n\nci.add_vlines()\n\n# plot using function that takes data and column name keyword args for dimensions (like seaborn's sns.scatterplot)\nci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.1, 0.3), s=5, c='C1', label='seaborn')\n\nfrom matplotlib.axes import Axes\n# plot using matplotlib Axes method that x and y positional arguments (like matplotlib's Axes.scatter)\nci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(0.4, 0.6), s=5, c='C2', label='matplotlib')\n\nci.legend()\n\n##########################################################################################\n# add axis\n##########################################################################################\n\nnew_ax, new_ax2, new_ax3 = ci.add_axes(3, height_ratio=0.3, hspace=0.3)\n\n\nnew_ax.vlines(list(range(*map(int, new_ax.get_xlim()), 2_000_000)), *new_ax.get_ylim(), color='gray', linewidth=0.1)\n\n# new_ax.plot(np.linspace(*new_ax.get_xlim(), 100), np.random.random(100), label='Line')\n_df = stairs(df)\nnew_ax.plot(_df.pos, _df.y, label='Stairs')\nnew_ax.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\n# new_ax2.scatter(np.linspace(*new_ax.get_xlim(), 100), np.random.random(100), s=5, label='Scatter')\nnew_ax2.scatter(df.x, df.y, s=5, c='black',label='Scatter')\nadd_lowess(df.x, df.y, ax=new_ax2, frac=0.02, c='red', label='Lowess')\nnew_ax2.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\n\nhorizonplot(df, y='y', ax=new_ax3)\n\n\n##########################################################################################\n# info annotation\n##########################################################################################\n\nfrom matplotlib.text import OffsetFrom\nimport textwrap\n\nstrs = \"DYNLT3: lka dflaks dlfkajs ldkajs dlfkajsd fasdfasdfl lakjsd las dflasd jflaksdj flaksjdf laksdjf laksdjf a flaksdj fla\"\n\nannot_kwargs=dict(fontsize=5, ha=\"left\", va=\"bottom\",\n             bbox=dict(\n                 # fc=\"0.97\", \n                 fc=\"w\",\n                 ec=\"red\",\n                       # alpha=0.2, \n                 linewidth=0.7),\n\n    arrowprops=dict(\n        facecolor='red', # color of arrow\n        shrink=0.01, # distance from point\n        width=1.5, # width of arrow\n        headwidth=5, # width of arrow head\n        headlength=7, # length of arrow head\n        connectionstyle=\"angle3,angleA=0,angleB=-90\", \n        # alpha=0.7,\n    ) \n                  \n             # arrowprops=dict(facecolor='red', arrowstyle=\"fancy\", \n             #                 connectionstyle=\"angle3,angleA=0,angleB=-90\", alpha=0.9)\n                  \n                 )\n\nci.ax.annotate(textwrap.fill(strs, 40), xy=(60000000, ci.map_y(1.2, ci.ax)), xytext=(30000000, ci.map_y(3.1, ci.ax)), xycoords=\"data\", textcoords=\"data\", **annot_kwargs)\n           \nci.ax.annotate(textwrap.fill(strs, 40), xy=(120000000, ci.map_y(1.2, ci.ax)), xytext=(100000000, ci.map_y(3.1, ci.ax)), xycoords=\"data\", textcoords=\"data\", **annot_kwargs) ;\n\nnew_ax.annotate(textwrap.fill(strs, 40), xy=(0.8, 0.7), xytext=(800, 200), xycoords=\"axes fraction\",\n             textcoords=OffsetFrom(ax.bbox, (0, 0), \"points\"), **annot_kwargs) ;\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 47\n     45 # new_ax2.scatter(np.linspace(*new_ax.get_xlim(), 100), np.random.random(100), s=5, label='Scatter')\n     46 new_ax2.scatter(df.x, df.y, s=5, c='black',label='Scatter')\n---&gt; 47 add_lowess(df.x, df.y, ax=new_ax2, frac=0.02, c='red', label='Lowess')\n     48 new_ax2.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n     51 horizonplot(df, y='y', ax=new_ax3)\n\nNameError: name 'add_lowess' is not defined"
  },
  {
    "objectID": "pages/chrom_ideograms.html",
    "href": "pages/chrom_ideograms.html",
    "title": "Chromosome ideograms",
    "section": "",
    "text": "%load_ext autoreload\n%autoreload 2\nfrom collections import defaultdict\nimport random\nrandom.seed(7)\nimport pandas as pd\nimport numpy  as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('white')\nfrom random import randint\nfrom geneinfo.plot import GenomeIdeogram, ChromIdeogram\nfrom geneinfo.utils import stairs, fit_lowess, horizon\nimport matplotlib\nfrom matplotlib.axes import Axes\n\nimport re\n\n%matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\n%config InlineBackend.figure_format = 'svg'\n\nimport geneinfo.information as gi\n#gi.email('your@email.com')\n\nfrom geneinfo import utils\nlists = utils.GoogleSheet()\nlists\n\n\n\n\n\n\n\n\nlabel\ndescription\n\n\n\n\nall_npx\nall NPX genes\n\n\nneuron_genome_proteome\nNeuron proteome (whole genome)\n\n\nneuron_npx_proteome\nNPX neuron proteome\n\n\nmatos_neuron\nMatos neuron genes\n\n\nmatos_common\nMatos neuron genes expressed in spermatids\n\n\nhpa_brain_prot\nBrain genes form Human protein atlas\n\n\nmeritxell_spermatid_expr\n\n\n\nintersection(nDEG, matos_neuron)\n\n\n\nunion(H,matos_common)\n\n\n\nmult_copy\n\n\n\nall_post_mei_expr\nMulti copy genes\n\n\nmsci\nall post.mei.expr. X genes\n\n\nmsci_esc\nMSCI genes\n\n\nmy_primate_codeml\nMSCI-escaping\n\n\ncDEG\nPrimate codeml site model\n\n\nnDEG\ncDEG\n\n\nprimate_ampl_multi\nnDEG\n\n\ngametologs\nAmpliconic or multicopy in some primates\n\n\nxi\nGametologs in some primates\n\n\nxi_escape\nSubject to somatic X inactivation (XI)\n\n\nxi_uncertain\nEscaping somatic X inactivation (XI)\n\n\nxi_any_evidence\nX genes uncertain XI status\n\n\nexpr_mod_xi_copynr_fibrobl\nUnion of certain and uncertain XI status\n\n\nexpr_mod_xi_copynr_lcl\nExpression modulated by Xi copy number (Fibroblast)\n\n\nreg_sa_pheno\nExpression modulated by Xi copy number (LCL)\n\n\nari_relate_EUR\nX-chromosome genes associated with regional SA phenotypes\n\n\nari_relate_ASIA\n\n\n\nari_relate_AFR\n\n\n\nari_nonPUR\n\n\n\nari_relate_PUR\n\n\n\nari_all\n\n\n\ncandidates\n\n\n\nech75_regions\nCandidate for explaining human and baboon sweeps\n\n\nech90_regions\nOverlapping human sweeps (75% ECH regions)\n\n\naccel_reg_simiiformes_br\nOverlapping human sweeps (90% ECH regions)\n\n\nsfari_all_conf\nGenes with accelerated regions Simiiformes branch\n\n\nintel_seiz_lang\nX SFARI genes (including all confidence levels)\n\n\nintelect_disabil\nIntellectual disability or Seizures or Language impairment\n\n\nmatos_common_no_xy_gametologs\nIntelectual disbility",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#dummy-sample-data",
    "href": "pages/chrom_ideograms.html#dummy-sample-data",
    "title": "Chromosome ideograms",
    "section": "Dummy sample data",
    "text": "Dummy sample data\n\ndf = utils.dummy_data()\nsegments = utils.dummy_segments()",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#all-chromosome-ideogram",
    "href": "pages/chrom_ideograms.html#all-chromosome-ideogram",
    "title": "Chromosome ideograms",
    "section": "All chromosome ideogram",
    "text": "All chromosome ideogram\nSegments:\n\ngid = GenomeIdeogram() \ngid.draw_chromosomes()",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#single-chromosome-ideogram",
    "href": "pages/chrom_ideograms.html#single-chromosome-ideogram",
    "title": "Chromosome ideograms",
    "section": "Single chromosome ideogram",
    "text": "Single chromosome ideogram\n\ncid = ChromIdeogram('chrX')\ncid.draw_chromosomes()",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#the-coordinate-system",
    "href": "pages/chrom_ideograms.html#the-coordinate-system",
    "title": "Chromosome ideograms",
    "section": "The coordinate system",
    "text": "The coordinate system\nThe x-axis follow the chromosome coordinates along the ideogram. Behind the scenes, the y-axis for each ideogram has the same scale as its x-axis. But this is mapped to a more sensible range that is (0, 10) by default can be controlled by the ylim keyword argument:\n\ncid = ChromIdeogram('chrX', ylim=(0, 30))\ncid.draw_chromosomes()",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#ideogram-size-and-plament",
    "href": "pages/chrom_ideograms.html#ideogram-size-and-plament",
    "title": "Chromosome ideograms",
    "section": "Ideogram size and plament",
    "text": "Ideogram size and plament\n\ncid = ChromIdeogram('chrX')\ncid.draw_chromosomes(base=1, height=4)",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#showing-data-on-ideograms",
    "href": "pages/chrom_ideograms.html#showing-data-on-ideograms",
    "title": "Chromosome ideograms",
    "section": "Showing data on ideograms",
    "text": "Showing data on ideograms\n\ngid = GenomeIdeogram() \ngid.draw_chromosomes()\ngid.add_segments(segments, facecolor='tab:blue', alpha=0.5)\n\n\n\n\n\n\n\n\nTo make sure segments are visible on the plot, the default minimal size of plotteed segments are 200000. This can be changed like this (notice how the chr1 segment is no longer visible):\n\nsegments_with_alpha = [(*t, np.random.random()) for t in segments]\nsegments_with_alpha[:3]\n\n[('chr1', 10065165, 12961789, 0.8436340944814724),\n ('chr1', 15568967, 18751672, 0.9366558594839778),\n ('chr1', 19444467, 23071285, 0.15548690510483776)]\n\n\n\ngid = GenomeIdeogram() \ngid.draw_chromosomes()\ngid.add_segments(segments_with_alpha, facecolor='tab:blue')\n\n\n\n\n\n\n\n\nYou can also make consequtive segments with individual alpha values to evalutate a statistic across the chromosomes. Below I make 100kb windows with sin values:\n\nlength = utils.chrom_lengths['hg38']['chrX']\nwin = 100_000\nx = range(0, length, win)\nf = np.linspace(5, 10, len(x))\ny = np.sin(2* np.pi * f * x / length) / 2 + 1/2\nchrom = ['chrX']*len(x)\nshaded_segments = [('chrX', s, s+win, a) for s, a in zip(x, y)]\nshaded_segments[:3]\n\n[('chrX', 0, 100000, 0.5),\n ('chrX', 100000, 200000, 0.5100723398623864),\n ('chrX', 200000, 300000, 0.5201534872481727)]\n\n\n\ncid = ChromIdeogram('chrX') \ncid.draw_chromosomes()\ncid.add_segments(shaded_segments, facecolor='tab:red')",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#combinatorial-highlighting",
    "href": "pages/chrom_ideograms.html#combinatorial-highlighting",
    "title": "Chromosome ideograms",
    "section": "Combinatorial highlighting",
    "text": "Combinatorial highlighting\n\ncid = ChromIdeogram('chr2', rel_font_height=0.07)\ncid.draw_chromosomes()\ncid.add_labels(sample_gene_coord,\n             colored=['NCOA1', 'CHST10', 'CPS1'],\n             filled=['STAMBP', 'SP140L'],\n             framed=['NCOA1', 'C2orf88', 'STAMBP'],\n             bold=['NCOA1', 'SP140L', 'EPC2'],\n             italic=['EPC2'],\n             )\n\n\n\n\n\n\n\n\n\ncid = ChromIdeogram('chr2', rel_font_height=0.07)\ncid.draw_chromosomes()\ncid.add_labels(sample_gene_coord_with_sizes,\n             colored=['NCOA1', 'CHST10', 'CPS1'],\n             filled=['STAMBP', 'SP140L'],\n             framed=['NCOA1', 'C2orf88', 'STAMBP'],\n             bold=['NCOA1', 'SP140L', 'EPC2'],\n             italic=['EPC2'],\n             )\n\n\n\n\n\n\n\n\nYou can do all the same things as with GenomeIdeogram:\n\ncid = ChromIdeogram('chrX', rel_font_height=0.05)\n\n# ci.draw_chromosomes(base=1, height=0.10, facecolor='lightgray')\ncid.draw_chromosomes()\n\ncid.add_labels(sample_gene_coord)\n\ncid.add_segments([('chrX', 25e6, 55e6), \n                 ('chrX', 98e6, 102e6)], label='segments', alpha=0.7)\ncid.add_segments([('chrX', 115e6, 135e6)], facecolor='red', base=4, height=1, label='red segments', alpha=0.7)\ncid.add_segments([('chrX', 125e6, 145e6)], facecolor='green', base=5, height=1, label='green segments', alpha=0.7)\ncid.add_segments([('chrX', 35e6, 45e6), \n                 ('chrX', 100e6, 102e6), \n                 ('chrX', 120e6, 132e6)], facecolor='blue', base=3, height=1, label='blue segments', alpha=0.7)\n\ncid.add_vlines()\n\n# plot using function that takes data and column name keyword args for dimensions (like seaborn's sns.scatterplot)\ncid.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 1.5), s=5, c='C1', label='seaborn')\n\n# plot using matplotlib Axes method that x and y positional arguments (like matplotlib's Axes.scatter)\ncid.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(1.5, 2.5), s=5, c='C2', label='matplotlib')\n\ncid.add_legend()\n\n\n\n\n\n\n\n\n\nAdditional axes\n\nci = ChromIdeogram('chrX') # plots chromosome\nci.draw_chromosomes(base=2, facecolor='none')\n\nnew_ax, new_ax2, new_ax3 = ci.add_axes(3, height_ratio=0.6, hspace=0.5)\n\n_df = stairs(df.loc[df.chrom == 'chrX'])\nnew_ax.plot(_df.pos, _df.y, label='Stairs')\nnew_ax.vlines(np.arange(*new_ax.get_xlim(), 2_000_000), *new_ax.get_ylim(), color='gray', linewidth=0.1)\nnew_ax.hlines(np.arange(*new_ax.get_ylim(), 1), *new_ax.get_xlim(), color='gray', linewidth=0.1)\nnew_ax.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\nnew_ax2.scatter(df.loc[df.chrom == 'chrX', 'x'], df.loc[df.chrom == 'chrX', 'y'], s=5, c='black',label='Scatter')\nfit = fit_lowess(df.loc[df.chrom == 'chrX'], 'x', 'y')\nnew_ax2.plot(fit.x, fit.y, c='red', label='Lowess')\nnew_ax2.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\nnew_ax3.scatter(df.loc[df.chrom == 'chrX', 'x'], df.loc[df.chrom == 'chrX', 'y'], s=5, c='black',label='Scatter')\nfit = fit_lowess(df.loc[df.chrom == 'chrX'], 'x', 'y', frac=0.05)\nnew_ax3.plot(fit.x, fit.y, c='red', label='Lowess')\nnew_ax3.legend(loc='center left', bbox_to_anchor=(1.02, 0.3), fontsize=\"10\", frameon=False) ;",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#floating-annotations",
    "href": "pages/chrom_ideograms.html#floating-annotations",
    "title": "Chromosome ideograms",
    "section": "Floating annotations",
    "text": "Floating annotations\n\nci = ChromIdeogram('chrX') \nci.draw_chromosomes(base=2) \n\nnew_ax, new_ax2 = ci.add_axes(2, height_ratio=0.6, hspace=0.5)\n\n_df = stairs(df.loc[df.chrom == 'chrX'])\nnew_ax.plot(_df.pos, _df.y, label='Stairs')\nnew_ax.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\nnew_ax2.scatter(df.loc[df.chrom == 'chrX', 'x'], df.loc[df.chrom == 'chrX', 'y'], s=5, c='black',label='Scatter')\nfit = fit_lowess(df.loc[df.chrom == 'chrX'], 'x', 'y')\nnew_ax2.plot(fit.x, fit.y, c='red', label='Lowess')\nnew_ax2.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\nfrom matplotlib.text import OffsetFrom\nimport textwrap\n\nannot_kwargs=dict(fontsize=7, ha=\"left\", va=\"bottom\",\n                  bbox=dict(facecolor=\"white\", edgecolor=\"red\", linewidth=1),\n                  arrowprops=dict(facecolor='red', # color of arrow\n                                  shrink=0.01, # distance from point\n                                  width=1.5, # width of arrow\n                                  headwidth=5, # width of arrow head\n                                  headlength=7, # length of arrow head\n                                  connectionstyle=\"angle3,angleA=0,angleB=-90\"))\n\n# ci.ax.annotate(textwrap.fill(\"This is the beginning of the chromosome.\", 20), \n#                xy=(0, ci.map_y(4, ci.ax)), xycoords=\"data\", \n#                # xytext=(10000000, ci.map_y(8, ci.ax)), textcoords=\"data\", \n#                xytext=(50, 50), textcoords=OffsetFrom(ci.ax.bbox, (0, 0), \"points\"),\n#                **annot_kwargs)\n           \n# ci.ax.annotate(textwrap.fill(\"This is the centromere.\", 20),\n#                xy=(60000000, ci.map_y(4, ci.ax)), xycoords=\"data\", \n#                # xytext=(40000000, ci.map_y(9, ci.ax)), textcoords=\"data\", \n#                xytext=(261, 50), textcoords=OffsetFrom(ci.ax.bbox, (0, 0), \"points\"),\n\n#                **annot_kwargs) ;\n\n# new_ax2.annotate(textwrap.fill(\"This is something you might want to say about a plot in another axes\", 30), \n#                 xy=(120000000, 1), xycoords=\"data\",\n#                 xytext=(120000000/point_in_bases, ci.map_y(4, ci.ax)/point_in_bases), textcoords=OffsetFrom(ci.ax.bbox, (0, 0), \"points\"),\n#                 **annot_kwargs) ;\n\ndef annotate(ax, point, testpos, text):\n\n    annot_kwargs=dict(fontsize=7, ha=\"left\", va=\"bottom\",\n                  bbox=dict(facecolor=\"white\", edgecolor=\"red\", linewidth=1),\n                  arrowprops=dict(facecolor='red', # color of arrow\n                                  shrink=0.01, # distance from point\n                                  width=1.5, # width of arrow\n                                  headwidth=5, # width of arrow head\n                                  headlength=7, # length of arrow head\n                                  connectionstyle=\"angle3,angleA=0,angleB=-90\"))\n    fig = ci.fig\n    bbox = ci.ax.get_window_extent()\n    dpi = fig.dpi\n    height = bbox.height / dpi  # in inches\n    width = bbox.width / dpi  # in inches\n    point_in_bases = ci.ax.get_xlim()[1]/(width*72)\n    if ax == ci.ax:\n       point = (point[0], ci.map_y(point[1], ci.ax))\n\n    ax.annotate(textwrap.fill(text, 30), \n                xy=point, \n                xycoords=\"data\",\n                xytext=(testpos[0]/point_in_bases, ci.map_y(testpos[1], ci.ax)/point_in_bases), textcoords=OffsetFrom(ci.ax.bbox, (0, 0), \"points\"),\n                **annot_kwargs) ;\n\n\n\nannotate(ci.ax, (0, 4), (10000000, 4), \"This is the beginning of the chromosome\")\nannotate(ci.ax, (61000000, 4), (40000000, 4), \"This is the centromere\")\nannotate(new_ax2, (90000000, 1), (90000000, 5), \"Something important in another axes\")\n\n# fig = ci.fig\n# bbox = ci.ax.get_window_extent()\n# dpi = fig.dpi\n# height = bbox.height / dpi  # in inches\n# width = bbox.width / dpi  # in inches\n# point_in_bases = ci.ax.get_xlim()[1]/(width*72)\n\n# 500* point_in_bases\n\n\n\n\n\n\n\n\n\n11 * 72\n\n720",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms.html#zooms",
    "href": "pages/chrom_ideograms.html#zooms",
    "title": "Chromosome ideograms",
    "section": "Zooms",
    "text": "Zooms\n\nfrom geneinfo.plot import ChromIdeogram\n\nci = ChromIdeogram('chrX',\n                   rel_font_height=0.01, \n                   zooms=[(45_000_000, 55_000_000), \n                          # (65_000_000, 90_000_000), \n                           (100_000_000, 120_000_000),\n                         ]) \n\nci.draw_chromosomes(base=3.5, height=1, facecolor='none')\n\nci.add_horizon(data=df, alpha=0.5)\n\n#ci.add_vlines()\nci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 1), s=5, c='C1', label='seaborn')\nci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(1.5, 2.4), s=5, c='C2', label='matplotlib')\n\nci.map_method(Axes.plot, data=fit_lowess(df, 'x', 'y', frac=0.02), x='x', y='y', yaxis=(1.5, 2.4), c='red', label='Lowess')\n\n# ci.add_lowess(df.x, df.y, ax=new_ax2, frac=0.02, c='red', label='Lowess')\n\nci.legend()",
    "crumbs": [
      "Gene plots",
      "Chromosome ideograms"
    ]
  },
  {
    "objectID": "pages/basics.html",
    "href": "pages/basics.html",
    "title": "Basic use",
    "section": "",
    "text": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis sagittis posuere ligula sit amet lacinia. Duis dignissim pellentesque magna, rhoncus congue sapien finibus mollis. Ut eu sem laoreet, vehicula ipsum in, convallis erat. Vestibulum magna sem, blandit pulvinar augue sit amet, auctor malesuada sapien. Nullam faucibus leo eget eros hendrerit, non laoreet ipsum lacinia. Curabitur cursus diam elit, non tempus ante volutpat a. Quisque hendrerit blandit purus non fringilla. Integer sit amet elit viverra ante dapibus semper. Vestibulum viverra rutrum enim, at luctus enim posuere eu. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.\nUt ut condimentum augue, nec eleifend nisl. Sed facilisis egestas odio ac pretium. Pellentesque consequat magna sed venenatis sagittis. Vivamus feugiat lobortis magna vitae accumsan. Pellentesque euismod malesuada hendrerit. Ut non mauris non arcu condimentum sodales vitae vitae dolor. Nullam dapibus, velit eget lacinia rutrum, ipsum justo malesuada odio, et lobortis sapien magna vel lacus. Nulla purus neque, hendrerit non malesuada eget, mattis vel erat. Suspendisse potenti."
  },
  {
    "objectID": "pages/basics.html#some-topic",
    "href": "pages/basics.html#some-topic",
    "title": "Basic use",
    "section": "Some topic",
    "text": "Some topic\nFinding Python objects to document involves two pieces of configuration:\n\nthe package name.\na list of objects for content.\n\nquartodoc can look up a wide variety of objects, including functions, modules, classes, attributes, and methods:"
  },
  {
    "objectID": "pages/string_nets.html",
    "href": "pages/string_nets.html",
    "title": "String networks",
    "section": "",
    "text": "import geneinfo as gi\ngi.email('your@email.com')",
    "crumbs": [
      "Gene plots",
      "String networks"
    ]
  },
  {
    "objectID": "pages/string_nets.html#show-string-interaction-network",
    "href": "pages/string_nets.html#show-string-interaction-network",
    "title": "String networks",
    "section": "Show STRING interaction network",
    "text": "Show STRING interaction network\n\ngi.show_string_network(['ATRX', 'TP53', 'RAD51'], nodes=10)",
    "crumbs": [
      "Gene plots",
      "String networks"
    ]
  },
  {
    "objectID": "pages/go_enrichment.html",
    "href": "pages/go_enrichment.html",
    "title": "GO enrichment",
    "section": "",
    "text": "import pandas as pd\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport geneinfo as gi\ngi.email('your@email.com')\nclass left:\n    def __rlshift__(self, df):\n        \"Left align columns of data frame: df &lt;&lt; left()\"\n        left_aligned_df = df.style.set_properties(**{'text-align': 'left'})\n        left_aligned_df = left_aligned_df.set_table_styles(\n        [dict(selector = 'th', props=[('text-align', 'left')])])\n        display(left_aligned_df)\n        \ndf = pd.DataFrame(dict(name=['A', 'B'], desc=['bla bla bla bla', 'bla']))\ndf",
    "crumbs": [
      "Gene ontology",
      "GO enrichment"
    ]
  },
  {
    "objectID": "pages/go_enrichment.html#global-go-enrichment",
    "href": "pages/go_enrichment.html#global-go-enrichment",
    "title": "GO enrichment",
    "section": "Global GO enrichment",
    "text": "Global GO enrichment\nEnrichment against all GO terms with all protein coding genes as background:\n\nimport importlib\nimport geneinfo\nimportlib.reload(geneinfo)\n\n&lt;module 'geneinfo' from '/Users/kmt/geneinfo/geneinfo/__init__.py'&gt;\n\n\n\ngo_results = gi.go_enrichment(motor_genes_df.symbol)\ngo_results.head(10)\n\nCould not map gene symbol \"KIF28P\" to ncbi id\n\n\n\n\n\n\n\n\n\nnamespace\nterm_id\ne/p\npval_uncorr\np_fdr_bh\nratio\nbg_ratio\nobj\n\n\n\n\n0\nCC\nGO:0005874\ne\n3.174662e-104\n5.793757e-101\n0.296407\n0.014664\n&lt;GO:0005874&gt;\n\n\n1\nBP\nGO:0007018\ne\n3.469444e-87\n4.220231e-83\n0.152695\n0.002719\n&lt;GO:0007018&gt;\n\n\n2\nCC\nGO:0005871\ne\n1.323152e-82\n1.207376e-79\n0.134731\n0.002185\n&lt;GO:0005871&gt;\n\n\n3\nMF\nGO:0008017\ne\n2.849730e-80\n1.305176e-76\n0.239521\n0.012819\n&lt;GO:0008017&gt;\n\n\n4\nCC\nGO:0005813\ne\n1.960675e-77\n1.192744e-74\n0.314371\n0.030444\n&lt;GO:0005813&gt;\n\n\n5\nMF\nGO:0019894\ne\n4.661206e-77\n1.067416e-73\n0.125749\n0.002039\n&lt;GO:0019894&gt;\n\n\n6\nCC\nGO:0032391\ne\n3.269844e-75\n1.491866e-72\n0.122754\n0.001991\n&lt;GO:0032391&gt;\n\n\n7\nMF\nGO:0003777\ne\n5.259928e-70\n8.030157e-67\n0.125749\n0.002331\n&lt;GO:0003777&gt;\n\n\n8\nMF\nGO:0045505\ne\n7.657838e-68\n8.768225e-65\n0.110778\n0.001797\n&lt;GO:0045505&gt;\n\n\n9\nCC\nGO:0016235\ne\n3.632820e-64\n1.325979e-61\n0.104790\n0.001699\n&lt;GO:0016235&gt;\n\n\n\n\n\n\n\nShow GO DAG for enrichment results:\n\ngi.show_go_dag_enrichment_results(go_results.obj)\n\n\n\n\n\n\n\n\nSame but only for top 10 GO terms:\n\ngi.show_go_dag_enrichment_results(go_results.obj[:10])\n\n\n\n\n\n\n\n\nDescriptions of the same 10 GO terms:\n\ngi.go_info(go_results.term_id[:10])\n\nGO:0005874: microtubule\nAny of the long, generally straight, hollow tubes of internal diameter 12-15 nm and external diameter 24 nm found in a wide variety of eukaryotic cells; each consists (usually) of 13 protofilaments of polymeric tubulin, staggered in such a manner that the tubulin monomers are arranged in a helical pattern on the microtubular surface, and with the alpha/beta axes of the tubulin subunits parallel to the long axis of the tubule; exist in equilibrium with pool of tubulin monomers and can be rapidly assembled or disassembled in response to physiological stimuli; concerned with force generation, e.g. in the spindle.\n\n\n\nGO:0007018: microtubule-based movement\nA microtubule-based process that results in the movement of organelles, other microtubules, or other cellular components. Examples include motor-driven movement along microtubules and movement driven by polymerization or depolymerization of microtubules.\n\n\n\nGO:0005871: kinesin complex\nAny complex that includes a dimer of molecules from the kinesin superfamily, a group of related proteins that contain an extended region of predicted alpha-helical coiled coil in the main chain that likely produces dimerization. The native complexes of several kinesin family members have also been shown to contain additional peptides, often designated light chains as all of the noncatalytic subunits that are currently known are smaller than the chain that contains the motor unit. Kinesin complexes generally possess a force-generating enzymatic activity, or motor, which converts the free energy of the gamma phosphate bond of ATP into mechanical work.\n\n\n\nGO:0008017: microtubule binding\nBinding to a microtubule, a filament composed of tubulin monomers.\n\n\n\nGO:0005813: centrosome\nA structure comprised of a core structure (in most organisms, a pair of centrioles) and peripheral material from which a microtubule-based structure, such as a spindle apparatus, is organized. Centrosomes occur close to the nucleus during interphase in many eukaryotic cells, though in animal cells it changes continually during the cell-division cycle.\n\n\n\nGO:0019894: kinesin binding\nInteracting selectively and non-covalently and stoichiometrically with kinesin, a member of a superfamily of microtubule-based motor proteins that perform force-generating tasks such as organelle transport and chromosome segregation.\n\n\n\nGO:0032391: photoreceptor connecting cilium\nThe portion of the photoreceptor cell cilium linking the photoreceptor inner and outer segments. It’s considered to be equivalent to the ciliary transition zone.\n\n\n\nGO:0003777: microtubule motor activity\nA motor activity that generates movement along a microtubule, driven by ATP hydrolysis.\n\n\n\nGO:0045505: dynein intermediate chain binding\nBinding to an intermediate chain of the dynein complex.\n\n\n\nGO:0016235: aggresome\nAn inclusion body formed by dynein-dependent retrograde transport of an aggregated protein on microtubules.\n\n\n\nShow the GO DAG for a set of GO terms and their parent terms:\n\ngi.show_go_dag_for_terms(go_results.term_id[:10])\n\n\n\n\n\n\n\n\nSpecifying a custom set of background genes:\nThe query genes should be a subset of the background genes:\n\nall_protein_coding = set(pd.read_csv('geneinfo_cache/9606_protein_genes.txt', sep='\\t').Symbol)\n# only the first 50 genes:\nsubset_background = list(all_protein_coding)[:50] + motor_genes_df.symbol.tolist()\n\n\ngo_results = gi.go_enrichment(motor_genes_df.symbol, background_genes=subset_background)\ngo_results\n\nCould not map gene symbol \"KIF28P\" to ncbi id\nCould not map gene symbol \"KIF28P\" to ncbi id\n\n\n\n\n\n\n\n\n\nnamespace\nterm_id\ne/p\npval_uncorr\np_fdr_bh\nratio\nbg_ratio\nobj\n\n\n\n\n0\nCC\nGO:0005813\ne\n8.279747e-07\n0.000378\n0.314371\n0.276042\n&lt;GO:0005813&gt;\n\n\n1\nCC\nGO:0005874\ne\n2.975553e-06\n0.000678\n0.296407\n0.260417\n&lt;GO:0005874&gt;\n\n\n2\nCC\nGO:0005737\ne\n2.878076e-05\n0.004375\n0.538922\n0.497396\n&lt;GO:0005737&gt;\n\n\n3\nMF\nGO:0000981\np\n9.358545e-05\n0.018951\n0.011976\n0.028646\n&lt;GO:0000981&gt;\n\n\n4\nMF\nGO:0008017\ne\n6.502644e-05\n0.018951\n0.239521\n0.210938\n&lt;GO:0008017&gt;\n\n\n5\nCC\nGO:0005929\ne\n3.614207e-04\n0.032962\n0.164671\n0.143229\n&lt;GO:0005929&gt;\n\n\n6\nCC\nGO:0036064\ne\n3.598807e-04\n0.032962\n0.167665\n0.145833\n&lt;GO:0036064&gt;\n\n\n7\nCC\nGO:0005930\ne\n6.152330e-04\n0.046758\n0.155689\n0.135417\n&lt;GO:0005930&gt;\n\n\n8\nCC\nGO:0005829\ne\n7.499627e-04\n0.048855\n0.494012\n0.460938\n&lt;GO:0005829&gt;\n\n\n\n\n\n\n\nUse only the X chromosome as background:\n\ngo_results = gi.go_enrichment(motor_genes_df.symbol, background_chrom='X')\ngo_results\n\nCould not map gene symbol \"KIF28P\" to ncbi id\n\n\n\n\n\n\n\n\n\nnamespace\nterm_id\ne/p\npval_uncorr\np_fdr_bh\nratio\nbg_ratio\nobj\n\n\n\n\n0\nMF\nGO:0045505\ne\n0.000041\n0.010017\n0.333333\n0.002345\n&lt;GO:0045505&gt;\n\n\n1\nMF\nGO:0070840\ne\n0.000041\n0.010017\n0.333333\n0.002345\n&lt;GO:0070840&gt;\n\n\n2\nMF\nGO:0008017\ne\n0.000031\n0.010017\n0.500000\n0.012896\n&lt;GO:0008017&gt;\n\n\n3\nCC\nGO:0016235\ne\n0.000041\n0.020475\n0.333333\n0.002345\n&lt;GO:0016235&gt;",
    "crumbs": [
      "Gene ontology",
      "GO enrichment"
    ]
  },
  {
    "objectID": "pages/go_enrichment.html#enrichment-among-a-subset-of-go-terms",
    "href": "pages/go_enrichment.html#enrichment-among-a-subset-of-go-terms",
    "title": "GO enrichment",
    "section": "Enrichment among a subset of GO terms",
    "text": "Enrichment among a subset of GO terms\nExtract terms matching regular expression:\n\n#target_terms = gi.get_terms_for_go_regex('brain')\n#target_terms = gi.get_terms_for_go_regex('microtubul')\n# target_terms = gi.get_terms_for_go_regex('spindle')\ntarget_terms = gi.get_terms_for_go_regex(r'neuron\\S* migration')\ngi.show_go_dag_for_terms(target_terms)\n\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-09-08) 44,296 Terms; optional_attrs(comment def relationship synonym xref)\n\n\n\n\n\n\n\n\n\n\ngo_results = gi.go_enrichment(motor_genes_df.symbol, terms=target_terms, list_study_genes=True)\ngo_results.head()\n\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-09-08) 44,296 Terms; optional_attrs(def relationship)\n\n\nCould not map gene symbol \"KIF28P\" to ncbi id\n\n\n\n\n\n\n\n\n\nnamespace\nterm_id\ne/p\npval_uncorr\np_fdr_bh\nratio\nbg_ratio\nobj\nstudy_genes\n\n\n\n\n0\nCC\nGO:0005615\np\n0.000016\n0.000063\n0.020958\n0.076426\n&lt;GO:0005615&gt;\n[ACTB, BLOC1S1, HSPA1A, SNCA, LRP8, DYNC2I1, T...\n\n\n1\nCC\nGO:0032991\ne\n0.000155\n0.000310\n0.071856\n0.031027\n&lt;GO:0032991&gt;\n[ACTB, HTT, HNRNPU, HSPA1A, HSPA1B, HSP90AB1, ...\n\n\n2\nBP\nGO:0140650\ne\n0.000778\n0.031519\n0.005988\n0.000146\n&lt;GO:0140650&gt;\n[PAFAH1B1, NDEL1]\n\n\n3\nBP\nGO:0001764\ne\n0.000515\n0.031519\n0.023952\n0.005487\n&lt;GO:0001764&gt;\n[BBS4, PAFAH1B1, PCM1, PSEN1, DISC1, DCDC2, ND...\n\n\n\n\n\n\n\n\ngi.show_go_dag_enrichment_results(go_results.obj)\n\n\n\n\n\n\n\n\nExtract terms matching two regular expressions in any order:\n\npattern_one = r'microtub\\S*'\npattern_two = r'spindle'\nregex = fr\"(?=.*({pattern_one}))(?=.*({pattern_two}))(?=.*)\"\n\ntarget_terms = gi.get_terms_for_go_regex(regex)\ngi.show_go_dag_for_terms(target_terms)\n\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-09-08) 44,296 Terms; optional_attrs(comment def relationship synonym xref)\n\n\n\n\n\n\n\n\n\n\ngo_results = gi.go_enrichment(motor_genes_df.symbol, terms=target_terms, list_study_genes=True)\ngo_results.head()\n\ngeneinfo_cache/go-basic.obo: fmt(1.2) rel(2024-09-08) 44,296 Terms; optional_attrs(def relationship)\n\n\nCould not map gene symbol \"KIF28P\" to ncbi id\n\n\n\n\n\n\n\n\n\nnamespace\nterm_id\ne/p\npval_uncorr\np_fdr_bh\nratio\nbg_ratio\nobj\nstudy_genes\n\n\n\n\n0\nCC\nGO:0005874\ne\n3.174662e-104\n1.428598e-102\n0.296407\n0.014664\n&lt;GO:0005874&gt;\n[APC, KIF1A, CENPE, DCTN1, DNAH5, DNAH6, DNAH8...\n\n\n1\nBP\nGO:0007018\ne\n3.469444e-87\n3.816388e-85\n0.152695\n0.002719\n&lt;GO:0007018&gt;\n[CENPE, DYNC1I2, DYNC1LI2, KIF2A, KIF3C, KIF5A...\n\n\n2\nCC\nGO:0005813\ne\n1.960675e-77\n4.411518e-76\n0.314371\n0.030444\n&lt;GO:0005813&gt;\n[APC, ARL3, BBS4, BICD1, CENPF, CETN1, CETN2, ...\n\n\n3\nCC\nGO:0005868\ne\n3.150407e-42\n4.725610e-41\n0.068862\n0.001117\n&lt;GO:0005868&gt;\n[DYNC1H1, DYNC1I1, DYNC1I2, DYNC1LI2, DYNLT3, ...\n\n\n4\nCC\nGO:0030286\ne\n5.844463e-35\n6.575021e-34\n0.056886\n0.000923\n&lt;GO:0030286&gt;\n[DCTN1, DNAH6, DNAH9, DYNC1H1, DYNC1I2, DYNC1L...\n\n\n\n\n\n\n\n\ngi.show_go_dag_enrichment_results(go_results.obj)",
    "crumbs": [
      "Gene ontology",
      "GO enrichment"
    ]
  },
  {
    "objectID": "pages/go_graphs.html",
    "href": "pages/go_graphs.html",
    "title": "GO graphs",
    "section": "",
    "text": "Show the sub-graph for a list of GO terms:\n\nimport geneinfo.ontology as go\n# import importlib\n# importlib.reload(geneinfo)\ngo_terms = go.get_go_terms_for_genes(['DYNLT3'])\ngo.show_go_dag_for_terms(go_terms)\n\n\n\n\n\n\n\n\n\ngi.show_go_dag_for_terms(go_terms)\n\n\n\n\n\n\n\n\nShow the sub-graph for the GO terms of a single gene:\n\ngi.show_go_dag_for_gene('DYNLT3')\n\n10741    6990\nName: GeneID, dtype: int64\n\n\n\n\n\n\n\n\n\nSame but using GO annotation backed by certain kinds of evidence:\n\ngi.show_go_dag_for_gene('DYNLT3', evidence=['IDA', 'EXP', 'HTP'])\n\n10741    6990\nName: GeneID, dtype: int64",
    "crumbs": [
      "Gene plots",
      "GO graphs"
    ]
  },
  {
    "objectID": "pages/chrom_ideograms-Copy2.html",
    "href": "pages/chrom_ideograms-Copy2.html",
    "title": "Chromosome ideograms",
    "section": "",
    "text": "from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('white')\n\n%matplotlib inline\n# %config InlineBackend.figure_format = 'retina'\n%config InlineBackend.figure_format = 'svg'\n\nimport geneinfo as gi\n#gi.email('your@email.com')\nfrom geneinfo.plot import chrom_ideogram\n\n\nannotation = [\n    ('chr1', 50000000, 50001000),                          # segment color defaults to red\n    ('chr2', 10000000, 1000000, 'green'),                  # with segment color\n    ('chr3', 45000000, 55000000, 'blue', 'NAME'),          # with name label\n    ('chr6', 10000000, 15000000, 'magenta', None, 0, 0.5), # with base and height\n    ('chr6', 10000000, 15000000, 'pink', None, 0.5, 0.5),  # with base and height\n]\n\nchrom_ideogram(annotation, figsize=(8, 8)) ;\n\n\n\n\n\n\n\n\nTo make sure segments are visible on the plot, the default minimal size of plotteed segments are 200000. This can be changed like this (notice how the chr1 segment is no longer visible):\n\nchrom_ideogram(annotation, figsize=(8, 8), min_visible_width=1, hspace=0)\n\n\n\n\n\n\n\n\nOther assembly, figure dimentions:\n\nchrom_ideogram(annotation, assembly='hg19', figsize=(8, 8))\n\n\n\n\n\n\n\n\nYou can add position markers along a chromosome like this to better see the location of some segments:\n\nchrom = 'chr3'\nstart = 100000000\nend = 200000000\nwidth = 10000000\nannotation2 = annotation + [(chrom, x[0], x[1], 'black', str(x[2]/width)) for x in zip(\n    range(start, end, width), \n    range(start+1, end, width), \n    range(start, end, width)\n)]\nchrom_ideogram(annotation2, figsize=(8, 8))\n\n\n\n\n\n\n\n\n\nfrom geneinfo.utils import GoogleSheet\n\n\nlists = GoogleSheet()\n\n\nimport importlib\nimport geneinfo\nimportlib.reload(geneinfo)\n\ncoords = gi.gene_coord(lists.get('xi_escape'), assembly='GRCh38')\nannotation = [(c, s, e, 'red', g) for g, (c, s, e, _) in coords.items()]\n\n\ncoords = gi.gene_coord(['ATRX', 'MAGT1'], assembly='GRCh38')\nannotation = [(c, s, e, 'red', g) for g, (c, s, e, _) in coords.items()]\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def get_points(self):\n        return self.points\n\n    def nudge_y(self, nudge):\n        for point in self.points:\n            point.y += nudge\n\ndef is_polygons_intersecting(a, b):\n    for x in range(2):\n        polygon = a if x == 0 else b\n\n        for i1 in range(len(polygon.get_points())):\n            i2 = (i1 + 1) % len(polygon.get_points())\n            p1 = polygon.get_points()[i1]\n            p2 = polygon.get_points()[i2]\n\n            normal = Point(p2.y - p1.y, p1.x - p2.x)\n\n            min_a = float('inf')\n            max_a = float('-inf')\n\n            for p in a.get_points():\n                projected = normal.x * p.x + normal.y * p.y\n                min_a = min(min_a, projected)\n                max_a = max(max_a, projected)\n\n            min_b = float('inf')\n            max_b = float('-inf')\n\n            for p in b.get_points():\n                projected = normal.x * p.x + normal.y * p.y\n                min_b = min(min_b, projected)\n                max_b = max(max_b, projected)\n\n            if max_a &lt; min_b or max_b &lt; min_a:\n                return False\n\n    return True\n\na = list(zip([0, 0, 2, 2], [0, 2, 2, 0]))\nb = list(zip([1, 1, 3, 3], [1, 3, 3, 1]))\n\nis_polygons_intersecting(\n    Polygon([Point(*tup) for tup in a]),\n    Polygon([Point(*tup) for tup in b])\n)\n\nTrue\n\n\n\nimport time\nimport warnings\nfrom itertools import chain\n# import gc\n\nimport numpy as np\nimport pandas as pd\n\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\n\n# # Make inline plots vector graphics instead of raster graphics\n# from IPython.display import set_matplotlib_formats\n# set_matplotlib_formats('pdf', 'svg')\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom math import isclose, floor, log10\n\ndef horizon(row, i, cut):\n    \"\"\"\n    Compute the values for the three \n    positive and negative intervals.\n    \"\"\"\n    val = getattr(row, i)\n\n    if np.isnan(val):\n        for i in range(8):\n            yield 0\n        # for nan color\n        yield cut\n    else:\n        if val &lt; 0:\n            for i in range(4):\n                yield 0\n\n        val = abs(val)\n        for i in range(3):\n            yield min(cut, val)\n            val = max(0, val-cut)\n        yield int(not isclose(val, 0, abs_tol=1e-8)) * cut\n\n        if val &gt;= 0:\n            for i in range(4):\n                yield 0\n\n        # for nan color\n        yield 0\n    \ndef horizonplot(df, y=None, ax=None,\n                cut=None, # float, takes precedence over quantile_span\n                quantile_span = None,\n                x='start',\n                beginzero=True, \n                offset=0,\n                height=None,\n                colors = ['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue',\n                          '#F2DE9A', '#DA8630', '#972428', 'darkred',\n                          '#D3D3D3']):\n                # colours = ['#314E9F', '#36AAA8', '#D7E2D4'] + ['midnightblue'] + \\\n                #           ['#F5DE90', '#F5DE90', '#A51023'] + ['darkred'] + ['whitesmoke']):\n                # colors = sns.color_palette(\"Blues\", 3) + ['midnightblue'] + \\\n                #           sns.color_palette(\"Reds\", 3) + ['darkred'] + ['lightgrey']):\n\n\n\n\n    \n    \"\"\"\n    Horizon bar plot made allowing multiple chromosomes and multiple samples.\n    \"\"\"\n\n    # set cut if not set\n    if cut is None:\n        cut = np.max([np.max(df[y]), np.max(-df[y])]) / 3\n    elif quantile_span:\n        cut=max(np.abs(np.nanquantile(df[col], quantile_span[0])), \n                np.abs(np.nanquantile(df[col], quantile_span[1]))) / 3,\n\n    # make the data frame to plot\n    row_iter = df.itertuples()\n    col_iterators = zip(*(horizon(row, y, cut) for row in row_iter))\n    col_names = ['yp1', 'yp2', 'yp3', 'yp4', \n                 'yn1', 'yn2', 'yn3', 'yn4', 'nan']\n\n    df2 = (df[[y, x]]\n           .assign(**dict(zip(col_names, col_iterators)))\n          )\n    df2 = pd.DataFrame(dict((col, list(chain.from_iterable(zip(df2[col].values, df2[col].values)))) for col in df2))\n\n    # make the plot\n    with sns.axes_style(\"ticks\"):\n\n        # ingore UserWarning from seaborn that tight_layout is not applied\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            \n            # first y tick\n            ytic1 = round(cut/3, -int(floor(log10(abs(cut/3)))))\n\n            scale = 1\n            if height is not None:\n                ymax = max(df2[col_name].max() for col_name in col_names)\n                ymin = max(df2[col_name].min() for col_name in col_names)\n                scale = height/(ymax-ymin)\n\n            for col_name, color in zip(col_names, colors):\n                plt.setp(fig.texts, text=\"\") # hack to make y facet labels align...\n                ax.fill_between(\n                    df2[x], \n                    df2[col_name]*scale+offset, \n                    y2=offset,\n                    color=color,\n                    linewidth=0,\n                    capstyle='butt')\n\n\nn = 1000\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 1))\nplt.ylim(0, 1)\ndf = pd.DataFrame({'chrom': ['chr1']*n,\n                'start': list(range(1*n)), \n                 'pi': list(np.sin(np.linspace(-np.pi, 10*np.pi, 1*n)))                   \n                  })\nsample = n\nFs = 248956422\n# f = 50\nf = np.linspace(5, 50, sample)\nx = np.linspace(0, Fs, sample)\ny = np.sin(2* np.pi * f * x / Fs)\ndf['pi'] = y\n\nheight = 1\n\nhorizonplot(df, y='pi', x='start', offset=0, height=1, ax=ax)\n#ax.set_axis_off()\n\n\n\n\n\n\n\n\n\n# from matplotlib import patches\n\n# fig, ax = plt.subplots(1, 1)\n# ax.set_xlim(0, 5)\n# ax.set_ylim(0, 5)\n\n# offset = 1\n# scale = 3\n\n# xy = np.array([[0, 0], [1, 1], [2, 1], [3, 1], [4, 0]]) \n# xy[:, 1] = xy[:, 1] * scale + offset\n# poly = patches.Polygon(xy, closed=False, fc='blue', ec='none')\n# ax.add_patch(poly)    \n# # xy = np.array([[1, 0], [2, 1], [3, 0], [3, 0]])\n# xy[:, 1] = xy[:, 1] * scale + offset\n# poly = patches.Polygon(xy, closed=False, fc='red', ec='none')\n# ax.add_patch(poly)    \n\n\ndef add_lowess(x, y, ax=None, color=None, is_sorted=True, frac=0.005, it=0, lowess_kwargs={}, **kwargs):\n    \"Add a lowess curve to the plot\"\n    if ax is None:\n        ax = plt.gca() \n    filtered = lowess(y, x, is_sorted=is_sorted, frac=frac, it=it, **lowess_kwargs)\n    ax.plot(filtered[:,0], filtered[:,1], **kwargs)\n\ndef add_band(x_low, x_high, y_low=None, y_high=None, ax=None, color='gray', linewidth=0, alpha=0.5, zorder=0, **kwargs):\n    \"Plot a gray block on x interval\"\n    if ax is None:\n        ax = plt.gca()\n    if y_low is None:\n        y_low, _ = ax.get_ylim()\n    if y_high is None:\n        _, y_high = ax.get_ylim()\n    g = ax.add_patch(Rectangle((x_low, y_low), x_high-x_low, y_high-y_low, \n                 facecolor=color,\n                 linewidth=linewidth,\n                 alpha=alpha,\n                 zorder=zorder,\n                 **kwargs))\n\ndef stairs(df, start='start', end='end', pos='pos', endtrim=0):\n    \"Turn a df with start, end into one with pos to plot as stairs\"\n    df1 = df.copy(deep=True)\n    df2 = df.copy(deep=True)\n    df1[pos] = df1[start]\n    df2[pos] = df2[end] - endtrim\n    return pd.concat([df1, df2]).sort_values([start, end])\n\n\nimport pandas as pd\nimport math\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib.artist import Artist\nimport matplotlib.gridspec as gridspec\nfrom operator import sub\nimport random\nimport numpy as np\nfrom collections import defaultdict\nfrom itertools import cycle\nfrom matplotlib.lines import Line2D\nfrom matplotlib.patches import Patch\n\nimport seaborn as sns\nfrom matplotlib.axes import Axes\n\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\n\nimport time\nimport warnings\nfrom itertools import chain\n# import gc\n\nimport numpy as np\nimport pandas as pd\n\nfrom statsmodels.nonparametric.smoothers_lowess import lowess\n\n\n# # Make inline plots vector graphics instead of raster graphics\n# from IPython.display import set_matplotlib_formats\n# set_matplotlib_formats('pdf', 'svg')\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom math import isclose, floor, log10\n\n\n\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def get_points(self):\n        return self.points\n\n    def nudge_y(self, nudge):\n        for point in self.points:\n            point.y += nudge\n            \nclass GenomeIdeogram(object):\n\n    d = {'axes.linewidth': 0.8, 'grid.linewidth': 0.64, 'lines.linewidth': 0.96, \n         'lines.markersize': 3.84, 'patch.linewidth': 0.64, 'xtick.major.width': 0.8,\n         'ytick.major.width': 0.8, 'xtick.minor.width': 0.64, 'ytick.minor.width': 0.64,\n         'xtick.major.size': 3.84, 'ytick.major.size': 3.84, 'xtick.minor.size': 2.56, \n         'ytick.minor.size': 2.56, 'font.size': 7.68, 'axes.labelsize': 7.68,\n         'axes.titlesize': 7.68, 'xtick.labelsize': 7.04, 'ytick.labelsize': 7.04, \n         'legend.fontsize': 7.04, 'legend.title_fontsize': 7.68}\n    \n    chrom_lengths = {'hg19': {'chr1': 249250621, 'chr2': 243199373, 'chr3': 198022430, 'chr4': 191154276, \n                              'chr5': 180915260, 'chr6': 171115067, 'chr7': 159138663, 'chr8': 146364022, \n                              'chr9': 141213431, 'chr10': 135534747, 'chr11': 135006516, 'chr12': 133851895,\n                              'chr13': 115169878, 'chr14': 107349540, 'chr15': 102531392, 'chr16': 90354753, \n                              'chr17': 81195210, 'chr18': 78077248, 'chr19': 59128983, 'chr20': 63025520, \n                              'chr21': 48129895, 'chr22': 51304566, 'chrX': 155270560, 'chrY': 59373566},\n                     'hg38': {'chr1': 248956422, 'chr2': 242193529, 'chr3': 198295559, 'chr4': 190214555, \n                              'chr5': 181538259, 'chr6': 170805979, 'chr7': 159345973, 'chr8': 145138636, \n                              'chr9': 138394717, 'chr10': 133797422, 'chr11': 135086622, 'chr12': 133275309, \n                              'chr13': 114364328, 'chr14': 107043718, 'chr15': 101991189, 'chr16': 90338345, \n                              'chr17': 83257441, 'chr18': 80373285, 'chr19': 58617616, 'chr20': 64444167, \n                              'chr21': 46709983, 'chr22': 50818468, 'chrX': 156040895, 'chrY': 57227415}}    \n\n    # TODO: make the centromeres fit each assembly!\n    centromeres = {\n        'chr1':    (121700000, 125100000),\n        'chr10':   (38000000, 41600000),\n        'chr11':   (51000000, 55800000),\n        'chr12':   (33200000, 37800000),\n        'chr13':   (16500000, 18900000),\n        'chr14':   (16100000, 18200000),\n        'chr15':   (17500000, 20500000),\n        'chr16':   (35300000, 38400000),\n        'chr17':   (22700000, 27400000),\n        'chr18':   (15400000, 21500000),\n        'chr19':   (24200000, 28100000),\n        'chr2':    (91800000, 96000000),\n        'chr20':   (25700000, 30400000),\n        'chr21':   (10900000, 13000000),\n        'chr22':   (13700000, 17400000),\n        'chr3':    (87800000, 94000000),\n        'chr4':    (48200000, 51800000),\n        'chr5':    (46100000, 51400000),\n        'chr6':    (58500000, 62600000),\n        'chr7':    (58100000, 62100000),\n        'chr8':    (43200000, 47200000),\n        'chr9':    (42200000, 45500000),\n        'chrX':    (58100000, 63800000),\n        'chrY':    (10300000, 10400000)}                     \n\n    \n    def __init__(self, axes_height_inches=1, axes_width_inches=12, hspace=0, ylim=(0, 1), \n                 rel_font_height=0.05, assembly:str='hg38', min_stick_height=0.3):\n\n        self.ideogram_base = None\n        self.ideogram_height = None\n        self.min_stick_height = min_stick_height\n        self.legend_handles = []\n        self.zoom_axes = []\n        \n        self.end_padding = 300000\n        self.chr_names = [f'chr{x}' for x in list(range(1, 23))+['X', 'Y']]\n        self.chr_sizes = [self.chrom_lengths[assembly][chrom] for chrom in self.chr_names]\n        self.max_chrom_size = max(self.chr_sizes)\n        nr_rows = len(self.chr_names) - 1\n        self.aspect = axes_height_inches / axes_width_inches\n        axes_width = self.max_chrom_size + 2 * self.end_padding\n        axes_height = self.aspect * axes_width\n        fig_height_inches = axes_height_inches * (nr_rows-1) + hspace * (nr_rows-1)\n        fig_width_inches = axes_width_inches #fig_height_inches / (nr_rows-1) / aspect \n        figsize = (fig_width_inches, fig_height_inches)\n        point_size = 1/72\n        self.ylim = ylim\n        self.font_size = rel_font_height * axes_height_inches / point_size\n\n        self.fig = plt.figure(figsize=figsize)\n        plt.subplots_adjust(hspace=0)\n        \n        with plt.rc_context(self.d):\n        \n            nr_rows, nr_cols = len(self.chr_names)-2+1, 2\n    \n            # fig = plt.figure(figsize=figsize)\n\n            \n            # gs = matplotlib.gridspec.GridSpec(nr_rows, 25)\n            gs = matplotlib.gridspec.GridSpec(nr_rows+1, 25, height_ratios=[1e-2]+[1]*nr_rows)\n            gs.update(wspace=0, hspace=hspace) \n\n            dummy_ax = plt.subplot(gs[0, :])\n            xlim = (-self.end_padding, self.max_chrom_size+self.end_padding)\n            dummy_ax.set_xlim(xlim)\n            # dummy_ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n            dummy_ax.spines['top'].set_visible(True)\n            dummy_ax.xaxis.tick_top()\n            dummy_ax.xaxis.set_label_position('top') \n            dummy_ax.yaxis.set_ticks_position('none')\n            dummy_ax.set_yticklabels([])\n        \n            ax_list = [plt.subplot(gs[i, :]) for i in range(1, nr_rows-2)]\n            ax_list.append(plt.subplot(gs[nr_rows-2, :9]))\n            ax_list.append(plt.subplot(gs[nr_rows-1, :9]))\n            ax_list.append(plt.subplot(gs[nr_rows-2, 9:]))\n            ax_list.append(plt.subplot(gs[nr_rows-1, 9:]))\n\n            self.ax_list = ax_list\n            self.chr_axes = dict(zip(self.chr_names, self.ax_list))\n    \n            for ax in self.ax_list[:-4]:\n                xlim = (-end_padding, self.max_chrom_size+end_padding)\n                scaled_y_lim = xlim[0] * self.aspect, xlim[1] * self.aspect\n                ax.set_xlim(xlim)\n                ax.set_ylim(scaled_y_lim)\n            for ax in ax_list[-4:]:\n                xlim = (-end_padding, ((25-9)/25)*self.max_chrom_size+end_padding)\n                scaled_y_lim = xlim[0] * self.aspect, xlim[1] * self.aspect\n                ax.set_xlim(xlim)\n                ax.set_ylim(scaled_y_lim)\n    \n            for i in range(len(self.ax_list)):\n                chrom = self.chr_names[i]\n                ax = ax_list[i]\n                \n                start, end = 0, self.chr_sizes[i]\n                ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n                # ax.spines['top'].set_visible(False)\n                # ax.spines['right'].set_visible(False)\n                # ax.spines['bottom'].set_visible(False)\n                # ax.spines['left'].set_visible(False)\n                # ax.set_ylim((0, 3))\n                # ax.set_ylim((0, 5))\n    \n                if i in [20, 21]:   \n                    x = -3500000 * 10 / figsize[1]\n                else:\n                    x = -2000000 * 10 / figsize[1]\n\n                ax.text(x, self.map_y(-sub(*self.ylim), ax)/2, chrom.replace('chr', ''), fontsize=7, verticalalignment='center', horizontalalignment='right', weight='bold')\n    \n                # h = ax.set_ylabel(chrom)\n                # h.set_rotation(0)\n                ax.set_yticklabels([])\n    \n                # if i == 0:\n                #     ax.spines['top'].set_visible(True)\n                #     ax.xaxis.tick_top()\n                #     ax.xaxis.set_label_position('top') \n                #     ax.yaxis.set_ticks_position('none')\n                # elif i == len(ax_list)-1:\n                if i == len(self.ax_list)-1:\n                    ax.xaxis.tick_bottom()\n                    ax.spines['bottom'].set_visible(True)                    \n                    ax.yaxis.set_ticks_position('none')\n                    ax.yaxis.set_visible(False)\n                    ax.set_yticklabels([])\n                else:\n                    ax.set_xticklabels([])\n                    ax.xaxis.set_ticks_position('none')\n                    ax.yaxis.set_ticks_position('none')\n                    # ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n    def draw_chromosomes(self, base=0.05, height=0.25, facecolor='#EBEAEA', edgecolor='black', linewidth=0.7, **kwargs):\n\n        self.ideogram_base = base\n        self.ideogram_height = height\n        \n        with plt.rc_context(self.d):\n\n            for i in range(len(self.ax_list)):\n                chrom = self.chr_names[i]\n                ax = self.ax_list[i]\n                start, end = 0, self.chr_sizes[i]                \n\n                ideogram_base = self.map_y(base, ax)\n                ideogram_height = self.map_y(height, ax)\n\n                    \n                # draw centromere\n                cent_start, cent_end = self.centromeres[chrom]\n                ymin, ymax = ax.get_ylim()\n                # ax.add_patch(patches.Rectangle((cent_start, ymin), cent_end-cent_start, ymax, \n                #                            fill=True, color='white',\n                #                            zorder=1))\n                xy = [[cent_start, ideogram_base], [cent_start, ideogram_base+ideogram_height], [cent_end, ideogram_base], [cent_end, ideogram_base+ideogram_height]]\n                g = ax.add_patch(patches.Polygon(xy, closed=True, zorder=2, fill=True,\n                                         # color='#666666',\n                                         color='#777777',\n                                        ))\n                \n                # draw chrom\n                g = ax.add_patch(patches.Rectangle((start, ideogram_base), cent_start-start, ideogram_height, \n                                           # fill=False,\n                                           facecolor=facecolor,\n                                           edgecolor='none',\n                                           zorder=0,\n                                           linewidth=linewidth,\n                                           **kwargs\n                                          ))\n                g = ax.add_patch(patches.Rectangle((start, ideogram_base), cent_start-start, ideogram_height, \n                                           # fill=False,\n                                           facecolor='none',\n                                           edgecolor=edgecolor,\n                                           zorder=0.5,\n                                           linewidth=linewidth,\n                                           **kwargs\n                                          )) \n                g = ax.add_patch(patches.Rectangle((cent_end, ideogram_base), end-cent_end, ideogram_height, \n                                           # fill=False,\n                                           facecolor=facecolor,\n                                           edgecolor='none',\n                                           zorder=0,\n                                           linewidth=linewidth,\n                                           **kwargs\n                                          ))\n                g = ax.add_patch(patches.Rectangle((cent_end, ideogram_base), end-cent_end, ideogram_height, \n                                           # fill=False,\n                                           facecolor='none',\n                                           edgecolor=edgecolor,\n                                           zorder=0.5,\n                                           linewidth=linewidth,\n                                           **kwargs\n                                          ))                   \n\n\n                for ax in self.zoom_axes:\n\n                    ideogram_base = self.map_y(base, ax)\n                    ideogram_height = self.map_y(height, ax)\n                \n                    # draw centromere\n                    cent_start, cent_end = self.centromeres[chrom]\n                    ymin, ymax = ax.get_ylim()\n                    # ax.add_patch(patches.Rectangle((cent_start, ymin), cent_end-cent_start, ymax, \n                    #                            fill=True, color='white',\n                    #                            zorder=-2))\n                    xy = [[cent_start, ideogram_base], [cent_start, ideogram_base+ideogram_height], [cent_end, ideogram_base], [cent_end, ideogram_base+ideogram_height]]\n                    g = ax.add_patch(patches.Polygon(xy, closed=True, zorder=-1, fill=True,\n                                             # color='#666666',\n                                             color='#777777',\n                                            ))\n                    \n                    # draw chrom\n                    g = ax.add_patch(patches.Rectangle((start, ideogram_base), cent_start-start, ideogram_height, \n                                               # fill=False,\n                                               facecolor=facecolor,\n                                               edgecolor='none',\n                                               zorder=0,\n                                               linewidth=linewidth,\n                                               **kwargs\n                                              ))\n                    g = ax.add_patch(patches.Rectangle((start, ideogram_base), cent_start-start, ideogram_height, \n                                               # fill=False,\n                                               facecolor='none',\n                                               edgecolor=edgecolor,\n                                               zorder=0.5,\n                                               linewidth=linewidth,\n                                               **kwargs\n                                              )) \n                    g = ax.add_patch(patches.Rectangle((cent_end, ideogram_base), end-cent_end, ideogram_height, \n                                               # fill=False,\n                                               facecolor=facecolor,\n                                               edgecolor='none',\n                                               zorder=0,\n                                               linewidth=linewidth,\n                                               **kwargs\n                                              ))\n                    g = ax.add_patch(patches.Rectangle((cent_end, ideogram_base), end-cent_end, ideogram_height, \n                                               # fill=False,\n                                               facecolor='none',\n                                               edgecolor=edgecolor,\n                                               zorder=0.5,\n                                               linewidth=linewidth,\n                                               **kwargs\n                                              ))               \n        \n\n                \n\n\n\n    \n    def is_polygons_intersecting(self, a, b):\n        for x in range(2):\n            polygon = a if x == 0 else b\n    \n            for i1 in range(len(polygon.get_points())):\n                i2 = (i1 + 1) % len(polygon.get_points())\n                p1 = polygon.get_points()[i1]\n                p2 = polygon.get_points()[i2]\n    \n                normal = Point(p2.y - p1.y, p1.x - p2.x)\n    \n                min_a = float('inf')\n                max_a = float('-inf')\n    \n                for p in a.get_points():\n                    projected = normal.x * p.x + normal.y * p.y\n                    min_a = min(min_a, projected)\n                    max_a = max(max_a, projected)\n    \n                min_b = float('inf')\n                max_b = float('-inf')\n    \n                for p in b.get_points():\n                    projected = normal.x * p.x + normal.y * p.y\n                    min_b = min(min_b, projected)\n                    max_b = max(max_b, projected)\n    \n                if max_a &lt; min_b or max_b &lt; min_a:\n                    return False\n    \n        return True\n\n    \n    def scaled_y_lim(self, ax):\n        xlim = ax.get_xlim()\n\n        bbox = ax.get_window_extent().transformed(self.fig.dpi_scale_trans.inverted())\n        aspect = bbox.height / bbox.width\n        \n        return 0, -sub(*xlim) * aspect \n        # return xlim[0] * self.aspect, xlim[1] * self.aspect\n    \n\n    def map_y(self, y, ax, bottom=0, top=1):\n        miny, maxy = ax.get_ylim()\n\n        return y * (top - bottom) * (maxy - miny) / (self.ylim[1] - self.ylim[0]) + bottom * (maxy - miny)\n        # zero = -miny\n        # if y &gt;= 0:\n        #     return y * (top - max(bottom, zero)) * (maxy - zero) / (self.ylim[1] - self.ylim[0]) + max(bottom, zero) * (maxy - zero)\n        # else:\n        #     return y * (min(top, zero) - bottom) * (zero - miny) / (self.ylim[1] - self.ylim[0]) + min(top, zero) * (zero - miny)\n\n        \n    def draw_text(self, x_pos, y_pos, text, ax, color=None, y_line_bottom=0, highlight=None):\n        y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n\n        if bool(color is not None) == bool(highlight is not None):\n            raise TypeError(\"Do not use color and highlight keyword arguments together\")\n\n        if highlight is True:\n            text_props = dict(weight='bold', color='red')\n            linecolor = 'lightgray'\n        elif type(highlight) is dict:\n            text_props = highlight\n            linecolor = 'lightgray'\n            # if 'color' in highlight:\n            #     linecolor = highlight['color']\n        else:\n            text_props = dict(color='black',\n                    fontweight='normal', # 'normal' | 'bold' | 'heavy' | 'light' | 'ultrabold' | 'ultralight']\n                    # variant = 'small-caps', # [ 'normal' | 'small-caps' ]\n                    fontstyle = 'normal', # [ 'normal' | 'italic' | 'oblique' ]\n                    bbox=dict(boxstyle='square,pad=0', \n                              linewidth=0.2,\n                              fc='none', \n                              alpha=1,\n                              ec='none'),)\n            linecolor = 'lightgray'\n        \n        t = ax.text(x_pos, y_pos, text, fontsize=self.font_size,                     \n                    rotation=45, zorder=10, \n                    horizontalalignment='left',\n                    verticalalignment='bottom',\n                    **text_props)\n        ax.plot((x_pos, x_pos, x_pos+y_unit/10),\n                (y_line_bottom, y_pos, y_pos+y_unit/10), \n                linewidth=0.5, \n                # color='darkgray', \n                color='lightgray',\n                # alpha=0.3,\n                zorder=-5)\n    \n    \n    def get_polygon(self, text:str, x_pos:int, y_pos:float,ax:matplotlib.axes.Axes, pad=0) -&gt; Polygon:\n\n        y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n        # y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*ax.get_ylim())\n\n        y_pos = y_pos * y_unit\n        \n        t = ax.text(x_pos, y_pos, text, fontsize=self.font_size,\n                    horizontalalignment='left',\n                    verticalalignment='bottom', \n                    rotation=0, zorder=3, \n                    bbox=dict(boxstyle='square', \n                              fc='none', ec='red', pad=pad, alpha=0.4))\n        \n        transf = ax.transData.inverted()\n        bb = t.get_window_extent(renderer = self.fig.canvas.get_renderer())\n        bbt = bb.transformed(transf)\n        coords = bbt.get_points()\n        \n        Artist.remove(t)\n        \n        (x0, y0), (x1, y1) = coords\n        pad = (y1 - y0)/5\n        coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n            \n        x, y = zip(*coords)\n        df = pd.DataFrame(dict(x=x, y=y))\n        df['y'] -= y_pos\n        df['x'] -= x_pos\n        dfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\n        df['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\n        df['x'] = dfx\n        df['y'] += y_pos\n        df['x'] += x_pos\n            \n        coords = np.array(list(zip(df.x, df.y)))\n        \n        x_pos, y_pos = df['x'][0] - (df['x'][0] - df['x'][1]), df['y'][0]\n    \n        df['x'] = df.x + np.array([-pad, -pad, pad, pad])\n        df['y'] = df.y + np.array([-pad, pad, pad, -pad])\n        \n        return x_pos, y_pos, Polygon([Point(x, y) for x, y in zip(df.x, df.y)])\n        \n\n    # def add_labels(self, data, labels='name', chrom='chrom', x='pos'):\n    def add_labels(self, annot, y0=None, y1=None, bold=[], italic=[], colored=[], framed=[], filled=[], pad=0):\n\n        if y0 is None:\n            y0 = self.ideogram_base + self.ideogram_height\n        if y1 is None:\n            y1 = self.ideogram_base + self.ideogram_height + self.min_stick_height\n\n    \n        highlight = defaultdict(dict)\n        for gene in bold:\n            highlight[gene].update(dict(weight='bold'))\n        for gene in italic:\n            highlight[gene].update(dict(style='italic'))\n        for gene in colored:\n            highlight[gene].update(dict(color='red'))\n        for gene in framed:\n            if 'bbox' not in highlight[gene]:\n                highlight[gene]['bbox'] = {}\n            highlight[gene]['bbox'].update(dict(edgecolor='black', pad=pad, linewidth=0.5))\n        for gene in filled:\n            if 'bbox' not in highlight[gene]:\n                highlight[gene]['bbox'] = {}\n            highlight[gene]['bbox'].update(dict(facecolor='red', alpha=0.2, pad=pad))\n\n        for gene in highlight:\n            if 'bbox' in highlight[gene]:\n                if 'edgecolor' not in highlight[gene]['bbox']:\n                    highlight[gene]['bbox']['edgecolor'] = 'none'\n                if 'facecolor' not in highlight[gene]['bbox']:\n                    highlight[gene]['bbox']['facecolor'] = 'none'\n        \n        chrom_annot = defaultdict(list)\n        for a in annot:\n            chrom_annot[a[0]].append(a[1:])\n            \n        for chrom, annot in chrom_annot.items():\n            ax = self.chr_axes[chrom]\n\n            annot = sorted(annot, reverse=True)\n\n            y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n            nudge = 0.01 * y_unit\n        \n            polybuff = []\n            for pos, name, *args in annot:\n\n                if type(highlight) is list or type(highlight) is set:\n                    hl = name in highlight\n                elif type(highlight) is dict or type(highlight) is defaultdict:\n                    hl = highlight[name]\n                else:\n                    hl = None\n                \n                x, y, poly = self.get_polygon(name, pos, y1, ax, pad=pad)\n                while any(self.is_polygons_intersecting(poly, p) for p in polybuff):\n                    y += nudge\n                    poly.nudge_y(nudge)\n\n                self.draw_text(x, y, name, ax, *args, y_line_bottom=y0*y_unit, highlight=hl)\n\n                polybuff.append(poly)\n                if len(polybuff) &gt; 40:\n                    del polybuff[0]        \n            z = 100\n            for i, t in enumerate(reversed(ax.texts)):\n                t.set_zorder(z+i)\n\n            for zoom, ax in zip(self.zooms, self.zoom_axes):\n\n                y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n                nudge = 0.01 * y_unit\n                \n                zoom_polybuff = []\n                for pos, name, *args in annot:\n\n                    if type(highlight) is list or type(highlight) is set:\n                        hl = name in highlight\n                    elif type(highlight) is dict or type(highlight) is defaultdict:\n                        hl = highlight[name]\n                    else:\n                        hl = None\n                        \n                    if pos &gt;= zoom[0] and pos &lt; zoom[1]:\n                        x, y, poly = self.get_polygon(name, pos, y1, ax)\n                        while any(self.is_polygons_intersecting(poly, p) for p in zoom_polybuff):\n                            y += nudge\n                            poly.nudge_y(nudge)\n                        self.draw_text(x, y, name, ax, *args, y_line_bottom=y0*y_unit, highlight=hl)\n        \n                        zoom_polybuff.append(poly)\n                        if len(zoom_polybuff) &gt; 20:\n                            del zoom_polybuff[0]        \n                z = 100\n                for i, t in enumerate(reversed(ax.texts)):\n                    t.set_zorder(z+i)\n                    \n\n\n    def add_segments(self, annot, base=None, height=None, label=None,\n                    min_visible_width:int=200000, **kwargs):\n\n        if 'facecolor' not in kwargs:\n            kwargs['facecolor'] = 'black'\n        if 'edgecolor' not in kwargs:\n            kwargs['edgecolor'] = 'none'\n        \n        if label is not None:\n            self.legend_handles.append(Patch(facecolor=kwargs['facecolor'], edgecolor=kwargs['edgecolor'],label=label))\n        \n        if base is None:\n            base = self.ideogram_base\n        if height is None:\n            height = self.ideogram_height            \n        \n        chrom_annot = defaultdict(list)\n        for a in annot:\n            chrom_annot[a[0]].append(a[1:])\n            \n        for chrom, annot in chrom_annot.items():\n            ax = self.chr_axes[chrom]\n            annot = sorted(annot, reverse=True)\n            y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n            for start, end in annot:\n                scaled_base = base * y_unit\n                scaled_height = height * y_unit                \n                width = end - start\n                if width &lt; min_visible_width:\n                    start -= min_visible_width/2\n                    width += min_visible_width\n\n                rect = patches.Rectangle((start, scaled_base), width, scaled_height, linewidth=1, zorder=3, **kwargs)\n                ax.add_patch(rect)    \n\n                for zoom_ax in self.zoom_axes:\n                    zoom_y_unit = -sub(*self.scaled_y_lim(zoom_ax)) / -sub(*self.ylim)\n                    zoom_scaled_base = base * zoom_y_unit\n                    zoom_scaled_height = height * zoom_y_unit                      \n\n                    rect = patches.Rectangle((start, zoom_scaled_base), width, zoom_scaled_height, linewidth=1, zorder=3, **kwargs)\n                    zoom_ax.add_patch(rect)    \n\n\n\n    def add_vlines(self, step=1000000, color='black', linewidth=0.1, zorder=100, **kwargs):\n        for i, ax in enumerate(self.ax_list):\n\n            s, e = self.centromeres[self.chr_names[i]]\n\n            ymin = self.map_y(self.ideogram_base, ax)        \n            ymax = self.map_y(self.ideogram_base+self.ideogram_height, ax)\n            ax.vlines([x for x in range(0, self.chr_sizes[i], step) if x &lt; s or x &gt; e], \n                      ymin=ymin, ymax=ymax, linewidth=linewidth, color=color, zorder=zorder, **kwargs)\n            for ax in self.zoom_axes:\n                ymin = self.map_y(self.ideogram_base, ax)        \n                ymax = self.map_y(self.ideogram_base+self.ideogram_height, ax)\n                ax.vlines([x for x in range(0, self.chr_sizes[i], step) if x &lt; s or x &gt; e], \n                          ymin=ymin, ymax=ymax, linewidth=linewidth, color=color, zorder=zorder, **kwargs)\n                \n    \n    # TODO rename yaxis to data_scaling or something or use offset and scale or offset and height\n    def map_method(self, fun, data=None, chrom_col='chrom', yaxis=(0, 1), **kwargs):\n\n        def method_not_found(): # just in case we dont have the function\n            print('No Function '+fun+' Found!')\n\n        grouped = data.groupby(chrom_col, observed=True)\n        for chrom, group in grouped:\n            ax = self.chr_axes[chrom]\n            bottom, top = yaxis            \n            scaled_y_lim = ax.get_ylim()\n            if 'ylim' in kwargs:\n                dy = -sub(*ylim)\n            else:\n                dy = -sub(*self.ylim)\n            df = group.reset_index() # create independent dataframe\n            df['y'] -= df.y.min()\n            df['y'] /= df.y.max()\n            df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n            x = df.x\n            y = df.y\n            if 'x' in kwargs: del kwargs['x']\n            if 'y' in kwargs: del kwargs['y']                \n            fun_name = fun.__name__\n            method = getattr(ax, fun_name, method_not_found) \n            g = method(x, y, **kwargs)\n            \n            for ax in self.zoom_axes:\n                scaled_y_lim = ax.get_ylim()\n                if 'ylim' in kwargs:\n                    dy = -sub(*ylim)\n                else:\n                    dy = -sub(*self.ylim)\n                df = group.reset_index() # create independent dataframe\n                df['y'] -= df.y.min()\n                df['y'] /= df.y.max()\n                df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n                x = df.x\n                y = df.y\n                if 'x' in kwargs: del kwargs['x']\n                if 'y' in kwargs: del kwargs['y']   \n                \n                method = getattr(ax, fun_name, method_not_found) \n                g = method(x, y, **kwargs)\n                \n                try:\n                    ax.get_legend().remove()\n                except:\n                    pass\n            plt.xlabel('')\n            plt.ylabel('')\n\n    \n    def map_fun(self, fun, data=None, chrom_col='chrom', yaxis=None, **kwargs):\n            \n        grouped = data.groupby(chrom_col, observed=True)\n        for chrom, group in grouped:\n            ax = self.chr_axes[chrom]\n            scaled_y_lim = ax.get_ylim()\n            if 'ylim' in kwargs:\n                dy = -sub(*ylim)\n            else:\n                dy = -sub(*self.ylim)\n            df = group.copy()\n            if yaxis is None:\n                df['y'] = df.y * -sub(*scaled_y_lim) / -sub(*self.ylim)\n            else:\n                bottom, top = yaxis\n                df['y'] -= df.y.min()\n                df['y'] /= df.y.max()\n                df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n            g = fun(df, ax=ax, **kwargs)\n            for ax in self.zoom_axes:\n                scaled_y_lim = ax.get_ylim()\n                if 'ylim' in kwargs:\n                    dy = -sub(*ylim)\n                else:\n                    dy = -sub(*self.ylim)\n                df = group.copy()\n                if yaxis is None:\n                    df['y'] = df.y * -sub(*scaled_y_lim) / -sub(*self.ylim)\n                else:\n                    bottom, top = yaxis\n                    df['y'] -= df.y.min()\n                    df['y'] /= df.y.max()\n                    df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n                g = fun(df, ax=ax, **kwargs)\n                try:\n                    ax.get_legend().remove()\n                except:\n                    pass                               \n            plt.xlabel('')\n            plt.ylabel('')\n\n    def legend(self, loc='center left', bbox_to_anchor=(1.02, 0.5), frameon=False, **kwargs):\n        for ax in self.ax_list:\n            handles, labels = ax.get_legend_handles_labels()\n            if self.legend_handles:\n                handles = self.legend_handles + handles\n            ax.legend(handles=handles, loc=loc, bbox_to_anchor=bbox_to_anchor, frameon=frameon, **kwargs)\n\n\n    def _horizon(self, row, i, cut):\n        \"\"\"\n        Compute the values for the three \n        positive and negative intervals.\n        \"\"\"\n        val = getattr(row, i)\n    \n        if np.isnan(val):\n            for i in range(8):\n                yield 0\n            # for nan color\n            yield cut\n        else:\n            if val &lt; 0:\n                for i in range(4):\n                    yield 0\n    \n            val = abs(val)\n            for i in range(3):\n                yield min(cut, val)\n                val = max(0, val-cut)\n            yield int(not isclose(val, 0, abs_tol=1e-8)) * cut\n    \n            if val &gt;= 0:\n                for i in range(4):\n                    yield 0\n    \n            # for nan color\n            yield 0\n\n    def _horizonplot(self, df, y=None, ax=None,\n                    cut=None, # float, takes precedence over quantile_span\n                    quantile_span = None,\n                    x='start',\n                    beginzero=True, \n                    offset=0,\n                    height=None,\n                    colors = ['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue',\n                              '#F2DE9A', '#DA8630', '#972428', 'darkred',\n                              '#D3D3D3'],\n                    **kwargs):\n                    # colours = ['#314E9F', '#36AAA8', '#D7E2D4'] + ['midnightblue'] + \\\n                    #           ['#F5DE90', '#F5DE90', '#A51023'] + ['darkred'] + ['whitesmoke']):\n                    # colors = sns.color_palette(\"Blues\", 3) + ['midnightblue'] + \\\n                    #           sns.color_palette(\"Reds\", 3) + ['darkred'] + ['lightgrey']):\n    \n        \"\"\"\n        Horizon bar plot made allowing multiple chromosomes and multiple samples.\n        \"\"\"\n        \n        # set cut if not set\n        if cut is None:\n            cut = np.max([np.max(df[y]), np.max(-df[y])]) / 3\n        elif quantile_span:\n            cut=max(np.abs(np.nanquantile(df[col], quantile_span[0])), \n                    np.abs(np.nanquantile(df[col], quantile_span[1]))) / 3,\n    \n        # make the data frame to plot\n        row_iter = df.itertuples()\n        col_iterators = zip(*(self._horizon(row, y, cut) for row in row_iter))\n        col_names = ['yp1', 'yp2', 'yp3', 'yp4', \n                     'yn1', 'yn2', 'yn3', 'yn4', 'nan']\n    \n        df2 = (df[[y, x]]\n               .assign(**dict(zip(col_names, col_iterators)))\n              )\n        df2 = pd.DataFrame(dict((col, list(chain.from_iterable(zip(df2[col].values, df2[col].values)))) for col in df2))\n    \n        # make the plot\n        with sns.axes_style(\"ticks\"):\n    \n            # ingore UserWarning from seaborn that tight_layout is not applied\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"ignore\")\n                \n                # first y tick\n                ytic1 = round(cut/3, -int(floor(log10(abs(cut/3)))))\n    \n                scale = 1\n                if height is not None:\n                    ymax = max(df2[col_name].max() for col_name in col_names)\n                    ymin = max(df2[col_name].min() for col_name in col_names)\n                    scale = height/(ymax-ymin)\n    \n                for col_name, color in zip(col_names, colors):\n                    # plt.setp(fig.texts, text=\"\") # hack to make y facet labels align...\n                    ax.fill_between(\n                        df2[x], \n                        df2[col_name]*scale+offset, \n                        y2=offset,\n                        color=color,\n                        linewidth=0,\n                        capstyle='butt',\n                    **kwargs)\n    \n\n    def horizon(self, data=None, chrom_col='chrom', y=None, \n                    cut=None, # float, takes precedence over quantile_span\n                    quantile_span = None,\n                    x='start',\n                    beginzero=True, \n                    base=0,\n                    height=1,\n                    colors = ['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue',\n                              '#F2DE9A', '#DA8630', '#972428', 'darkred',\n                              '#D3D3D3'],\n                    **kwargs):\n\n        grouped = data.groupby(chrom_col, observed=True)\n        for chrom, group in grouped:\n            ax = self.chr_axes[chrom]\n            \n            df = group.reset_index() # make copy\n            # scaled_y_lim = ax.get_ylim()\n            # if 'ylim' in kwargs:\n            #     dy = -sub(*ylim)\n            # else:\n            #     dy = -sub(*self.ylim)\n            # df = group.copy()\n            # if yaxis is None:\n            #     df['y'] = df.y * -sub(*scaled_y_lim) / -sub(*self.ylim)\n            # else:\n            #     bottom, top = yaxis\n            #     df['y'] -= df.y.min()\n            #     df['y'] /= df.y.max()\n            #     df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n            # g = fun(df, ax=ax, **kwargs)\n            self._horizonplot(df, y=y, ax=ax,\n                    cut=cut, # float, takes precedence over quantile_span\n                    quantile_span = quantile_span,\n                    x=x,\n                    beginzero=beginzero, \n                    offset=self.map_y(base, ax),\n                    height=self.map_y(height, ax),\n                    colors = colors,\n                    **kwargs)\n                             \n            for ax in self.zoom_axes:\n                # scaled_y_lim = ax.get_ylim()\n                # if 'ylim' in kwargs:\n                #     dy = -sub(*ylim)\n                # else:\n                #     dy = -sub(*self.ylim)\n                # df = group.copy()\n                # if yaxis is None:\n                #     df['y'] = df.y * -sub(*scaled_y_lim) / -sub(*self.ylim)\n                # else:\n                #     bottom, top = yaxis\n                #     df['y'] -= df.y.min()\n                #     df['y'] /= df.y.max()\n                #     df['y'] = df.y * ((top-bottom) * -sub(*scaled_y_lim)) / -sub(*self.ylim) + bottom /  -sub(*self.ylim) * -sub(*scaled_y_lim)\n                self._horizonplot(df, y=y, ax=ax,\n                    cut=cut, # float, takes precedence over quantile_span\n                    quantile_span = quantile_span,\n                    x=x,\n                    beginzero=beginzero, \n                    offset=self.map_y(base, ax),\n                    height=self.map_y(height, ax),\n                    colors = colors,\n                    **kwargs)\n                # try:\n                #     ax.get_legend().remove()\n                # except:\n                #     pass                               \n            # plt.xlabel('')\n            # plt.ylabel('')\n\n    \n\n\nclass ChromIdeogram(GenomeIdeogram):\n\n    def __init__(self, chrom, axes_height_inches=1, axes_width_inches=12, hspace=0.3, \n                 ylim=(0, 1), zooms=[], wspace=None,\n                 rel_font_height=0.05, assembly:str='hg38', min_stick_height=0.5):\n\n        self.ideogram_base = None\n        self.ideogram_height = None\n        self.legend_handles = []\n        self.height_ratios = [1]\n        self.zooms = zooms\n        self.zoom_axes = []\n        self.end_padding = 300000\n        self.min_stick_height = min_stick_height\n        \n        self.chr_names = [chrom]\n        self.chr_sizes = [self.chrom_lengths[assembly][chrom] for chrom in self.chr_names]\n        self.max_chrom_size = max(self.chr_sizes)\n        nr_rows = 1\n        self.aspect = axes_height_inches / axes_width_inches\n        axes_width = self.max_chrom_size\n        axes_height = self.aspect * self.max_chrom_size + (2 * self.end_padding)\n        fig_height_inches = axes_height_inches\n        point_size = 1/72\n        self.ylim = ylim\n        self.font_size = rel_font_height * axes_height_inches / point_size\n        if zooms:\n             fig_height_inches += (1 + hspace) * axes_height_inches\n        fig_width_inches = axes_width_inches\n        figsize = (fig_width_inches, fig_height_inches)\n\n        with plt.rc_context(self.d):\n\n            xlim = (-self.end_padding, self.chr_sizes[0]+self.end_padding)\n            scaled_y_lim = xlim[0] * self.aspect, xlim[1] * self.aspect\n\n            if zooms:\n                self.fig =  plt.figure(figsize=figsize)\n                axs = self.fig.subplot_mosaic([\n                    [\"main\" for i in range(len(zooms))],\n                    [f\"zoom{i}\" for i in range(len(zooms))]],\n                     width_ratios=[-sub(*tup) for tup in zooms],\n                )\n                axs[\"main\"].set(xlim=xlim)\n\n                for i in range(len(zooms)):\n                    self.zoom_effect(axs[f\"zoom{i}\"], axs[\"main\"])\n                    axs[f\"zoom{i}\"].set(xlim=zooms[i])\n\n                    zoom_scaled_y_lim = self.scaled_y_lim(axs[f\"zoom{i}\"])\n                    axs[f\"zoom{i}\"].set(ylim=zoom_scaled_y_lim)\n\n                self.ax = axs[\"main\"]\n                self.zoom_axes = [axs[f\"zoom{i}\"] for i in range(len(zooms))]\n                \n                for i in range(len(self.zoom_axes)):\n                    self.zoom_axes[i].sharey(self.zoom_axes[0])\n\n                plt.subplots_adjust(wspace=wspace)\n\n            else:        \n                self.fig, self.ax = plt.subplots(1, 1, figsize=figsize)\n            \n            if hspace is not None:\n                plt.subplots_adjust(hspace=hspace)\n    \n            plt.minorticks_on()\n        \n\n            nr_rows, nr_cols = 1, 1\n\n            \n            # gs = matplotlib.gridspec.GridSpec(nr_rows, 25)\n            gs = matplotlib.gridspec.GridSpec(1, 1)\n            gs.update(wspace=0, hspace=hspace) \n\n            self.ax.set_xlim(xlim)\n            self.ax.set_ylim(scaled_y_lim)                \n\n            # start, end = 0, self.chr_sizes[i]\n            # ax.set_xlim(start, end)\n            self.ax.spines[['right', 'top', 'left']].set_visible(False)\n            x = -self.end_padding * 10 / figsize[1]\n            self.ax.set_yticklabels([])\n            self.ax.set_xticks(np.arange(0, self.chr_sizes[0]+1, 10_000_000))\n            self.ax.xaxis.tick_bottom()\n            self.ax.spines['bottom'].set_visible(True)                    \n            self.ax.yaxis.set_ticks_position('none')\n            self.ax.yaxis.set_visible(False)\n            self.ax.set_yticklabels([])\n\n            self.ax_list = [self.ax]\n        \n            self.chr_axes = dict(zip(self.chr_names, self.ax_list))\n\n    \n    def connect_bbox(self, bbox1, bbox2,\n                     loc1a, loc2a, loc1b, loc2b,\n                     prop_lines, prop_patches=None):\n        if prop_patches is None:\n            prop_patches = {\n                **prop_lines,\n                \"alpha\": prop_lines.get(\"alpha\", 1) * 0.2,\n                \"clip_on\": False,\n            }\n    \n        c1 = BboxConnector(\n            bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n        c2 = BboxConnector(\n            bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n    \n        bbox_patch1 = BboxPatch(bbox1, ec='none', fc='none')\n        bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n    \n        p = BboxConnectorPatch(bbox1, bbox2,\n                               loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                               clip_on=False,\n                               **prop_patches)\n    \n        return c1, c2, bbox_patch1, bbox_patch2, p\n    \n    \n    def zoom_effect(self, ax1, ax2, **kwargs):\n        \"\"\"\n        ax1 : the main Axes\n        ax1 : the zoomed Axes\n    \n        Similar to zoom_effect01.  The xmin & xmax will be taken from the\n        ax1.viewLim.\n        \"\"\"\n    \n        tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n        trans = blended_transform_factory(ax2.transData, tt)\n    \n        mybbox1 = ax1.bbox\n        mybbox2 = TransformedBbox(ax1.viewLim, trans)\n    \n        prop_patches = {**kwargs, 'ec': 'black', 'fc': 'lightgray', 'alpha': 0.3, 'linewidth': 0.5}\n    \n        c1, c2, bbox_patch1, bbox_patch2, p = self.connect_bbox(\n            mybbox1, mybbox2,\n            loc1a=2, loc2a=3, loc1b=1, loc2b=4,\n            prop_lines=kwargs, prop_patches=prop_patches)\n    \n        ax1.add_patch(bbox_patch1)\n        ax2.add_patch(bbox_patch2)\n        ax2.add_patch(c1)\n        ax2.add_patch(c2)\n        ax2.add_patch(p)\n    \n        return c1, c2, bbox_patch1, bbox_patch2, p\n\n\n    def add_axes(self, nr_axes=1, height_ratio=1.0, hspace=None):\n\n        new_axes = []\n        for _ in range(nr_axes):\n        \n            gs = self.ax.get_gridspec()\n            row = gs.nrows + 1\n            self.height_ratios.append(height_ratio)\n            gs = gridspec.GridSpec(row, 1, height_ratios=self.height_ratios, hspace=hspace)\n            for i, ax in enumerate(self.fig.axes):\n                ax.set_position(gs[i].get_position(self.fig))\n                ax.set_subplotspec(gs[i])\n            new_ax = self.fig.add_subplot(gs[row-1], sharex=ax)\n            self.fig.set_figheight(self.fig.get_figheight()*sum(self.height_ratios)/sum(self.height_ratios[:-1]))\n            new_ax.spines[['right', 'top']].set_visible(False)\n            new_ax.xaxis.set_visible(False)\n            # new_ax.spines[['bottom']].set_visible(False)\n            new_axes.append(new_ax)\n\n        new_axes[-1].xaxis.tick_bottom()\n        new_axes[-1].xaxis.set_visible(True)\n        # new_axes[-1].spines[['bottom']].set_visible(True)\n\n        if nr_axes == 1:\n            return new_axes[0]\n        else:\n            return new_axes\n\n\n\n\nimport random\n# _names = random.choices(['AKAP4', 'DYNLT3', 'MAGEA4', 'TP53'], k=200)\n# _pos = sorted(np.random.randint(1, 250000000, 200).tolist())\n# # _colors = ['black']*200\n# _colors = random.choices(['blue', 'brown', 'green', 'orange'], k=200)\n# annot = list(zip(['chr1']*200, _pos, _names, _colors))\n\n\ndef read_google_sheet():\n    SHEET_ID = '1JSjSLuto3jqdEnnG7JqzeC_1pUZw76n7XueVAYrUOpk'\n    SHEET_NAME = 'Sheet1'\n    url = f'https://docs.google.com/spreadsheets/d/{SHEET_ID}/gviz/tq?tqx=out:csv&sheet={SHEET_NAME}'\n    df = pd.read_csv(url, header=1, low_memory=False)\n    return df.loc[:, [not x.startswith('Unnamed') for x in df.columns]]\n    \ndef gene_list_names():\n    df = read_google_sheet()\n    return sorted(df.columns.tolist())\n\ndef gene_list(name):\n    df = read_google_sheet()\n    sr = df[name]\n    return sr[~sr.isnull()]\n    \ngene_list_names() # prints names in row 2 (row 1 is descriptive header for the sheet on Google Drive)\n\n['accel_reg_simiiformes_br',\n 'all_npx',\n 'all_post_mei_expr',\n 'ari_all',\n 'ari_nonPUR',\n 'ari_relate_AFR',\n 'ari_relate_ASIA',\n 'ari_relate_EUR',\n 'ari_relate_PUR',\n 'cDEG',\n 'candidates',\n 'ech75_regions',\n 'ech90_regions',\n 'expr_mod_xi_copynr_fibrobl',\n 'expr_mod_xi_copynr_lcl',\n 'gametologs',\n 'hpa_brain_prot',\n 'intel_seiz_lang',\n 'intelect_disabil',\n 'intersection(nDEG, matos_neuron)',\n 'matos_common',\n 'matos_common_no_xy_gametologs',\n 'matos_neuron',\n 'meritxell_spermatid_expr',\n 'msci',\n 'msci_esc',\n 'mult_copy',\n 'my_primate_codeml',\n 'nDEG',\n 'neuron_genome_proteome',\n 'neuron_npx_proteome',\n 'primate_ampl_multi',\n 'reg_sa_pheno',\n 'sfari_all_conf',\n 'union(H,matos_common)',\n 'xi',\n 'xi_any_evidence',\n 'xi_escape',\n 'xi_uncertain']\n\n\n\ndef gene_list_coords(gene_list):\n    append_list = []\n    for gene in gene_list:\n        coord = gi.gene_coord(gene, assembly='hg38')\n        if coord:\n            chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n            append_list.append((chrom, (start + end)/2, gene))\n        else:\n            print('skipped', gene)\n    return append_list\n    \nxi_escape_genes = gene_list('xi_escape')\n# annot_xi_escape = gene_list_coords(xi_escape_genes)\n\nsfari_genes = gene_list('sfari_all_conf')\n# annot_sfari_all_conf = gene_list_coords(sfari_genes)\n\ncDEG_genes = gene_list('cDEG')\n# annot_cDEG_genes = gene_list_coords(cDEG_genes)\n\nnDEG_genes = gene_list('nDEG')\n# annot_nDEG_genes = gene_list_coords(nDEG_genes)\n\nspermatid_expr_genes = gene_list('meritxell_spermatid_expr')\nannot_spermatid_expr_genes = gene_list_coords(spermatid_expr_genes)\n\naccel_reg_genes = gene_list('accel_reg_simiiformes_br')\n# annot_accel_reg_genes = gene_list_coords(accel_reg_genes)\n\nskipped BHLHB9\nskipped CA5BP1-CA5B\nskipped CH17-340M24.3\nskipped FAM104B\nskipped FLJ44635\nskipped IDS2\nskipped LINC00893\nskipped LINC00894\nskipped LOC101928128\nskipped LOC101928336\nskipped LOC101928415\nskipped LOC101928437\nskipped LOC101928832\nskipped LOC102724150\nskipped LOC105373133\nskipped LOC105373137\nskipped LOC105373146\nskipped LOC105373150\nskipped LOC105373151\nskipped LOC105373153\nskipped LOC105373154\nskipped LOC105373155\nskipped LOC105373182\nskipped LOC105373184\nskipped LOC105373188\nskipped LOC105373191\nskipped LOC105373194\nskipped LOC105373195\nskipped LOC105373292\nskipped LOC105373298\nskipped LOC105373302\nskipped LOC105373303\nskipped LOC105373313\nskipped LOC105373323\nskipped LOC105373335\nskipped LOC105373347\nskipped LOC105373369\nskipped LOC105373370\nskipped LOC105373383\nskipped LOC105373386\nskipped LOC105373387\nskipped LOC107985634\nskipped LOC107985664\nskipped LOC107985675\nskipped LOC107985678\nskipped LOC107985694\nskipped LOC107985695\nskipped LOC107985698\nskipped LOC107985701\nskipped LOC107985704\nskipped LOC107985707\nskipped LOC107985713\nskipped LOC107985714\nskipped LOC107985717\nskipped LOC107985719\nskipped LOC112268302\nskipped LOC728660\nskipped MAGEA10-MAGEA5\nskipped MTRNR2L10\nskipped PIR-FIGF\nskipped amplicon_chrX_CPXCR1_0\nskipped amplicon_chrX_CSAG1/2/3_0\nskipped amplicon_chrX_CSAG1/2/3_1\nskipped amplicon_chrX_CSAG1/2/3_2\nskipped amplicon_chrX_CSAG1/2/3_3\nskipped amplicon_chrX_CSAG1/2/3_4\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_0\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_1\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_10\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_11\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_12\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_13\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_14\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_15\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_16\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_2\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_3\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_4\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_5\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_6\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_7\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_8\nskipped amplicon_chrX_CT45A1/2/3//6/7/8/9/10_9\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_0\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_1\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_10\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_11\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_12\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_13\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_2\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_3\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_4\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_5\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_6\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_7\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_8\nskipped amplicon_chrX_CT47A1/2/3/4/5/6/7/8/9/10/11/12/B1_9\nskipped amplicon_chrX_CT55_0\nskipped amplicon_chrX_CT55_1\nskipped amplicon_chrX_CT55_2\nskipped amplicon_chrX_CT83_0\nskipped amplicon_chrX_CT83_1\nskipped amplicon_chrX_CTAG1A/1B/2_0\nskipped amplicon_chrX_CTAG1A/1B/2_1\nskipped amplicon_chrX_CTAG1A/1B/2_2\nskipped amplicon_chrX_CXorf49/B_0\nskipped amplicon_chrX_CXorf49/B_1\nskipped amplicon_chrX_CXorf49/B_2\nskipped amplicon_chrX_CXorf49/B_3\nskipped amplicon_chrX_CXorf49/B_4\nskipped amplicon_chrX_CXorf49/B_5\nskipped amplicon_chrX_CXorf49/B_6\nskipped amplicon_chrX_CXorf49/B_7\nskipped amplicon_chrX_CXorf51A/B_0\nskipped amplicon_chrX_CXorf51A/B_1\nskipped amplicon_chrX_DDX53_0\nskipped amplicon_chrX_DMRTC1/B/FAM236A/B/C/D_0\nskipped amplicon_chrX_EOLA1/2/HSFX3/4_0\nskipped amplicon_chrX_EOLA1/2/HSFX3/4_1\nskipped amplicon_chrX_ETD1/B/ZNF75D_0\nskipped amplicon_chrX_ETD1/B/ZNF75D_1\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_0\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_1\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_2\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_3\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_4\nskipped amplicon_chrX_F8/F8A1/2/3/H2AB1/2/3_5\nskipped amplicon_chrX_FAM156A/B_0\nskipped amplicon_chrX_FAM156A/B_1\nskipped amplicon_chrX_FAM47A/B/C_0\nskipped amplicon_chrX_FAM47A/B/C_1\nskipped amplicon_chrX_FAM47A/B/C_2\nskipped amplicon_chrX_G6PD/IKBKG_0\nskipped amplicon_chrX_G6PD/IKBKG_1\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_0\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_1\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_10\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_11\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_12\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_2\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_3\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_4\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_5\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_6\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_7\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_8\nskipped amplicon_chrX_GAGE10/1/2A/13/12B/12C/12D/12E/12F/12G/12H/12J_9\nskipped amplicon_chrX_HSFX1/2_0\nskipped amplicon_chrX_HSFX1/2_1\nskipped amplicon_chrX_IL3RA/P2RY8/SLC25A6_0\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_0\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_1\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_2\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_3\nskipped amplicon_chrX_MAGEA12/A2/A2B/A3/A6_4\nskipped amplicon_chrX_MAGEA4_0\nskipped amplicon_chrX_MAGEA9/9B_0\nskipped amplicon_chrX_MAGEA9/9B_1\nskipped amplicon_chrX_MAGEB6_0\nskipped amplicon_chrX_MAGEB6_1\nskipped amplicon_chrX_MAGEC1_0\nskipped amplicon_chrX_MBTPS2/YY2_0\nskipped amplicon_chrX_MBTPS2/YY2_1\nskipped amplicon_chrX_NSDHL_0\nskipped amplicon_chrX_NUDT10/11_0\nskipped amplicon_chrX_NUDT10/11_1\nskipped amplicon_chrX_NXF2/2B/5_0\nskipped amplicon_chrX_NXF2/2B/5_1\nskipped amplicon_chrX_NXF2/2B/5_2\nskipped amplicon_chrX_PABPC1L2A/B_0\nskipped amplicon_chrX_PABPC1L2A/B_1\nskipped amplicon_chrX_PAGE2/2B/5_0\nskipped amplicon_chrX_PAGE2/2B/5_1\nskipped amplicon_chrX_PAGE2/2B/5_2\nskipped amplicon_chrX_PAGE2/2B/5_3\nskipped amplicon_chrX_RHOXF2/B_0\nskipped amplicon_chrX_RHOXF2/B_1\nskipped amplicon_chrX_SPACA5/B_0\nskipped amplicon_chrX_SPACA5/B_1\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_0\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_1\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_2\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_3\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_4\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_5\nskipped amplicon_chrX_SPANXA1/A2/N1/N2/N3/N4/N5/B1/C/D_6\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_0\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_1\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_10\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_11\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_12\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_13\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_14\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_15\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_16\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_17\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_18\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_19\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_2\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_20\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_21\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_22\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_23\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_24\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_25\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_26\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_27\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_28\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_29\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_3\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_30\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_31\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_4\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_5\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_6\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_7\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_8\nskipped amplicon_chrX_SSX1/2/2B/344B/5/7_9\nskipped amplicon_chrX_SUPT20HL1/2_0\nskipped amplicon_chrX_SUPT20HL1/2_1\nskipped amplicon_chrX_TCEAL2/3/4/5/6_0\nskipped amplicon_chrX_TCEAL2/3/4/5/6_1\nskipped amplicon_chrX_TCEAL2/3/4/5/6_2\nskipped amplicon_chrX_TCEAL2/3/4/5/6_3\nskipped amplicon_chrX_TCEAL2/3/4/5/6_4\nskipped amplicon_chrX_TCP11X1/2_0\nskipped amplicon_chrX_TCP11X1/2_1\nskipped amplicon_chrX_TCP11X1/2_2\nskipped amplicon_chrX_TCP11X1/2_3\nskipped amplicon_chrX_TEX28_0\nskipped amplicon_chrX_TEX28_1\nskipped amplicon_chrX_TEX28_2\nskipped amplicon_chrX_TMEM185A_0\nskipped amplicon_chrX_TMEM185A_1\nskipped amplicon_chrX_VCX/2/3A/3B_0\nskipped amplicon_chrX_VCX/2/3A/3B_1\nskipped amplicon_chrX_VCX/2/3A/3B_2\nskipped amplicon_chrX_VCX/2/3A/3B_3\nskipped amplicon_chrX_XAGE1A/B_0\nskipped amplicon_chrX_XAGE1A/B_1\nskipped amplicon_chrX_XAGE3_0\nskipped amplicon_chrX_XAGE3_1\nskipped amplicon_chrX_XAGE3_2\nskipped amplicon_chrX_XAGE5_0\nskipped amplicon_chrX_XAGE5_1\n\n\n\nappend_gene_list_coords(annot, nDEG_genes)\n\n\n# # for gene in gene_list('cDEG'):\n# #     chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n# #     annot.append((chrom, (start + end)/2, gene, 'red'))\n# for gene in gene_list('sfari_all_conf'):\n#     chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n#     # annot.append((chrom, (start + end)/2, gene, 'blue'))\n#     annot.append((chrom, (start + end)/2, gene))    \n\n\n# for gene in gene_list('xi_escape'):\n#     chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n#     # annot.append((chrom, (start + end)/2, gene, 'green'))\n#     annot.append((chrom, (start + end)/2, gene))\n    \n\n\n# for gene in spermatid_expr_genes:\n#     coord = gi.gene_coord(gene, assembly='hg38')\n#     if coord:\n#         chrom, start, end, strand = gi.gene_coord(gene, assembly='hg38')[gene]\n#         # annot.append((chrom, (start + end)/2, gene, 'purple'))\n#         annot.append((chrom, (start + end)/2, gene))s\n#     else:\n#         print('skipped', gene)\n\n\nannot = annot_spermatid_expr_genes\nannot = [a[:3] for a in annot if a[0] == 'chrX']\nannot = sorted(list(set(annot)))\n\n\nsample = 1000\nFs = 153000000\nf = np.linspace(5, 50, sample)\nx = np.linspace(0, Fs, sample)\ny = np.sin(2* np.pi * f * x / Fs)\nchrom = ['chrX']*sample\ndf = pd.DataFrame(dict(x=x, y=y, chrom=chrom)).sort_values('x')\ndf['start'] = df.x.shift()\ndf['end'] = df.x\ndf = df.iloc[1:-1, :]\ndf = stairs(df)\ndf.head()\n\n\n\n\n\n\n\n\nx\ny\nchrom\nstart\nend\npos\n\n\n\n\n1\n153153.153153\n0.031725\nchrX\n0.000000\n153153.153153\n0.000000\n\n\n1\n153153.153153\n0.031725\nchrX\n0.000000\n153153.153153\n153153.153153\n\n\n2\n306306.306306\n0.063984\nchrX\n153153.153153\n306306.306306\n153153.153153\n\n\n2\n306306.306306\n0.063984\nchrX\n153153.153153\n306306.306306\n306306.306306\n\n\n3\n459459.459459\n0.096740\nchrX\n306306.306306\n459459.459459\n306306.306306\n\n\n\n\n\n\n\n\n# fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 4))\n# ax1.scatter(df.x, df.y, s=5)\n# add_lowess(df.x, df.y, ax=ax1, frac=0.02)\n\n# ax2.plot(df.pos, df.y)\n\n\n# ##########################################################################################\n# # interface\n# ##########################################################################################\n\n# ci = ChromIdeogram('chr1', axes_width_inches=18, axes_height_inches=3, ylim=(0, 2), rel_font_height=0.03) # plots chromosome\n\n# # ci.draw_chromosomes(base=1, height=0.10, facecolor='lightgray')\n# ci.draw_chromosomes(base=0, height=0.1, facecolor='none')\n\n\n# ci.map_fun(horizonplot, data=df, y='y', yaxis=(0, 0.3))\n\n\n# ci.add_labels(annot)\n\n\n\n\nfig, ax = plt.subplots(1, 1, figsize=(10, 1))\nplt.ylim(0, 1)\n\nhorizonplot(df, y='y', x='x', offset=0, height=1, ax=ax)\n#ax.set_axis_off()\n\n\n\n\n\n\n\n\n\nci = ChromIdeogram('chrX', axes_width_inches=18, axes_height_inches=4, ylim=(0, 10), \n                   rel_font_height=0.01, hspace=0.2, wspace=None,\n                   zooms=[(45_000_000, 55_000_000), \n                          # (65_000_000, 90_000_000), \n                           (115_000_000, 125_000_000),\n                         ]) \n\nci.draw_chromosomes(base=3.5, height=0.5, facecolor='none')\n\n# ci.add_labels(annot, \n#               colored = xi_escape_genes,\n#               bold = accel_reg_genes,\n# #              italic = spermatid_expr_genes,\n#               filled = cDEG_genes,\n# #              bold = nDEG_genes + nDEG_genes,\n#               # bold=['ZNF711', 'COX7B', 'PGK1'], \n#               # italic = ['TBX22'], \n#               # colored = ['NEXMIF', 'ATRX'],\n#               # framed = ['MAOA', 'ATRX'],\n#               # filled = ['PCDH19', 'ATRX'],\n#              )\n\n# ci.map_fun(horizonplot, data=df, x='x', y='y', offset=0, height=1000000)\nci.horizon(data=df, x='x', y='y', base=3.5, height=0.5, alpha=0.2)\n\n\n\n\nci.add_segments([('chrX', 25e6, 55e6), \n                 ('chrX', 98e6, 102e6)], label='segments', alpha=0.7)\nci.add_segments([('chrX', 115e6, 135e6)], facecolor='red', base=3.5, height=0.25, label='red segments', alpha=0.7)\nci.add_segments([('chrX', 125e6, 145e6)], facecolor='green', base=3.75, height=0.25, label='green segments', alpha=0.7)\nci.add_segments([('chrX', 35e6, 45e6), \n                 ('chrX', 100e6, 102e6), \n                 ('chrX', 120e6, 132e6)], facecolor='blue', base=3, height=0.25, label='blue segments', alpha=0.7)\n\nci.add_vlines()\nci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 1), s=5, c='C1', label='seaborn')\nci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(1.5, 2.4), s=5, c='C2', label='matplotlib')\nci.legend()\n\n\n\n\n\n\n\n\n\n##########################################################################################\n# interface\n##########################################################################################\n\nci = ChromIdeogram('chrX', axes_width_inches=18, axes_height_inches=3, ylim=(0, 3), rel_font_height=0.03) # plots chromosome\n\n# ci.draw_chromosomes(base=1, height=0.10, facecolor='lightgray')\nci.draw_chromosomes(base=1, height=0.20, facecolor='none')\n\nci.add_labels(annot)\n\nci.add_segments([('chrX', 25e6, 55e6), \n                 ('chrX', 98e6, 102e6)], label='segments', alpha=0.7)\nci.add_segments([('chrX', 115e6, 135e6)], facecolor='red', base=1, height=0.1, label='red segments', alpha=0.7)\nci.add_segments([('chrX', 125e6, 145e6)], facecolor='green', base=1.1, height=0.1, label='green segments', alpha=0.7)\nci.add_segments([('chrX', 35e6, 45e6), \n                 ('chrX', 100e6, 102e6), \n                 ('chrX', 120e6, 132e6)], facecolor='blue', base=0.8, height=0.1, label='blue segments', alpha=0.7)\n\nci.add_vlines()\n\n# plot using function that takes data and column name keyword args for dimensions (like seaborn's sns.scatterplot)\nci.map_fun(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.1, 0.3), s=5, c='C1', label='seaborn')\n\n# plot using matplotlib Axes method that x and y positional arguments (like matplotlib's Axes.scatter)\nci.map_method(Axes.scatter, data=df, x='x', y='y', yaxis=(0.4, 0.6), s=5, c='C2', label='matplotlib')\n\nci.legend()\n\n##########################################################################################\n# add axis\n##########################################################################################\n\nnew_ax, new_ax2, new_ax3 = ci.add_axes(3, height_ratio=0.3, hspace=0.3)\n\n\nnew_ax.vlines(list(range(*map(int, new_ax.get_xlim()), 2_000_000)), *new_ax.get_ylim(), color='gray', linewidth=0.1)\n\n# new_ax.plot(np.linspace(*new_ax.get_xlim(), 100), np.random.random(100), label='Line')\n_df = stairs(df)\nnew_ax.plot(_df.pos, _df.y, label='Stairs')\nnew_ax.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\n# new_ax2.scatter(np.linspace(*new_ax.get_xlim(), 100), np.random.random(100), s=5, label='Scatter')\nnew_ax2.scatter(df.x, df.y, s=5, c='black',label='Scatter')\nadd_lowess(df.x, df.y, ax=new_ax2, frac=0.02, c='red', label='Lowess')\nnew_ax2.legend(loc='center left', bbox_to_anchor=(1.02, 0.5), fontsize=\"10\", frameon=False) ;\n\n\nhorizonplot(df, y='y', ax=new_ax3)\n\n\n##########################################################################################\n# info annotation\n##########################################################################################\n\nfrom matplotlib.text import OffsetFrom\nimport textwrap\n\nstrs = \"DYNLT3: lka dflaks dlfkajs ldkajs dlfkajsd fasdfasdfl lakjsd las dflasd jflaksdj flaksjdf laksdjf laksdjf a flaksdj fla\"\n\nannot_kwargs=dict(fontsize=5, ha=\"left\", va=\"bottom\",\n             bbox=dict(\n                 # fc=\"0.97\", \n                 fc=\"w\",\n                 ec=\"red\",\n                       # alpha=0.2, \n                 linewidth=0.7),\n\n    arrowprops=dict(\n        facecolor='red', # color of arrow\n        shrink=0.01, # distance from point\n        width=1.5, # width of arrow\n        headwidth=5, # width of arrow head\n        headlength=7, # length of arrow head\n        connectionstyle=\"angle3,angleA=0,angleB=-90\", \n        # alpha=0.7,\n    ) \n                  \n             # arrowprops=dict(facecolor='red', arrowstyle=\"fancy\", \n             #                 connectionstyle=\"angle3,angleA=0,angleB=-90\", alpha=0.9)\n                  \n                 )\n\nci.ax.annotate(textwrap.fill(strs, 40), xy=(60000000, ci.map_y(1.2, ci.ax)), xytext=(30000000, ci.map_y(3.1, ci.ax)), xycoords=\"data\", textcoords=\"data\", **annot_kwargs)\n           \nci.ax.annotate(textwrap.fill(strs, 40), xy=(120000000, ci.map_y(1.2, ci.ax)), xytext=(100000000, ci.map_y(3.1, ci.ax)), xycoords=\"data\", textcoords=\"data\", **annot_kwargs) ;\n\nnew_ax.annotate(textwrap.fill(strs, 40), xy=(0.8, 0.7), xytext=(800, 200), xycoords=\"axes fraction\",\n             textcoords=OffsetFrom(ax.bbox, (0, 0), \"points\"), **annot_kwargs) ;\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\nfrom matplotlib.transforms import (Bbox, TransformedBbox,\n                                   blended_transform_factory)\nfrom mpl_toolkits.axes_grid1.inset_locator import (BboxConnector,\n                                                   BboxConnectorPatch,\n                                                   BboxPatch)\n\n\ndef connect_bbox(bbox1, bbox2,\n                 loc1a, loc2a, loc1b, loc2b,\n                 prop_lines, prop_patches=None):\n    if prop_patches is None:\n        prop_patches = {\n            **prop_lines,\n            \"alpha\": prop_lines.get(\"alpha\", 1) * 0.2,\n            \"clip_on\": False,\n        }\n\n    c1 = BboxConnector(\n        bbox1, bbox2, loc1=loc1a, loc2=loc2a, clip_on=False, **prop_lines)\n    c2 = BboxConnector(\n        bbox1, bbox2, loc1=loc1b, loc2=loc2b, clip_on=False, **prop_lines)\n\n    bbox_patch1 = BboxPatch(bbox1, ec='none', fc='none')\n    bbox_patch2 = BboxPatch(bbox2, **prop_patches)\n\n    p = BboxConnectorPatch(bbox1, bbox2,\n                           loc1a=loc1a, loc2a=loc2a, loc1b=loc1b, loc2b=loc2b,\n                           clip_on=False,\n                           **prop_patches)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\n\n\ndef zoom_effect(ax1, ax2, **kwargs):\n    \"\"\"\n    ax1 : the main Axes\n    ax1 : the zoomed Axes\n\n    Similar to zoom_effect01.  The xmin & xmax will be taken from the\n    ax1.viewLim.\n    \"\"\"\n\n    tt = ax1.transScale + (ax1.transLimits + ax2.transAxes)\n    trans = blended_transform_factory(ax2.transData, tt)\n\n    mybbox1 = ax1.bbox\n    mybbox2 = TransformedBbox(ax1.viewLim, trans)\n\n    prop_patches = {**kwargs, 'ec': 'black', 'fc': 'lightgray', 'alpha': 0.3, 'linewidth': 0.5}\n\n    c1, c2, bbox_patch1, bbox_patch2, p = connect_bbox(\n        mybbox1, mybbox2,\n        loc1a=2, loc2a=3, loc1b=1, loc2b=4,\n        prop_lines=kwargs, prop_patches=prop_patches)\n\n    ax1.add_patch(bbox_patch1)\n    ax2.add_patch(bbox_patch2)\n    ax2.add_patch(c1)\n    ax2.add_patch(c2)\n    ax2.add_patch(p)\n\n    return c1, c2, bbox_patch1, bbox_patch2, p\n\n\naxs = plt.figure().subplot_mosaic([\n    [\"main\", \"main\"],\n    [\"zoom1\", \"zoom2\"],\n])\n\naxs[\"main\"].set(xlim=(0, 5))\nzoom_effect(axs[\"zoom1\"], axs[\"main\"])\naxs[\"zoom1\"].set(xlim=(1, 2))\naxs[\"zoom2\"].set(xlim=(3, 4))\nzoom_effect(axs[\"zoom2\"], axs[\"main\"])\n\nplt.show()\n\n\n\n\n\n\n\n\n\nthe issue seems to be that I compute ylimits using the input data to horizonplot, not the data it plots…\n\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\n\n\nclass DrawExample():\n\n    def __init__(self, initial_data) -&gt; None:\n        \"\"\"Constructs a DrawExample for one column and multiple rows.\n\n        Note that subplots are added to the bottom.\n        \"\"\"\n        self.fig = plt.figure()\n\n        # Start with one subplot\n        self.row = 1\n        ax = self.fig.add_subplot(self.row, 1, 1)\n        ax.plot(initial_data)\n\n    def plot_bottom(self, data: list) -&gt; None:\n        \"\"\"Plots the data to a new subplot at the bottom.\"\"\"\n        self.row += 1\n        gs = gridspec.GridSpec(self.row, 1)\n\n        # Reposition existing subplots\n        for i, ax in enumerate(self.fig.axes):\n            ax.set_position(gs[i].get_position(self.fig))\n            ax.set_subplotspec(gs[i])\n\n        # Add new subplot\n        new_ax = self.fig.add_subplot(gs[self.row-1])\n        new_ax.plot(data)\n\n    def show(self) -&gt; None:\n        plt.show()\n\n\ndraw = DrawExample([1, 2, 3])\ndraw.plot_bottom([1, 4, 100])\ndraw.plot_bottom([10, -1, -2])\ndraw.show()\n\n\n\n\n\n\n\n\n\nci = GenomeIdeogram() # plots chromosome\nci.draw_chromosomes(base=0.05, height=0.15)\nci.add_labels(annot, y0=0.2, y1=0.3)\n#ci.map(plt.scatter, data=df, x='x', y='y', yaxis=(0.5, 0.7))\nci.map_dataframe(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.4, 0.6), s=1)\nci.map_dataframe(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.6, 0.8), s=1)\nci.map_dataframe(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.8, 1.0), s=1)\nci.map_dataframe(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.05, 0.25), s=1)\n\n\n\n\n\n\n\n\n\n# import pandas as pd\n# import math\n# from matplotlib.artist import Artist\n\n\n# axes_height = 1e4 # relative to length of chrom one\n# max_chrom_size = 1e5\n# aspect = axes_height / chrom_size\n\n# fig_width_inches = 8\n# axes_height_inches = fig_width * aspect\n# fig_height = axes_height_inches * nr_rows\n\n# nr_rows = 11\n# fig, axes = plt.subplots(nr_rows, 1, figsize=(fig_width, fig_width*aspect*nr_rows), sharex=True, sharey=True)\n# plt.subplots_adjust(hspace=0)\n# ax = axes[0]\n\n# xlim = (0, max_chrom_size)\n# ylim = (0, 6)\n# scaled_y_lim = xlim[0] * aspect, xlim[1] * aspect\n# ax.set_xlim(xlim)\n# ax.set_ylim(scaled_y_lim)\n# plt.yticks([])\n# y_unit = -sub(*scaled_y_lim) / -sub(*ylim)\n\n# rel_font_height = 0.1\n# font_size = rel_font_height * axes_height_inches / point_size\n\n\n# def draw_text(x_pos, y_pos, text, font_size, rel_font_height, ax, y_line_bottom=0):\n \n#     ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#                 horizontalalignment='left',# weight='bold',\n#                 verticalalignment='bottom', \n#                 rotation=45, zorder=3, \n#                 bbox=dict(boxstyle='square,pad=0', fc='none', ec='none'))\n#     (_, a), (_, b) = ax.transAxes.transform([(0, 0), (0, rel_font_height / 2)])\n#     z = b - a    \n#     z = 300\n#     z = y_unit/6\n\n#     ax.plot((x_pos, x_pos, x_pos+z),\n#             (y_line_bottom, y_pos, y_pos+z), \n#             linewidth=0.5, color='gray')\n\n\n# def get_polygon(text:str, x_pos:int, y_pos:float, font_size:float, ax:matplotlib.axes.Axes) -&gt; Polygon:\n\n#     y_pos = y_pos * y_unit\n#     # x_pos, y_pos = chrom_size/2, 2*y_unit\n    \n#     # ax.scatter([x_pos], [y_pos], marker='X', color='black')\n    \n    \n#     t = ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#                 horizontalalignment='left',# weight='bold',\n#                 verticalalignment='bottom', \n#                 rotation=0, zorder=3, \n#                 bbox=dict(boxstyle='square,pad=0', fc='none', ec='none', alpha=0.4))\n#     # t.set_visible(False)\n    \n#     transf = ax.transData.inverted()\n#     bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n#     bbt = bb.transformed(transf)\n#     coords = bbt.get_points()\n    \n#     Artist.remove(t)\n    \n#     (x0, y0), (x1, y1) = coords\n#     coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n#     # ax.scatter(*coords.T, c='red')\n    \n#     # ax.scatter(*zip(*coords), transform=ax.transAxes, s=1, color='green', zorder=3)\n    \n#     x, y = zip(*coords)\n#     df = pd.DataFrame(dict(x=x, y=y))\n#     df['y'] -= y_pos\n#     df['x'] -= x_pos\n#     dfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\n#     df['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\n#     df['x'] = dfx\n#     df['y'] += y_pos\n#     df['x'] += x_pos\n    \n#     #df['x'] -= df['x'][1] - df['x'][0]\n    \n#     coords = np.array(list(zip(df.x, df.y)))\n    \n#     x_pos, y_pos = df['x'][0] - (df['x'][0] - df['x'][1]), df['y'][0]\n#     # _ = ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#     #             horizontalalignment='left',# weight='bold',\n#     #             verticalalignment='bottom', \n#     #             rotation=45, zorder=3, \n#     #             bbox=dict(boxstyle='square,pad=0', fc='none', ec='none'))\n    \n#     # ax.scatter(*coords.T, c='blue')\n    \n#     # ax.plot(*zip(*coords), linewidth=0.2)\n\n#     return x_pos, y_pos, Polygon([Point(x, y) for x, y in zip(df.x, df.y)])\n\n\n# annot = [(x, 'AKAP4') for x in range(1, int(max_chrom_size), int(max_chrom_size/200))]\n\n# for i, ax in enumerate(axes):\n#     annot = [(x, 'AKAP4') for x in range(1, int(max_chrom_size), int(max_chrom_size/(10*(i+1))))]\n\n#     polybuff = []\n#     for pos, name in annot:\n#         x, y, poly = get_polygon(name, pos, 1, rel_font_height, ax)\n\n#         while any(is_polygons_intersecting(poly, p) for p in polybuff):\n#             nudge = 0.1 * y_unit\n#             y += nudge\n#             poly.nudge_y(nudge)\n#         draw_text(x, y, name, font_size, rel_font_height, ax)\n\n#         if len(polybuff) &gt; 5:\n#             del polybuff[0]\n#         polybuff.append(poly)\n\n\nimport matplotlib.transforms\n\nfrom matplotlib.transforms import Bbox\nfig, ax = plt.subplots()\nplt.xlim(0, 0.5)\nplt.ylim(0, 1)\n\nt = ax.text(0.2, 0.2, 'Text', fontsize=30, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\nprint(coords)\n(x0, y0), (x1, y1) = coords\nplt_coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*plt_coords.T, c='red')\n\n\nfrom operator import sub\naspect_ratio = sub(*ax.get_ylim()) / sub(*ax.get_xlim())\n\n#x0, y0 = coords[0]\n# (x0, y0), (x1, y2) = coords\ntrafo = matplotlib.transforms.Affine2D().rotate_deg_around(x0,y0,45).skew(1, 1.3)#.scale(0.5)\n\ncoords = trafo.transform([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n# coords = trafo.transform([(x0, y0), (x1, y1)])\n# coords = trafo.transform(coords)\nprint(coords)\n\nax.scatter(*coords.T, zorder=10)\n\ndisp_ratio = ax.get_data_ratio()\nbbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\ndisp_ratio = bbox.width / bbox.height\nprint(disp_ratio)\n\n\n\n(x0, y0), (x0, y1), (x1, y1), (x1, y0) = coords\ncoords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*coords.T)\n\n\nPolygon([Point(x0, y0), Point(bbt.xmin, b[1]+(b[0]-bbt.xmin)), Point(b[2], b[3]), Point(bbt.xmax, b[3]-(b[0]-bbt.xmin))])\n\n\n#Bbox.count_overlaps\n\n[[0.2        0.2       ]\n [0.27711694 0.30281385]]\n[[0.51148154 0.92042049]\n [0.55200529 0.73124667]\n [0.6914605  0.9821989 ]\n [0.65093675 1.17137271]]\n1.3419913419913418\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.transforms as transforms\n\nfig, ax = plt.subplots()\n\n# [[0.25574077 0.46021024]\n#  [0.29626452 0.27103643]\n#  [0.43571973 0.52198865]\n#  [0.39519598 0.71116247]]\n\n# [[0.1        0.1       ]\n#  [0.17711694 0.20281385]]\nr1 = patches.Rectangle((0.1, 0.1), 0.2, 0.1, color=\"blue\", alpha=0.5)\nr2 = patches.Rectangle((0.1, 0.1), 0.2, 0.1, color=\"red\", alpha=0.5)\n\n\np = 0.1, 0.1 # rotate around this point\n\nx_lim = (0, 0.5)\ny_lim = (0, 1)\nax.set_xlim(x_lim)\nax.set_ylim(y_lim)\n\nx_range = x_lim[1] - x_lim[0]\ny_range = y_lim[1] - y_lim[0]\naspect_ratio = y_range / x_range\n\nmove_transform = transforms.Affine2D().translate(-p[0], -p[1])\ninverse_move_transform = transforms.Affine2D().translate(p[0], p[1])\ninverse_scale_transform = transforms.Affine2D().scale(1, 1 / aspect_ratio)\nrotate_transform = transforms.Affine2D().rotate_deg(45)\nscale_transform = transforms.Affine2D().scale(1, aspect_ratio)\n\ntotal_transform = move_transform + inverse_scale_transform + rotate_transform + scale_transform + inverse_move_transform + ax.transData\n\nr2.set_transform(total_transform)\n\nax.add_patch(r1)\nax.add_patch(r2)\n\n# print(ax.transLimits.transform([(0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1)]))\n# print(total_transform.transform([(0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1)]))\n# print(r2.get_bbox())\n# x0, y0, width, height = r2.get_bbox().bounds()\n# print(x0, y0)\n# coords = [(x0, y0), \n#           (x0 - sqrt(height**2 / 2), y0 + sqrt(height**2 / 2)), \n#           (x0 - sqrt(height**2 / 2) + sqrt(width**2 / 2), y0 + sqrt(height**2 / 2)) +  + sqrt(width**2 / 2), \n#           (x0 + sqrt(width**2 / 2), y0 + sqrt(width**2 / 2))]\n# plt.scatter(*zip(*coords))\n\n# coords = ((0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1))\n# plt.scatter(*zip(*coords))\n# coords = total_transform.transform(coords)\n# print(coords)\n# plt.scatter(*zip(*coords))\n\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib as mpl\nfrom math import *\n\n#some helper values\np=4\ntheta=pi/6\nx1 = p*cos(theta/2)\ny1 = p*sin(theta/2)\nvertices =[(-x1-p/2,0), (-p/2, y1), (p/2, y1), (x1+p/2, 0), (p/2, -y1), (-p/2, -y1)] \nmidPoint = [3,4]\nendPoint = (-x1-p/2,0)\n\n#set up the plot\nfig = plt.figure()\nax = fig.add_subplot(111)\n\n#function to rotate and translate the standard shape to a new position\ndef plot_polygon(vertices, midPoint, theta, color):\n    polygon = patches.Polygon(vertices, color=color, alpha=0.50) \n    r = mpl.transforms.Affine2D().rotate_around(midPoint[0],midPoint[1], theta)\n    # t = mpl.transforms.Affine2D().translate(midPoint[0],midPoint[1])\n    tra = r + ax.transData\n    # r = mpl.transforms.Affine2D().rotate(theta)\n    # t = mpl.transforms.Affine2D().translate(midPoint[0],midPoint[1])\n    # tra = r + t + ax.transData\n    polygon.set_transform(tra)\n    ax.add_patch(polygon)\n\n    return r.transform(polygon.xy)\n\np = plot_polygon(vertices, endPoint, 0, \"blue\")\n#plot_polygon(vertices, midPoint, theta, \"blue\")\np_ = plot_polygon(vertices, endPoint, theta, \"orange\")\n\n# print(p.get_xy())\n# print(p_.get_xy())\n# print(p.get_transform().transform(p.xy))\n# print(p_.get_transform().transform(p_.xy))\n#The correct answer is: tra.transform(poly.xy)\n\n\nplt.scatter(*zip(*p), color='blue', alpha=0.5)\nplt.scatter(*zip(*p_), color='orange', alpha=0.5)\n\n# plt.xlim(-10, 10)\n# plt.ylim(-10, 10)\n\nplt.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nchrom_size = 12e5\nylim = (0, 3)\nxlim = (0, chrom_size)\ndata_height = (ylim[1] - ylim[0])\ndata_width = (xlim[1] - xlim[0])\naspect = data_height / data_width\naspect\n# data_width * aspect\n# ylim = ylim * sub(*ylim) / sub(*xlim)\n# chrom_size * sub(*ylim) / sub(*xlim)\n\n2.5e-06\n\n\n\nimport pandas as pd\nimport math\nfrom operator import sub\ncoords = [(0, 0), (0, 1e4), (3e4, 1e4), (3e4, 0)]\n\n\nchrom_size = 12e5\nylim = np.array([0, 3])\nxlim = np.array([0, chrom_size])\nylim = sub()sub(ylim) / sub(xlim) *\n\n# fig, (ax, ax2) = plt.subplots(2, 1, figsize=(10, 1), sharex=True)\nfig, ax = plt.subplots(1, 1, figsize=(10, 1), sharex=True)\nax.set_xlim(-6e5, 6e5)\nax.set_ylim(-6e4, 6e4)\nax.axis('equal')\n\n# t = ax.text(0, 0, 'Text', fontsize=7, horizontalalignment='left',# weight='bold',\n#                          verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none', alpha=0.4))\n# box = t.get_bbox_patch()\n# fig.canvas.draw()\n# ax.axis('equal')\n# ax.set_xlim(-6e5, 6e5)\n# ax.set_ylim(-4e5, 4e5)\n# # coords = ax.transData.inverted().transform(box.get_window_extent())\n# #coords = ax.transAxes.transform(coords)\n\n# # print(coords)\n# # print(ax.transLimits.transform(coords))\n\nt = ax.text(0, 0, 'Text', fontsize=7, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none', alpha=0.4))\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\n\n(x0, y0), (x1, y1) = coords\ncoords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\nax.scatter(*coords.T, c='red')\n\n# ax.scatter(*zip(*coords), transform=ax.transAxes, s=1, color='green', zorder=3)\n\nx, y = zip(*coords)\ndf = pd.DataFrame(dict(x=x, y=y))\ndfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\ndf['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\ndf['x'] = dfx\ncoords = np.array(list(zip(df.x, df.y)))\n\nax.scatter(*coords.T, c='blue')\n\nax.plot(*zip(*coords))\n\n# ax.axis('equal')\n# ax.set_xlim(-6e5, 6e5)\n# ax.set_ylim(-4e5, 4e5)\n\nrect = patches.Rectangle((-6e5, -2e4), 12e5, 1e4, color=\"blue\", alpha=0.5)\nax.add_patch(rect) ;\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots()\nplt.xlim(0, 0.5)\nplt.ylim(0, 1)\nt = ax.text(0.2, 0.2, 'Text', fontsize=30, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\n\n\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\nprint(coords)\n(x0, y0), (x1, y1) = coords\nplt_coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*plt_coords.T, c='red')\n\n\n[[0.2        0.2       ]\n [1.97368952 0.30281385]]\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.transforms\n\nfrom matplotlib.transforms import Bbox\nfig, ax = plt.subplots()\n\ndef get_polygon(t):\n\n    transf = ax.transData.inverted()\n    bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    bbt = bb.transformed(transf)\n    coords = bbt.get_points()\n\n    x0, y0 = coords[0]\n    trafo = matplotlib.transforms.Affine2D().rotate_around(x0,y0,-)\n    print(trafo.transform(coords))\n\n# bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    # coords = bb.get_points()\n    # print(coords)\n    # x0, y0 = coords[0]\n    # print(x0, y0)\n    # trafo = matplotlib.transforms.Affine2D().rotate_around(x0,y0,45)\n\n    # coords = bb.get_points()\n    # print(coords)\n    # print(trafo.transform(coords))\n\n    # transf = ax.transData.inverted()\n    # bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    # bbt = bb.transformed(transf)\n    # # return bbt\n    # b = bbt.bounds\n    # # print(dir(bbt), bbt.rotated(0.785398).corners())\n\n    # return Polygon([Point(b[0], b[1]), Point(bbt.xmin, b[1]+(b[0]-bbt.xmin)), Point(b[2], b[3]), Point(bbt.xmax, b[3]-(b[0]-bbt.xmin))])\n    # # return Polygon([Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin)])\n\nt = ax.text(0.1, 0.1, 'Text', fontsize=17, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=45, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\na = get_polygon(t)\n#xs, ys = zip(*[(p.x, p.y) for p in a.get_points()])\n# print(xs, ys)\n\nt = ax.text(0.1, 0.23, 'Text', fontsize=17, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=45, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\n#ax.plot(xs,ys) \nb = get_polygon(t)\nis_polygons_intersecting(a, b)\n\n#print(Bbox.intersection(a, b))\n\n[[0.1        0.1       ]\n [0.25716788 0.0862437 ]]\n[[0.1        0.23      ]\n [0.25716788 0.2162437 ]]\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[391], line 48\n     46 #ax.plot(xs,ys) \n     47 b = get_polygon(t)\n---&gt; 48 is_polygons_intersecting(a, b)\n\nCell In[30], line 17, in is_polygons_intersecting(a, b)\n     14 for x in range(2):\n     15     polygon = a if x == 0 else b\n---&gt; 17     for i1 in range(len(polygon.get_points())):\n     18         i2 = (i1 + 1) % len(polygon.get_points())\n     19         p1 = polygon.get_points()[i1]\n\nAttributeError: 'NoneType' object has no attribute 'get_points'\n\n\n\n\n\n\n\n\n\n\n\nimport importlib\nimport geneinfo\nimportlib.reload(geneinfo)\n\ngi.chrom_ideogram(annotation, figsize=(8, 8))\n\nBbox(x0=72266463.49999999, y0=2.299999999999999, x1=78844788.63027559, y1=4.219218090860526)\nBbox(x0=38185129.999999985, y0=2.299999999999999, x1=43874492.27483292, y1=3.959864294798294)\nBbox(x0=2916660.500000015, y0=2.299999999999999, x1=8677139.803268358, y1=3.9806125984832725)\nBbox(x0=1428450.5, y0=2.299999999999999, x1=8042334.144493267, y1=4.229592242703012)\nBbox(x0=44533249.000000015, y0=2.299999999999999, x1=52320563.613677576, y1=4.571939253505164)\nBbox(x0=6908011.500000015, y0=2.299999999999999, x1=12632932.289050654, y1=3.9702384466407814)\nBbox(x0=53064702.000000015, y0=2.299999999999999, x1=60531989.985718235, y1=4.478571886922758)\nBbox(x0=119654546.99999999, y0=2.299999999999999, x1=127619654.1847661, y1=4.623810012717609)\nBbox(x0=48684013.500000015, y0=2.299999999999999, x1=53626646.976261124, y1=3.7420071061060156)\nBbox(x0=15840368.500000015, y0=2.299999999999999, x1=22169784.03075163, y1=4.146599027963099)\nBbox(x0=16742475.999999985, y0=2.299999999999999, x1=23107450.044969335, y1=4.15697317980559)\nBbox(x0=111713229.99999999, y0=2.299999999999999, x1=118042645.53075166, y1=4.146599027963099)\nBbox(x0=1597062.000000015, y0=2.299999999999999, x1=10059988.383813992, y1=4.769048138512458)\nBbox(x0=40692081.499999985, y0=2.299999999999999, x1=47341523.65871097, y1=4.239966394545505)\nBbox(x0=56565747.500000015, y0=2.299999999999999, x1=64246386.57102446, y1=4.540816797977694)\nBbox(x0=53398438.500000015, y0=2.299999999999999, x1=60225673.229799524, y1=4.29183715375795)\nBbox(x0=14016183.500000015, y0=2.299999999999999, x1=21447912.97150053, y1=4.468197735080267)\nBbox(x0=2784270.0, y0=2.299999999999999, x1=6482355.478641406, y1=3.37891179161889)\nBbox(x0=41161011.999999985, y0=2.299999999999999, x1=47739337.13027556, y1=4.219218090860526)\nBbox(x0=48896799.500000015, y0=2.299999999999999, x1=55510683.1444933, y1=4.2295922427030135)\nBbox(x0=44992983.500000015, y0=2.299999999999999, x1=51784659.71558182, y1=4.281463001915462)\nBbox(x0=53609424.000000015, y0=2.299999999999999, x1=60792243.87197657, y1=4.395578672182843)\nBbox(x0=13699816.000000015, y0=2.299999999999999, x1=20313699.644493297, y1=4.2295922427030135)\nBbox(x0=72646566.50000001, y0=2.299999999999999, x1=79260450.1444933, y1=4.2295922427030135)\nBbox(x0=20061809.999999985, y0=2.299999999999999, x1=27742449.071024433, y1=4.540816797977694)\nBbox(x0=70285815.99999999, y0=2.299999999999999, x1=77575311.41462968, y1=4.426701127710309)\nBbox(x0=40637241.000000015, y0=2.299999999999999, x1=47926736.41462971, y1=4.426701127710309)\nBbox(x0=76429526.00000001, y0=2.299999999999999, x1=84430191.6989838, y1=4.6341841645601)\nBbox(x0=2361155.5, y0=2.299999999999999, x1=9295065.772452638, y1=4.322959609285416)\nBbox(x0=85954370.49999999, y0=2.299999999999999, x1=90968121.0046965, y1=3.7627554097909943)\nBbox(x0=148750640.0, y0=2.299999999999999, x1=154048858.61843812, y1=3.845748624530909)\nBbox(x0=150437800.0, y0=2.299999999999999, x1=158331790.1563307, y1=4.60306170903263)\nBbox(x0=13667538.000000015, y0=2.299999999999999, x1=21597086.670548394, y1=4.613435860875121)\nBbox(x0=129754242.50000001, y0=2.299999999999999, x1=138430519.9691202, y1=4.831293049567396)\nBbox(x0=13723439.500000015, y0=2.299999999999999, x1=22399716.96912022, y1=4.831293049567396)\nBbox(x0=11766965.500000015, y0=2.299999999999999, x1=17242976.68952672, y1=3.897619383743354)\nBbox(x0=20133181.500000015, y0=2.299999999999999, x1=27031533.258234933, y1=4.312585457442928)\nBbox(x0=66215769.000000015, y0=2.299999999999999, x1=72082923.8459215, y1=4.011735054010739)\nBbox(x0=311072.0, y0=2.299999999999999, x1=7885035.528371349, y1=4.509694342450224)\nBbox(x0=154553122.5, y0=2.299999999999999, x1=160704745.4596631, y1=4.094728268750654)\nBbox(x0=16815475.499999985, y0=2.299999999999999, x1=23464917.658711, y1=4.239966394545505)\nBbox(x0=2716248.0, y0=2.299999999999999, x1=8156700.6753089875, y1=3.887245231900865)\nBbox(x0=30568287.499999985, y0=2.299999999999999, x1=35795389.09000276, y1=3.8250003208459304)\nBbox(x0=3327608.5, y0=2.299999999999999, x1=10190401.744017228, y1=4.302211305600441)\nBbox(x0=71099693.00000001, y0=2.299999999999999, x1=77855810.70136411, y1=4.271088850072971)\nBbox(x0=7475797.500000015, y0=2.299999999999999, x1=11920611.77721323, y1=3.5967689803111647)\nBbox(x0=103357475.49999999, y0=2.299999999999999, x1=110753646.4572828, y1=4.457823583237779)\nBbox(x0=47202994.499999985, y0=2.299999999999999, x1=52750122.7179621, y1=3.918367687428333)\nBbox(x0=115172356.00000001, y0=2.299999999999999, x1=121786239.6444933, y1=4.2295922427030135)\nBbox(x0=41348910.000000015, y0=2.299999999999999, x1=47998352.158711, y1=4.239966394545505)\nBbox(x0=2855820.0, y0=2.299999999999999, x1=8616299.303268328, y1=3.9806125984832725)\nBbox(x0=18297000.500000015, y0=2.299999999999999, x1=24910884.144493297, y1=4.2295922427030135)\nBbox(x0=15810425.000000015, y0=2.299999999999999, x1=22388750.130275592, y1=4.219218090860526)\nBbox(x0=2493695.0, y0=2.299999999999999, x1=8965344.587622449, y1=4.188095635333056)\nBbox(x0=74007178.49999999, y0=2.299999999999999, x1=78309758.72034238, y1=3.5552723729412072)\nBbox(x0=136179030.5, y0=2.299999999999999, x1=141477249.11843812, y1=3.845748624530909)\nBbox(x0=81157805.99999999, y0=2.299999999999999, x1=88269508.84354116, y1=4.374830368497864)\nBbox(x0=140783972.0, y0=2.299999999999999, x1=146473334.2748329, y1=3.959864294798294)\nBbox(x0=53273589.000000015, y0=2.299999999999999, x1=60456408.8719766, y1=4.395578672182843)\nBbox(x0=47223928.500000015, y0=2.299999999999999, x1=53695578.08762245, y1=4.188095635333056)\nBbox(x0=72036297.50000001, y0=2.299999999999999, x1=78543505.60184015, y1=4.198469787175547)\nBbox(x0=16854822.500000015, y0=2.299999999999999, x1=23397589.116057888, y1=4.208843939018035)\nBbox(x0=73836686.00000001, y0=2.299999999999999, x1=78743760.96204342, y1=3.731632954263528)\nBbox(x0=24066878.000000015, y0=2.299999999999999, x1=30751878.672928706, y1=4.250340546387992)\nBbox(x0=1389132.5, y0=2.299999999999999, x1=9567590.770072356, y1=4.686054923772543)\nBbox(x0=17555597.000000015, y0=2.299999999999999, x1=22320437.9051726, y1=3.6901363468935706)\nBbox(x0=24182714.000000015, y0=2.299999999999999, x1=28591969.762995526, y1=3.586394828468677)\nBbox(x0=138918752.0, y0=2.299999999999999, x1=145248167.53075165, y1=4.146599027963099)\nBbox(x0=68835590.50000001, y0=2.299999999999999, x1=75342798.60184018, y1=4.198469787175547)\nBbox(x0=78954529.50000001, y0=2.299999999999999, x1=86208466.40041198, y1=4.416326975867822)\nBbox(x0=1499883.000000015, y0=2.299999999999999, x1=7864857.044969365, y1=4.156973179805588)\nBbox(x0=1359652.5, y0=2.299999999999999, x1=7155690.317486033, y1=3.9909867503257583)\nBbox(x0=3658994.5, y0=2.299999999999999, x1=9348356.774832949, y1=3.959864294798294)\nBbox(x0=153932152.5, y0=2.299999999999999, x1=160403802.08762246, y1=4.188095635333056)\nBbox(x0=71105338.50000001, y0=2.299999999999999, x1=78394833.91462971, y1=4.426701127710309)\nBbox(x0=77903407.99999999, y0=2.299999999999999, x1=84659525.70136409, y1=4.271088850072971)\nBbox(x0=7912993.000000015, y0=2.299999999999999, x1=15344722.47150053, y1=4.468197735080267)\nBbox(x0=48514886.500000015, y0=2.299999999999999, x1=55591030.829323485, y1=4.364456216655377)\nBbox(x0=153959687.5, y0=2.299999999999999, x1=160680246.68714643, y1=4.260714698230483)\nBbox(x0=79160003.00000001, y0=2.299999999999999, x1=86627290.9857182, y1=4.478571886922758)\nBbox(x0=289839.0000000149, y0=2.299999999999999, x1=7792685.49993594, y1=4.488946038765246)\nBbox(x0=132049622.49999999, y0=2.299999999999999, x1=138272362.4880985, y1=4.115476572435632)\nBbox(x0=13756349.000000015, y0=2.299999999999999, x1=19339035.732179835, y1=3.928741839270824)\nBbox(x0=360444.0000000149, y0=2.299999999999999, x1=8823370.383814022, y1=4.769048138512458)\nBbox(x0=53200849.500000015, y0=2.299999999999999, x1=60063642.74401723, y1=4.302211305600441)\nBbox(x0=15738620.500000015, y0=2.299999999999999, x1=21285748.71796213, y1=3.918367687428333)"
  },
  {
    "objectID": "pages/chrom_ideograms-Copy1.html",
    "href": "pages/chrom_ideograms-Copy1.html",
    "title": "Chromosome ideograms",
    "section": "",
    "text": "from collections import defaultdict\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nsns.set_style('white')\n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n\nimport geneinfo as gi\ngi.email('your@email.com')\n\n\nannotation = [\n    ('chr1', 50000000, 50001000),                          # segment color defaults to red\n    ('chr2', 10000000, 1000000, 'green'),                  # with segment color\n    ('chr3', 45000000, 55000000, 'blue', 'NAME'),          # with name label\n    ('chr6', 10000000, 15000000, 'magenta', None, 0, 0.5), # with base and height\n    ('chr6', 10000000, 15000000, 'pink', None, 0.5, 0.5),  # with base and height\n]\n\ngi.chrom_ideogram(annotation, figsize=(8, 8))\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[2], line 9\n      1 annotation = [\n      2     ('chr1', 50000000, 50001000),                          # segment color defaults to red\n      3     ('chr2', 10000000, 1000000, 'green'),                  # with segment color\n   (...)\n      6     ('chr6', 10000000, 15000000, 'pink', None, 0.5, 0.5),  # with base and height\n      7 ]\n----&gt; 9 gi.chrom_ideogram(annotation, figsize=(8, 8))\n\nFile ~/geneinfo/geneinfo/__init__.py:2078, in chrom_ideogram(annot, hspace, min_visible_width, figsize, assembly)\n   2074     ax.add_patch(Rectangle((cent_start, 0), cent_end-cent_start, 3, \n   2075                                fill=True, color='white',\n   2076                                zorder=2))\n   2077     xy = [[cent_start, 1], [cent_start, 2], [cent_end, 1], [cent_end, 2]]\n-&gt; 2078     g = ax.add_patch(Polygon(xy, closed=True, zorder=3, fill=True,\n   2079                              # color='#666666',\n   2080                              color='#777777',\n   2081                             ))\n   2084 def plot_segment(chrom, start, end, color='red', label=None, base=0, height=1):\n   2086     base += 1\n\nTypeError: Polygon.__init__() got an unexpected keyword argument 'closed'\n\n\n\n\n\n\n\n\n\n\nTo make sure segments are visible on the plot, the default minimal size of plotteed segments are 200000. This can be changed like this (notice how the chr1 segment is no longer visible):\n\ngi.chrom_ideogram(annotation, figsize=(8, 8), min_visible_width=1, hspace=0)\n\nOther assembly, figure dimentions:\n\ngi.chrom_ideogram(annotation, assembly='hg19', figsize=(8, 8))\n\nYou can add position markers along a chromosome like this to better see the location of some segments:\n\nchrom = 'chr3'\nstart = 100000000\nend = 200000000\nwidth = 10000000\nannotation2 = annotation + [(chrom, x[0], x[1], 'black', str(x[2]/width)) for x in zip(\n    range(start, end, width), \n    range(start+1, end, width), \n    range(start, end, width)\n)]\ngi.chrom_ideogram(annotation2, figsize=(8, 8))\n\n\nlists = gi.GoogleSheet()\n\n\nimport importlib\nimport geneinfo\nimportlib.reload(geneinfo)\n\ncoords = gi.gene_coord(lists.get('xi_escape'), assembly='GRCh38')\nannotation = [(c, s, e, 'red', g) for g, (c, s, e, _) in coords.items()]\n\n\ncoords = gi.gene_coord(['ATRX', 'MAGT1'], assembly='GRCh38')\nannotation = [(c, s, e, 'red', g) for g, (c, s, e, _) in coords.items()]\n\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def get_points(self):\n        return self.points\n\n    def nudge_y(self, nudge):\n        for point in self.points:\n            point.y += nudge\n\ndef is_polygons_intersecting(a, b):\n    for x in range(2):\n        polygon = a if x == 0 else b\n\n        for i1 in range(len(polygon.get_points())):\n            i2 = (i1 + 1) % len(polygon.get_points())\n            p1 = polygon.get_points()[i1]\n            p2 = polygon.get_points()[i2]\n\n            normal = Point(p2.y - p1.y, p1.x - p2.x)\n\n            min_a = float('inf')\n            max_a = float('-inf')\n\n            for p in a.get_points():\n                projected = normal.x * p.x + normal.y * p.y\n                min_a = min(min_a, projected)\n                max_a = max(max_a, projected)\n\n            min_b = float('inf')\n            max_b = float('-inf')\n\n            for p in b.get_points():\n                projected = normal.x * p.x + normal.y * p.y\n                min_b = min(min_b, projected)\n                max_b = max(max_b, projected)\n\n            if max_a &lt; min_b or max_b &lt; min_a:\n                return False\n\n    return True\n\na = list(zip([0, 0, 2, 2], [0, 2, 2, 0]))\nb = list(zip([1, 1, 3, 3], [1, 3, 3, 1]))\n\nis_polygons_intersecting(\n    Polygon([Point(*tup) for tup in a]),\n    Polygon([Point(*tup) for tup in b])\n)\n\nTrue\n\n\n\nimport pandas as pd\nimport math\nfrom matplotlib.artist import Artist\nfrom operator import sub\n\n\naxes_height_inches = 0.8\naspect = 0.1\naxes_width_inches = axes_height_inches / aspect\nmax_chrom_size = 1e5\naxes_height = aspect * max_chrom_size\nfig_height = axes_height_inches * nr_rows\nfig_width = fig_height / nr_rows / aspect \n\n# axes_height = 1e4 # relative to length of chrom one\n# max_chrom_size = 1e5\n# aspect = axes_height / max_chrom_size\n# fig_width = 8\n# axes_height_inches = fig_width_inches * aspect\n# fig_height = axes_height_inches * nr_rows\n\nprint(axes_height, aspect, axes_height_inches, fig_width, fig_height)\n\npoint_size = 1/72\n\nnr_rows = 11\nfig, axes = plt.subplots(nr_rows, 1, figsize=(fig_width, fig_width*aspect*nr_rows), sharex=True, sharey=True)\nplt.subplots_adjust(hspace=0)\nax = axes[0]\n\nxlim = (0, max_chrom_size)\nylim = (0, 1)\nscaled_y_lim = xlim[0] * aspect, xlim[1] * aspect\nax.set_xlim(xlim)\nax.set_ylim(scaled_y_lim)\nplt.yticks([])\ny_unit = -sub(*scaled_y_lim) / -sub(*ylim)\n\nrel_font_height = 0.07\nfont_size = rel_font_height * axes_height_inches / point_size\n\n\ndef draw_text(x_pos, y_pos, text, font_size, ax, y_line_bottom=0):\n\n    # y_unit = -sub(*scaled_y_lim(ax) / -sub(*self.ylim)\n    \n    t = ax.text(x_pos, y_pos, text, fontsize=font_size, \n                horizontalalignment='left',\n                verticalalignment='bottom', \n                rotation=45, zorder=3, \n                bbox=dict(boxstyle='square,pad=0', fc='none', ec='none'))\n    ax.plot((x_pos, x_pos, x_pos+y_unit/40),\n            (y_line_bottom, y_pos, y_pos+y_unit/40), \n            linewidth=0.5, color='darkgray', zorder=2)\n\n\ndef get_polygon(text:str, x_pos:int, y_pos:float, ax:matplotlib.axes.Axes) -&gt; Polygon:\n\n    # y_unit = -sub(*scaled_y_lim(ax) / -sub(*self.ylim)\n\n    y_pos = y_pos * y_unit\n    \n    t = ax.text(x_pos, y_pos, text, fontsize=font_size, \n                horizontalalignment='left',\n                verticalalignment='bottom', \n                rotation=0, zorder=3, \n                # bbox=dict(boxstyle='square,pad=0', \n                bbox=dict(boxstyle='square', \n                          fc='none', ec='none', alpha=0.4))\n    \n    transf = ax.transData.inverted()\n    bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    bbt = bb.transformed(transf)\n    coords = bbt.get_points()\n    \n    Artist.remove(t)\n    \n    (x0, y0), (x1, y1) = coords\n    pad = (y1 - y0)/5\n    coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n        \n    x, y = zip(*coords)\n    df = pd.DataFrame(dict(x=x, y=y))\n    df['y'] -= y_pos\n    df['x'] -= x_pos\n    dfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\n    df['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\n    df['x'] = dfx\n    df['y'] += y_pos\n    df['x'] += x_pos\n        \n    coords = np.array(list(zip(df.x, df.y)))\n    \n    x_pos, y_pos = df['x'][0] - (df['x'][0] - df['x'][1]), df['y'][0]\n\n    df['x'] = df.x + np.array([-pad, -pad, pad, pad])\n    df['y'] = df.y + np.array([-pad, pad, pad, -pad])\n    \n    return x_pos, y_pos, Polygon([Point(x, y) for x, y in zip(df.x, df.y)])\n\n\n\n# annot = [(x, 'AKAP4') for x in range(1, int(max_chrom_size), int(max_chrom_size/100))]\n\nimport random\n_names = random.choices(['AKAP4', 'DYNLT3', 'MAGEA4', 'TP53'], k=100)\n_pos = np.random.randint(1, max_chrom_size, 100).tolist()\nannot = list(zip(_pos, _names))\n#annot = [(x, 'AKAP4') for x in np.random.randint(1, max_chrom_size, 100).tolist()]\n\nannot = sorted(annot, reverse=True)\n\nfor ax in axes:\n    # y_unit = -sub(*scaled_y_lim(ax) / -sub(*self.ylim)\n\n    polybuff = []\n    for pos, name in annot:\n        x, y, poly = get_polygon(name, pos, 0.1, ax)\n\n        while any(is_polygons_intersecting(poly, p) for p in polybuff):\n            nudge = 0.1 * y_unit\n            y += nudge\n            poly.nudge_y(nudge)\n        draw_text(x, y, name, font_size, ax)\n\n        if len(polybuff) &gt; 5:\n            del polybuff[0]\n        polybuff.append(poly)\n\n    z = 10\n    for i, t in enumerate(reversed(ax.texts)):\n        t.set_zorder(z+i)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 12\n     10 max_chrom_size = 1e5\n     11 axes_height = aspect * max_chrom_size\n---&gt; 12 fig_height = axes_height_inches * nr_rows\n     13 fig_width = fig_height / nr_rows / aspect \n     15 # axes_height = 1e4 # relative to length of chrom one\n     16 # max_chrom_size = 1e5\n     17 # aspect = axes_height / max_chrom_size\n     18 # fig_width = 8\n     19 # axes_height_inches = fig_width_inches * aspect\n     20 # fig_height = axes_height_inches * nr_rows\n\nNameError: name 'nr_rows' is not defined\n\n\n\n\nimport pandas as pd\nimport math\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib import patches\nfrom matplotlib.artist import Artist\nfrom operator import sub\nimport random\nimport numpy as np\nfrom collections import defaultdict\n\nclass Point:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n\nclass Polygon:\n    def __init__(self, points):\n        self.points = points\n\n    def get_points(self):\n        return self.points\n\n    def nudge_y(self, nudge):\n        for point in self.points:\n            point.y += nudge\n            \nclass ChromIdeogram(object):\n\n    d = {'axes.linewidth': 0.8, 'grid.linewidth': 0.64, 'lines.linewidth': 0.96, \n         'lines.markersize': 3.84, 'patch.linewidth': 0.64, 'xtick.major.width': 0.8,\n         'ytick.major.width': 0.8, 'xtick.minor.width': 0.64, 'ytick.minor.width': 0.64,\n         'xtick.major.size': 3.84, 'ytick.major.size': 3.84, 'xtick.minor.size': 2.56, \n         'ytick.minor.size': 2.56, 'font.size': 7.68, 'axes.labelsize': 7.68,\n         'axes.titlesize': 7.68, 'xtick.labelsize': 7.04, 'ytick.labelsize': 7.04, \n         'legend.fontsize': 7.04, 'legend.title_fontsize': 7.68}\n    \n    chrom_lengths = {'hg19': {'chr1': 249250621, 'chr2': 243199373, 'chr3': 198022430, 'chr4': 191154276, \n                              'chr5': 180915260, 'chr6': 171115067, 'chr7': 159138663, 'chr8': 146364022, \n                              'chr9': 141213431, 'chr10': 135534747, 'chr11': 135006516, 'chr12': 133851895,\n                              'chr13': 115169878, 'chr14': 107349540, 'chr15': 102531392, 'chr16': 90354753, \n                              'chr17': 81195210, 'chr18': 78077248, 'chr19': 59128983, 'chr20': 63025520, \n                              'chr21': 48129895, 'chr22': 51304566, 'chrX': 155270560, 'chrY': 59373566},\n                     'hg38': {'chr1': 248956422, 'chr2': 242193529, 'chr3': 198295559, 'chr4': 190214555, \n                              'chr5': 181538259, 'chr6': 170805979, 'chr7': 159345973, 'chr8': 145138636, \n                              'chr9': 138394717, 'chr10': 133797422, 'chr11': 135086622, 'chr12': 133275309, \n                              'chr13': 114364328, 'chr14': 107043718, 'chr15': 101991189, 'chr16': 90338345, \n                              'chr17': 83257441, 'chr18': 80373285, 'chr19': 58617616, 'chr20': 64444167, \n                              'chr21': 46709983, 'chr22': 50818468, 'chrX': 156040895, 'chrY': 57227415}}    \n\n    # TODO: make the centromeres fit each assembly!\n    centromeres = {\n        'chr1':    (121700000, 125100000),\n        'chr10':   (38000000, 41600000),\n        'chr11':   (51000000, 55800000),\n        'chr12':   (33200000, 37800000),\n        'chr13':   (16500000, 18900000),\n        'chr14':   (16100000, 18200000),\n        'chr15':   (17500000, 20500000),\n        'chr16':   (35300000, 38400000),\n        'chr17':   (22700000, 27400000),\n        'chr18':   (15400000, 21500000),\n        'chr19':   (24200000, 28100000),\n        'chr2':    (91800000, 96000000),\n        'chr20':   (25700000, 30400000),\n        'chr21':   (10900000, 13000000),\n        'chr22':   (13700000, 17400000),\n        'chr3':    (87800000, 94000000),\n        'chr4':    (48200000, 51800000),\n        'chr5':    (46100000, 51400000),\n        'chr6':    (58500000, 62600000),\n        'chr7':    (58100000, 62100000),\n        'chr8':    (43200000, 47200000),\n        'chr9':    (42200000, 45500000),\n        'chrX':    (58100000, 63800000),\n        'chrY':    (10300000, 10400000)}                     \n\n    \n    def __init__(self, assembly:str='hg38'):\n        # draw chromosomes       \n\n        self.chr_names = [f'chr{x}' for x in list(range(1, 23))+['X', 'Y']]\n        self.chr_sizes = [self.chrom_lengths[assembly][chrom] for chrom in self.chr_names]\n        self.max_chrom_size = max(self.chr_sizes)\n\n        nr_rows = 23\n        hspace = 0\n        axes_height_inches = 1\n        axes_width_inches = 15\n        self.aspect = axes_height_inches / axes_width_inches\n        # axes_width_inches = axes_height_inches / self.aspect\n\n        axes_width = self.max_chrom_size\n        axes_height = self.aspect * self.max_chrom_size\n        fig_height_inches = axes_height_inches * (nr_rows-1) + hspace * (nr_rows-1)\n        fig_width_inches = axes_width_inches #fig_height_inches / (nr_rows-1) / aspect \n        figsize = (fig_width_inches, fig_height_inches)\n        point_size = 1/72\n        \n#        nr_rows = 25\n        self.fig = plt.figure(figsize=figsize)\n        # fig, axes = plt.subplots(nr_rows, 1, figsize=figsize, sharex=True, sharey=True)\n        plt.subplots_adjust(hspace=0)\n        \n        self.ylim = (0, 1)\n\n        rel_font_height = 0.05\n\n        self.font_size = rel_font_height * axes_height_inches / point_size\n\n\n\n        # figwidth = max(chr_sizes)\n        \n        with plt.rc_context(self.d):\n        \n            nr_rows, nr_cols = len(self.chr_names)-2+1, 2\n    \n            # fig = plt.figure(figsize=figsize)\n\n            end_padding = 300000\n            \n            # gs = matplotlib.gridspec.GridSpec(nr_rows, 25)\n            gs = matplotlib.gridspec.GridSpec(nr_rows+1, 25, height_ratios=[1e-2]+[1]*nr_rows)\n            gs.update(wspace=0, hspace=hspace) \n\n            dummy_ax = plt.subplot(gs[0, :])\n            xlim = (-end_padding, self.max_chrom_size+end_padding)\n            dummy_ax.set_xlim(xlim)\n            # dummy_ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n            dummy_ax.spines['top'].set_visible(True)\n            dummy_ax.xaxis.tick_top()\n            dummy_ax.xaxis.set_label_position('top') \n            dummy_ax.yaxis.set_ticks_position('none')\n            dummy_ax.set_yticklabels([])\n        \n            ax_list = [plt.subplot(gs[i, :]) for i in range(1, nr_rows-2)]\n            ax_list.append(plt.subplot(gs[nr_rows-2, :9]))\n            ax_list.append(plt.subplot(gs[nr_rows-1, :9]))\n            ax_list.append(plt.subplot(gs[nr_rows-2, 9:]))\n            ax_list.append(plt.subplot(gs[nr_rows-1, 9:]))\n\n            self.ax_list = ax_list\n            self.chr_axes = dict(zip(self.chr_names, self.ax_list))\n    \n            for ax in self.ax_list[:-4]:\n                xlim = (-end_padding, self.max_chrom_size+end_padding)\n                scaled_y_lim = xlim[0] * self.aspect, xlim[1] * self.aspect\n                ax.set_xlim(xlim)\n                ax.set_ylim(scaled_y_lim)\n            for ax in ax_list[-4:]:\n                xlim = (-end_padding, ((25-9)/25)*self.max_chrom_size+end_padding)\n                scaled_y_lim = xlim[0] * self.aspect, xlim[1] * self.aspect\n                ax.set_xlim(xlim)\n                ax.set_ylim(scaled_y_lim)\n    \n            for i in range(len(self.ax_list)):\n                chrom = self.chr_names[i]\n                ax = ax_list[i]\n                start, end = 0, self.chr_sizes[i]\n                ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n                # ax.spines['top'].set_visible(False)\n                # ax.spines['right'].set_visible(False)\n                # ax.spines['bottom'].set_visible(False)\n                # ax.spines['left'].set_visible(False)\n                # ax.set_ylim((0, 3))\n                # ax.set_ylim((0, 5))\n    \n                if i in [20, 21]:   \n                    x = -3500000 * 10 / figsize[1]\n                else:\n                    x = -2000000 * 10 / figsize[1]\n\n                ax.text(x, self.map_y(-sub(*self.ylim), ax)/2, chrom.replace('chr', ''), fontsize=7, verticalalignment='center', horizontalalignment='right', weight='bold')\n    \n                # h = ax.set_ylabel(chrom)\n                # h.set_rotation(0)\n                ax.set_yticklabels([])\n    \n                # if i == 0:\n                #     ax.spines['top'].set_visible(True)\n                #     ax.xaxis.tick_top()\n                #     ax.xaxis.set_label_position('top') \n                #     ax.yaxis.set_ticks_position('none')\n                # elif i == len(ax_list)-1:\n                if i == len(self.ax_list)-1:\n                    ax.xaxis.tick_bottom()\n                    ax.spines['bottom'].set_visible(True)                    \n                    ax.yaxis.set_ticks_position('none')\n                else:\n                    ax.set_xticklabels([])\n                    ax.xaxis.set_ticks_position('none')\n                    ax.yaxis.set_ticks_position('none')\n                    # ax.spines[['right', 'top', 'left', 'bottom']].set_visible(False)\n\n    def draw_chromosomes(self, base=0.05, height=0.25):\n\n        with plt.rc_context(self.d):\n\n            for i in range(len(self.ax_list)):\n                chrom = self.chr_names[i]\n                ax = self.ax_list[i]\n                start, end = 0, self.chr_sizes[i]                \n\n                ideogram_base = self.map_y(base, ax)\n                ideogram_height = self.map_y(height, ax)\n                \n                # draw chrom\n                g = ax.add_patch(patches.Rectangle((start, ideogram_base), end-start, ideogram_height, \n                                           # fill=False,\n                                           facecolor='#EBEAEA',\n                                           edgecolor='black',\n                                           # edgecolor=None,\n                                           zorder=1, linewidth=0.7\n                                          ))\n                # g = ax.add_patch(patches.Rectangle((start, ideogram_base), end-start, ideogram_height, \n                #                            # fill=False,\n                #                            facecolor='black',\n                #                            edgecolor=None,\n                #                            # zorder=1, \n                #                           ))\n                # g = ax.add_patch(patches.Rectangle((start+self.map_y(0.01, ax), ideogram_base+self.map_y(0.01, ax)), (end-start)-self.map_y(2*0.01, ax), ideogram_height-self.map_y(2*.01, ax), \n                #                            # fill=False,\n                #                            facecolor='#EBEAEA',\n                #                            edgecolor=None,\n                #                            # zorder=1, \n                #                           ))                \n    \n                # draw centromere\n                cent_start, cent_end = self.centromeres[chrom]\n                ax.add_patch(patches.Rectangle((cent_start, ideogram_base-300000), cent_end-cent_start, ideogram_height+300000, \n                                           fill=True, color='white',\n                                           zorder=2))\n                xy = [[cent_start, ideogram_base], [cent_start, ideogram_base+ideogram_height], [cent_end, ideogram_base], [cent_end, ideogram_base+ideogram_height]]\n                g = ax.add_patch(patches.Polygon(xy, closed=True, zorder=3, fill=True,\n                                         # color='#666666',\n                                         color='#777777',\n                                        ))\n\n\n    def is_polygons_intersecting(self, a, b):\n        for x in range(2):\n            polygon = a if x == 0 else b\n    \n            for i1 in range(len(polygon.get_points())):\n                i2 = (i1 + 1) % len(polygon.get_points())\n                p1 = polygon.get_points()[i1]\n                p2 = polygon.get_points()[i2]\n    \n                normal = Point(p2.y - p1.y, p1.x - p2.x)\n    \n                min_a = float('inf')\n                max_a = float('-inf')\n    \n                for p in a.get_points():\n                    projected = normal.x * p.x + normal.y * p.y\n                    min_a = min(min_a, projected)\n                    max_a = max(max_a, projected)\n    \n                min_b = float('inf')\n                max_b = float('-inf')\n    \n                for p in b.get_points():\n                    projected = normal.x * p.x + normal.y * p.y\n                    min_b = min(min_b, projected)\n                    max_b = max(max_b, projected)\n    \n                if max_a &lt; min_b or max_b &lt; min_a:\n                    return False\n    \n        return True\n\n    \n    def scaled_y_lim(self, ax):\n        # xlim = (0, max_chrom_size)\n        xlim = ax.get_xlim()\n        return xlim[0] * self.aspect, xlim[1] * self.aspect\n    \n\n    def map_y(self, y, ax, bottom=0, top=1):\n        miny, maxy = ax.get_ylim()\n\n        return y * (top - bottom) * (maxy - miny) / (self.ylim[1] - self.ylim[0]) + bottom * (maxy - miny)\n        # zero = -miny\n        # if y &gt;= 0:\n        #     return y * (top - max(bottom, zero)) * (maxy - zero) / (self.ylim[1] - self.ylim[0]) + max(bottom, zero) * (maxy - zero)\n        # else:\n        #     return y * (min(top, zero) - bottom) * (zero - miny) / (self.ylim[1] - self.ylim[0]) + min(top, zero) * (zero - miny)\n\n        \n\n    \n    def draw_text(self, x_pos, y_pos, text, ax, color='black', y_line_bottom=0):\n        y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n        \n        t = ax.text(x_pos, y_pos, text, fontsize=self.font_size, \n                    color=color,\n                    horizontalalignment='left',\n                    verticalalignment='bottom', \n                    rotation=45, zorder=3, \n                    bbox=dict(boxstyle='square,pad=0', \n                              fc='none', \n                              # fc=color, alpha=0.4,\n                              ec='none'))\n        ax.plot((x_pos, x_pos, x_pos+y_unit/40),\n                (y_line_bottom, y_pos, y_pos+y_unit/40), \n                linewidth=0.5, \n                # color='darkgray', \n                color=color,\n                alpha=0.3,\n                zorder=2)\n    \n    \n    def get_polygon(self, text:str, x_pos:int, y_pos:float, ax:matplotlib.axes.Axes) -&gt; Polygon:\n    \n        y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n    \n        y_pos = y_pos * y_unit\n        \n        t = ax.text(x_pos, y_pos, text, fontsize=self.font_size,\n                    horizontalalignment='left',\n                    verticalalignment='bottom', \n                    rotation=0, zorder=3, \n                    # bbox=dict(boxstyle='square,pad=0', \n                    bbox=dict(boxstyle='square', \n                              fc='none', ec='none', alpha=0.4))\n        \n        transf = ax.transData.inverted()\n        bb = t.get_window_extent(renderer = self.fig.canvas.get_renderer())\n        bbt = bb.transformed(transf)\n        coords = bbt.get_points()\n        \n        Artist.remove(t)\n        \n        (x0, y0), (x1, y1) = coords\n        pad = (y1 - y0)/5\n        coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n            \n        x, y = zip(*coords)\n        df = pd.DataFrame(dict(x=x, y=y))\n        df['y'] -= y_pos\n        df['x'] -= x_pos\n        dfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\n        df['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\n        df['x'] = dfx\n        df['y'] += y_pos\n        df['x'] += x_pos\n            \n        coords = np.array(list(zip(df.x, df.y)))\n        \n        x_pos, y_pos = df['x'][0] - (df['x'][0] - df['x'][1]), df['y'][0]\n    \n        df['x'] = df.x + np.array([-pad, -pad, pad, pad])\n        df['y'] = df.y + np.array([-pad, pad, pad, -pad])\n        \n        return x_pos, y_pos, Polygon([Point(x, y) for x, y in zip(df.x, df.y)])\n        \n\n    # def add_labels(self, data, labels='name', chrom='chrom', x='pos'):\n    def add_labels(self, annot, y0=0, y1=0.2):\n\n        chrom_annot = defaultdict(list)\n        for a in annot:\n            chrom_annot[a[0]].append(a[1:])\n            \n        for chrom, annot in chrom_annot.items():\n            ax = self.chr_axes[chrom]\n            annot = sorted(annot, reverse=True)\n\n            y_unit = -sub(*self.scaled_y_lim(ax)) / -sub(*self.ylim)\n        \n            polybuff = []\n            for pos, name, *args in annot:\n                x, y, poly = self.get_polygon(name, pos, y1, ax)\n                while any(self.is_polygons_intersecting(poly, p) for p in polybuff):\n                    nudge = 0.01 * y_unit\n                    y += nudge\n                    poly.nudge_y(nudge)\n                self.draw_text(x, y, name, ax, *args, y_line_bottom=y0*y_unit)\n\n                polybuff.append(poly)\n                if len(polybuff) &gt; 10:\n                    del polybuff[0]\n        \n            z = 10\n            for i, t in enumerate(reversed(ax.texts)):\n                t.set_zorder(z+i)\n\n\n    \n    def map(self, fun, data=None, chrom_col='chrom', yaxis=(0, 1), **kwargs):\n        bottom, top = yaxis\n        renames = {}\n        for key, val in list(kwargs.items()):\n            if key in data.columns:\n                renames[key] = val\n                del kwargs[key]\n        df = data.rename(columns=renames)\n\n        \n        grouped = data.groupby(chrom_col)\n        for chrom, group in grouped:\n\n            ax = self.chr_axes[chrom]\n            scaled_y_lim = ax.get_ylim()\n\n            if 'ylim' in kwargs:\n                dy = -sub(*ylim)\n            else:\n                dy = max(y) - min(y)\n            df = group.iloc[:]\n            df['y'] = df.y * ((top-bottom) * scaled_y_lim[1]) / dy + bottom * scaled_y_lim[1]\n\n            df.apply(fun, axis=1, **kwargs)\n\n    def map_dataframe(self, fun, data=None, chrom_col='chrom', yaxis=(0, 1), **kwargs):\n        bottom, top = yaxis\n\n        \n        grouped = data.groupby(chrom_col)\n        for chrom, group in grouped:\n            ax = self.chr_axes[chrom]\n            scaled_y_lim = ax.get_ylim()\n            if 'ylim' in kwargs:\n                dy = -sub(*ylim)\n            else:\n                dy = max(y) - min(y)\n            df = group.iloc[:]\n            df['y'] = df.y * ((top-bottom) * scaled_y_lim[1]) / dy + bottom * scaled_y_lim[1]\n\n            fun(data, **kwargs)\n\nci = ChromIdeogram() # plots chromosome\nci.draw_chromosomes(base=0.05, height=0.15)\n\n# _names = random.choices(['AKAP4', 'DYNLT3', 'MAGEA4', 'TP53'], k=200)\n# _pos = np.random.randint(1, 250000000, 200).tolist()\n# _colors = random.choices(['blue', 'brown', 'green', 'orange'], k=200)\n# annot = list(zip(['chr1']*200, _pos, _names, _colors))\n# ci.add_labels(annot, y0=0.2, y1=0.3)\n\nx = np.linspace(1, 250000000, 10000)\nrng = np.random.default_rng()\ny = rng.exponential(scale=1, size=x.size)\nchrom = ['chr1']*10000\ndf = pd.DataFrame(dict(x=x, y=y, chrom=chrom))\n\n# ci.map(plt.scatter, data=df, x='x', y='y', yaxis=(0.5, 0.7))\nci.map_dataframe(sns.scatterplot, data=df, x='x', y='y', yaxis=(0.5, 0.7))\n\n\n\n\n\n\n\n\n\n# import pandas as pd\n# import math\n# from matplotlib.artist import Artist\n\n\n# axes_height = 1e4 # relative to length of chrom one\n# max_chrom_size = 1e5\n# aspect = axes_height / chrom_size\n\n# fig_width_inches = 8\n# axes_height_inches = fig_width * aspect\n# fig_height = axes_height_inches * nr_rows\n\n# nr_rows = 11\n# fig, axes = plt.subplots(nr_rows, 1, figsize=(fig_width, fig_width*aspect*nr_rows), sharex=True, sharey=True)\n# plt.subplots_adjust(hspace=0)\n# ax = axes[0]\n\n# xlim = (0, max_chrom_size)\n# ylim = (0, 6)\n# scaled_y_lim = xlim[0] * aspect, xlim[1] * aspect\n# ax.set_xlim(xlim)\n# ax.set_ylim(scaled_y_lim)\n# plt.yticks([])\n# y_unit = -sub(*scaled_y_lim) / -sub(*ylim)\n\n# rel_font_height = 0.1\n# font_size = rel_font_height * axes_height_inches / point_size\n\n\n# def draw_text(x_pos, y_pos, text, font_size, rel_font_height, ax, y_line_bottom=0):\n \n#     ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#                 horizontalalignment='left',# weight='bold',\n#                 verticalalignment='bottom', \n#                 rotation=45, zorder=3, \n#                 bbox=dict(boxstyle='square,pad=0', fc='none', ec='none'))\n#     (_, a), (_, b) = ax.transAxes.transform([(0, 0), (0, rel_font_height / 2)])\n#     z = b - a    \n#     z = 300\n#     z = y_unit/6\n\n#     ax.plot((x_pos, x_pos, x_pos+z),\n#             (y_line_bottom, y_pos, y_pos+z), \n#             linewidth=0.5, color='gray')\n\n\n# def get_polygon(text:str, x_pos:int, y_pos:float, font_size:float, ax:matplotlib.axes.Axes) -&gt; Polygon:\n\n#     y_pos = y_pos * y_unit\n#     # x_pos, y_pos = chrom_size/2, 2*y_unit\n    \n#     # ax.scatter([x_pos], [y_pos], marker='X', color='black')\n    \n    \n#     t = ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#                 horizontalalignment='left',# weight='bold',\n#                 verticalalignment='bottom', \n#                 rotation=0, zorder=3, \n#                 bbox=dict(boxstyle='square,pad=0', fc='none', ec='none', alpha=0.4))\n#     # t.set_visible(False)\n    \n#     transf = ax.transData.inverted()\n#     bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n#     bbt = bb.transformed(transf)\n#     coords = bbt.get_points()\n    \n#     Artist.remove(t)\n    \n#     (x0, y0), (x1, y1) = coords\n#     coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n#     # ax.scatter(*coords.T, c='red')\n    \n#     # ax.scatter(*zip(*coords), transform=ax.transAxes, s=1, color='green', zorder=3)\n    \n#     x, y = zip(*coords)\n#     df = pd.DataFrame(dict(x=x, y=y))\n#     df['y'] -= y_pos\n#     df['x'] -= x_pos\n#     dfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\n#     df['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\n#     df['x'] = dfx\n#     df['y'] += y_pos\n#     df['x'] += x_pos\n    \n#     #df['x'] -= df['x'][1] - df['x'][0]\n    \n#     coords = np.array(list(zip(df.x, df.y)))\n    \n#     x_pos, y_pos = df['x'][0] - (df['x'][0] - df['x'][1]), df['y'][0]\n#     # _ = ax.text(x_pos, y_pos, 'Tester', fontsize=font_size, \n#     #             horizontalalignment='left',# weight='bold',\n#     #             verticalalignment='bottom', \n#     #             rotation=45, zorder=3, \n#     #             bbox=dict(boxstyle='square,pad=0', fc='none', ec='none'))\n    \n#     # ax.scatter(*coords.T, c='blue')\n    \n#     # ax.plot(*zip(*coords), linewidth=0.2)\n\n#     return x_pos, y_pos, Polygon([Point(x, y) for x, y in zip(df.x, df.y)])\n\n\n# annot = [(x, 'AKAP4') for x in range(1, int(max_chrom_size), int(max_chrom_size/200))]\n\n# for i, ax in enumerate(axes):\n#     annot = [(x, 'AKAP4') for x in range(1, int(max_chrom_size), int(max_chrom_size/(10*(i+1))))]\n\n#     polybuff = []\n#     for pos, name in annot:\n#         x, y, poly = get_polygon(name, pos, 1, rel_font_height, ax)\n\n#         while any(is_polygons_intersecting(poly, p) for p in polybuff):\n#             nudge = 0.1 * y_unit\n#             y += nudge\n#             poly.nudge_y(nudge)\n#         draw_text(x, y, name, font_size, rel_font_height, ax)\n\n#         if len(polybuff) &gt; 5:\n#             del polybuff[0]\n#         polybuff.append(poly)\n\n\nimport matplotlib.transforms\n\nfrom matplotlib.transforms import Bbox\nfig, ax = plt.subplots()\nplt.xlim(0, 0.5)\nplt.ylim(0, 1)\n\nt = ax.text(0.2, 0.2, 'Text', fontsize=30, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\nprint(coords)\n(x0, y0), (x1, y1) = coords\nplt_coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*plt_coords.T, c='red')\n\n\nfrom operator import sub\naspect_ratio = sub(*ax.get_ylim()) / sub(*ax.get_xlim())\n\n#x0, y0 = coords[0]\n# (x0, y0), (x1, y2) = coords\ntrafo = matplotlib.transforms.Affine2D().rotate_deg_around(x0,y0,45).skew(1, 1.3)#.scale(0.5)\n\ncoords = trafo.transform([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n# coords = trafo.transform([(x0, y0), (x1, y1)])\n# coords = trafo.transform(coords)\nprint(coords)\n\nax.scatter(*coords.T, zorder=10)\n\ndisp_ratio = ax.get_data_ratio()\nbbox = ax.get_window_extent().transformed(fig.dpi_scale_trans.inverted())\ndisp_ratio = bbox.width / bbox.height\nprint(disp_ratio)\n\n\n\n(x0, y0), (x0, y1), (x1, y1), (x1, y0) = coords\ncoords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*coords.T)\n\n\nPolygon([Point(x0, y0), Point(bbt.xmin, b[1]+(b[0]-bbt.xmin)), Point(b[2], b[3]), Point(bbt.xmax, b[3]-(b[0]-bbt.xmin))])\n\n\n#Bbox.count_overlaps\n\n[[0.2        0.2       ]\n [0.27711694 0.30281385]]\n[[0.51148154 0.92042049]\n [0.55200529 0.73124667]\n [0.6914605  0.9821989 ]\n [0.65093675 1.17137271]]\n1.3419913419913418\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib.transforms as transforms\n\nfig, ax = plt.subplots()\n\n# [[0.25574077 0.46021024]\n#  [0.29626452 0.27103643]\n#  [0.43571973 0.52198865]\n#  [0.39519598 0.71116247]]\n\n# [[0.1        0.1       ]\n#  [0.17711694 0.20281385]]\nr1 = patches.Rectangle((0.1, 0.1), 0.2, 0.1, color=\"blue\", alpha=0.5)\nr2 = patches.Rectangle((0.1, 0.1), 0.2, 0.1, color=\"red\", alpha=0.5)\n\n\np = 0.1, 0.1 # rotate around this point\n\nx_lim = (0, 0.5)\ny_lim = (0, 1)\nax.set_xlim(x_lim)\nax.set_ylim(y_lim)\n\nx_range = x_lim[1] - x_lim[0]\ny_range = y_lim[1] - y_lim[0]\naspect_ratio = y_range / x_range\n\nmove_transform = transforms.Affine2D().translate(-p[0], -p[1])\ninverse_move_transform = transforms.Affine2D().translate(p[0], p[1])\ninverse_scale_transform = transforms.Affine2D().scale(1, 1 / aspect_ratio)\nrotate_transform = transforms.Affine2D().rotate_deg(45)\nscale_transform = transforms.Affine2D().scale(1, aspect_ratio)\n\ntotal_transform = move_transform + inverse_scale_transform + rotate_transform + scale_transform + inverse_move_transform + ax.transData\n\nr2.set_transform(total_transform)\n\nax.add_patch(r1)\nax.add_patch(r2)\n\n# print(ax.transLimits.transform([(0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1)]))\n# print(total_transform.transform([(0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1)]))\n# print(r2.get_bbox())\n# x0, y0, width, height = r2.get_bbox().bounds()\n# print(x0, y0)\n# coords = [(x0, y0), \n#           (x0 - sqrt(height**2 / 2), y0 + sqrt(height**2 / 2)), \n#           (x0 - sqrt(height**2 / 2) + sqrt(width**2 / 2), y0 + sqrt(height**2 / 2)) +  + sqrt(width**2 / 2), \n#           (x0 + sqrt(width**2 / 2), y0 + sqrt(width**2 / 2))]\n# plt.scatter(*zip(*coords))\n\n# coords = ((0.1, 0.1), (0.1, 0.2), (0.3, 0.2), (0.3, 0.1))\n# plt.scatter(*zip(*coords))\n# coords = total_transform.transform(coords)\n# print(coords)\n# plt.scatter(*zip(*coords))\n\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nimport matplotlib as mpl\nfrom math import *\n\n#some helper values\np=4\ntheta=pi/6\nx1 = p*cos(theta/2)\ny1 = p*sin(theta/2)\nvertices =[(-x1-p/2,0), (-p/2, y1), (p/2, y1), (x1+p/2, 0), (p/2, -y1), (-p/2, -y1)] \nmidPoint = [3,4]\nendPoint = (-x1-p/2,0)\n\n#set up the plot\nfig = plt.figure()\nax = fig.add_subplot(111)\n\n#function to rotate and translate the standard shape to a new position\ndef plot_polygon(vertices, midPoint, theta, color):\n    polygon = patches.Polygon(vertices, color=color, alpha=0.50) \n    r = mpl.transforms.Affine2D().rotate_around(midPoint[0],midPoint[1], theta)\n    # t = mpl.transforms.Affine2D().translate(midPoint[0],midPoint[1])\n    tra = r + ax.transData\n    # r = mpl.transforms.Affine2D().rotate(theta)\n    # t = mpl.transforms.Affine2D().translate(midPoint[0],midPoint[1])\n    # tra = r + t + ax.transData\n    polygon.set_transform(tra)\n    ax.add_patch(polygon)\n\n    return r.transform(polygon.xy)\n\np = plot_polygon(vertices, endPoint, 0, \"blue\")\n#plot_polygon(vertices, midPoint, theta, \"blue\")\np_ = plot_polygon(vertices, endPoint, theta, \"orange\")\n\n# print(p.get_xy())\n# print(p_.get_xy())\n# print(p.get_transform().transform(p.xy))\n# print(p_.get_transform().transform(p_.xy))\n#The correct answer is: tra.transform(poly.xy)\n\n\nplt.scatter(*zip(*p), color='blue', alpha=0.5)\nplt.scatter(*zip(*p_), color='orange', alpha=0.5)\n\n# plt.xlim(-10, 10)\n# plt.ylim(-10, 10)\n\nplt.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\nchrom_size = 12e5\nylim = (0, 3)\nxlim = (0, chrom_size)\ndata_height = (ylim[1] - ylim[0])\ndata_width = (xlim[1] - xlim[0])\naspect = data_height / data_width\naspect\n# data_width * aspect\n# ylim = ylim * sub(*ylim) / sub(*xlim)\n# chrom_size * sub(*ylim) / sub(*xlim)\n\n2.5e-06\n\n\n\nimport pandas as pd\nimport math\nfrom operator import sub\ncoords = [(0, 0), (0, 1e4), (3e4, 1e4), (3e4, 0)]\n\n\nchrom_size = 12e5\nylim = np.array([0, 3])\nxlim = np.array([0, chrom_size])\nylim = sub()sub(ylim) / sub(xlim) *\n\n# fig, (ax, ax2) = plt.subplots(2, 1, figsize=(10, 1), sharex=True)\nfig, ax = plt.subplots(1, 1, figsize=(10, 1), sharex=True)\nax.set_xlim(-6e5, 6e5)\nax.set_ylim(-6e4, 6e4)\nax.axis('equal')\n\n# t = ax.text(0, 0, 'Text', fontsize=7, horizontalalignment='left',# weight='bold',\n#                          verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none', alpha=0.4))\n# box = t.get_bbox_patch()\n# fig.canvas.draw()\n# ax.axis('equal')\n# ax.set_xlim(-6e5, 6e5)\n# ax.set_ylim(-4e5, 4e5)\n# # coords = ax.transData.inverted().transform(box.get_window_extent())\n# #coords = ax.transAxes.transform(coords)\n\n# # print(coords)\n# # print(ax.transLimits.transform(coords))\n\nt = ax.text(0, 0, 'Text', fontsize=7, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none', alpha=0.4))\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\n\n(x0, y0), (x1, y1) = coords\ncoords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\nax.scatter(*coords.T, c='red')\n\n# ax.scatter(*zip(*coords), transform=ax.transAxes, s=1, color='green', zorder=3)\n\nx, y = zip(*coords)\ndf = pd.DataFrame(dict(x=x, y=y))\ndfx = df['x']*math.cos(math.radians(45))-df['y']*math.sin(math.radians(45))\ndf['y'] = df['x']*math.sin(math.radians(45))+df['y']*math.cos(math.radians(45))\ndf['x'] = dfx\ncoords = np.array(list(zip(df.x, df.y)))\n\nax.scatter(*coords.T, c='blue')\n\nax.plot(*zip(*coords))\n\n# ax.axis('equal')\n# ax.set_xlim(-6e5, 6e5)\n# ax.set_ylim(-4e5, 4e5)\n\nrect = patches.Rectangle((-6e5, -2e4), 12e5, 1e4, color=\"blue\", alpha=0.5)\nax.add_patch(rect) ;\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots()\nplt.xlim(0, 0.5)\nplt.ylim(0, 1)\nt = ax.text(0.2, 0.2, 'Text', fontsize=30, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=0, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\n\n\ntransf = ax.transData.inverted()\nbb = t.get_window_extent(renderer = fig.canvas.get_renderer())\nbbt = bb.transformed(transf)\ncoords = bbt.get_points()\nprint(coords)\n(x0, y0), (x1, y1) = coords\nplt_coords = np.array([(x0, y0), (x0, y1), (x1, y1), (x1, y0)])\n\nax.scatter(*plt_coords.T, c='red')\n\n\n[[0.2        0.2       ]\n [1.97368952 0.30281385]]\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.transforms\n\nfrom matplotlib.transforms import Bbox\nfig, ax = plt.subplots()\n\ndef get_polygon(t):\n\n    transf = ax.transData.inverted()\n    bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    bbt = bb.transformed(transf)\n    coords = bbt.get_points()\n\n    x0, y0 = coords[0]\n    trafo = matplotlib.transforms.Affine2D().rotate_around(x0,y0,-)\n    print(trafo.transform(coords))\n\n# bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    # coords = bb.get_points()\n    # print(coords)\n    # x0, y0 = coords[0]\n    # print(x0, y0)\n    # trafo = matplotlib.transforms.Affine2D().rotate_around(x0,y0,45)\n\n    # coords = bb.get_points()\n    # print(coords)\n    # print(trafo.transform(coords))\n\n    # transf = ax.transData.inverted()\n    # bb = t.get_window_extent(renderer = fig.canvas.get_renderer())\n    # bbt = bb.transformed(transf)\n    # # return bbt\n    # b = bbt.bounds\n    # # print(dir(bbt), bbt.rotated(0.785398).corners())\n\n    # return Polygon([Point(b[0], b[1]), Point(bbt.xmin, b[1]+(b[0]-bbt.xmin)), Point(b[2], b[3]), Point(bbt.xmax, b[3]-(b[0]-bbt.xmin))])\n    # # return Polygon([Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin), Point(bbt.xmin, bbt.ymin)])\n\nt = ax.text(0.1, 0.1, 'Text', fontsize=17, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=45, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\na = get_polygon(t)\n#xs, ys = zip(*[(p.x, p.y) for p in a.get_points()])\n# print(xs, ys)\n\nt = ax.text(0.1, 0.23, 'Text', fontsize=17, horizontalalignment='left',# weight='bold',\n                         verticalalignment='bottom', rotation=45, zorder=3, bbox=dict(boxstyle='square,pad=0', fc='red', ec='none'))\n#ax.plot(xs,ys) \nb = get_polygon(t)\nis_polygons_intersecting(a, b)\n\n#print(Bbox.intersection(a, b))\n\n[[0.1        0.1       ]\n [0.25716788 0.0862437 ]]\n[[0.1        0.23      ]\n [0.25716788 0.2162437 ]]\n\n\n\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\nCell In[391], line 48\n     46 #ax.plot(xs,ys) \n     47 b = get_polygon(t)\n---&gt; 48 is_polygons_intersecting(a, b)\n\nCell In[30], line 17, in is_polygons_intersecting(a, b)\n     14 for x in range(2):\n     15     polygon = a if x == 0 else b\n---&gt; 17     for i1 in range(len(polygon.get_points())):\n     18         i2 = (i1 + 1) % len(polygon.get_points())\n     19         p1 = polygon.get_points()[i1]\n\nAttributeError: 'NoneType' object has no attribute 'get_points'\n\n\n\n\n\n\n\n\n\n\n\nimport importlib\nimport geneinfo\nimportlib.reload(geneinfo)\n\ngi.chrom_ideogram(annotation, figsize=(8, 8))\n\nBbox(x0=72266463.49999999, y0=2.299999999999999, x1=78844788.63027559, y1=4.219218090860526)\nBbox(x0=38185129.999999985, y0=2.299999999999999, x1=43874492.27483292, y1=3.959864294798294)\nBbox(x0=2916660.500000015, y0=2.299999999999999, x1=8677139.803268358, y1=3.9806125984832725)\nBbox(x0=1428450.5, y0=2.299999999999999, x1=8042334.144493267, y1=4.229592242703012)\nBbox(x0=44533249.000000015, y0=2.299999999999999, x1=52320563.613677576, y1=4.571939253505164)\nBbox(x0=6908011.500000015, y0=2.299999999999999, x1=12632932.289050654, y1=3.9702384466407814)\nBbox(x0=53064702.000000015, y0=2.299999999999999, x1=60531989.985718235, y1=4.478571886922758)\nBbox(x0=119654546.99999999, y0=2.299999999999999, x1=127619654.1847661, y1=4.623810012717609)\nBbox(x0=48684013.500000015, y0=2.299999999999999, x1=53626646.976261124, y1=3.7420071061060156)\nBbox(x0=15840368.500000015, y0=2.299999999999999, x1=22169784.03075163, y1=4.146599027963099)\nBbox(x0=16742475.999999985, y0=2.299999999999999, x1=23107450.044969335, y1=4.15697317980559)\nBbox(x0=111713229.99999999, y0=2.299999999999999, x1=118042645.53075166, y1=4.146599027963099)\nBbox(x0=1597062.000000015, y0=2.299999999999999, x1=10059988.383813992, y1=4.769048138512458)\nBbox(x0=40692081.499999985, y0=2.299999999999999, x1=47341523.65871097, y1=4.239966394545505)\nBbox(x0=56565747.500000015, y0=2.299999999999999, x1=64246386.57102446, y1=4.540816797977694)\nBbox(x0=53398438.500000015, y0=2.299999999999999, x1=60225673.229799524, y1=4.29183715375795)\nBbox(x0=14016183.500000015, y0=2.299999999999999, x1=21447912.97150053, y1=4.468197735080267)\nBbox(x0=2784270.0, y0=2.299999999999999, x1=6482355.478641406, y1=3.37891179161889)\nBbox(x0=41161011.999999985, y0=2.299999999999999, x1=47739337.13027556, y1=4.219218090860526)\nBbox(x0=48896799.500000015, y0=2.299999999999999, x1=55510683.1444933, y1=4.2295922427030135)\nBbox(x0=44992983.500000015, y0=2.299999999999999, x1=51784659.71558182, y1=4.281463001915462)\nBbox(x0=53609424.000000015, y0=2.299999999999999, x1=60792243.87197657, y1=4.395578672182843)\nBbox(x0=13699816.000000015, y0=2.299999999999999, x1=20313699.644493297, y1=4.2295922427030135)\nBbox(x0=72646566.50000001, y0=2.299999999999999, x1=79260450.1444933, y1=4.2295922427030135)\nBbox(x0=20061809.999999985, y0=2.299999999999999, x1=27742449.071024433, y1=4.540816797977694)\nBbox(x0=70285815.99999999, y0=2.299999999999999, x1=77575311.41462968, y1=4.426701127710309)\nBbox(x0=40637241.000000015, y0=2.299999999999999, x1=47926736.41462971, y1=4.426701127710309)\nBbox(x0=76429526.00000001, y0=2.299999999999999, x1=84430191.6989838, y1=4.6341841645601)\nBbox(x0=2361155.5, y0=2.299999999999999, x1=9295065.772452638, y1=4.322959609285416)\nBbox(x0=85954370.49999999, y0=2.299999999999999, x1=90968121.0046965, y1=3.7627554097909943)\nBbox(x0=148750640.0, y0=2.299999999999999, x1=154048858.61843812, y1=3.845748624530909)\nBbox(x0=150437800.0, y0=2.299999999999999, x1=158331790.1563307, y1=4.60306170903263)\nBbox(x0=13667538.000000015, y0=2.299999999999999, x1=21597086.670548394, y1=4.613435860875121)\nBbox(x0=129754242.50000001, y0=2.299999999999999, x1=138430519.9691202, y1=4.831293049567396)\nBbox(x0=13723439.500000015, y0=2.299999999999999, x1=22399716.96912022, y1=4.831293049567396)\nBbox(x0=11766965.500000015, y0=2.299999999999999, x1=17242976.68952672, y1=3.897619383743354)\nBbox(x0=20133181.500000015, y0=2.299999999999999, x1=27031533.258234933, y1=4.312585457442928)\nBbox(x0=66215769.000000015, y0=2.299999999999999, x1=72082923.8459215, y1=4.011735054010739)\nBbox(x0=311072.0, y0=2.299999999999999, x1=7885035.528371349, y1=4.509694342450224)\nBbox(x0=154553122.5, y0=2.299999999999999, x1=160704745.4596631, y1=4.094728268750654)\nBbox(x0=16815475.499999985, y0=2.299999999999999, x1=23464917.658711, y1=4.239966394545505)\nBbox(x0=2716248.0, y0=2.299999999999999, x1=8156700.6753089875, y1=3.887245231900865)\nBbox(x0=30568287.499999985, y0=2.299999999999999, x1=35795389.09000276, y1=3.8250003208459304)\nBbox(x0=3327608.5, y0=2.299999999999999, x1=10190401.744017228, y1=4.302211305600441)\nBbox(x0=71099693.00000001, y0=2.299999999999999, x1=77855810.70136411, y1=4.271088850072971)\nBbox(x0=7475797.500000015, y0=2.299999999999999, x1=11920611.77721323, y1=3.5967689803111647)\nBbox(x0=103357475.49999999, y0=2.299999999999999, x1=110753646.4572828, y1=4.457823583237779)\nBbox(x0=47202994.499999985, y0=2.299999999999999, x1=52750122.7179621, y1=3.918367687428333)\nBbox(x0=115172356.00000001, y0=2.299999999999999, x1=121786239.6444933, y1=4.2295922427030135)\nBbox(x0=41348910.000000015, y0=2.299999999999999, x1=47998352.158711, y1=4.239966394545505)\nBbox(x0=2855820.0, y0=2.299999999999999, x1=8616299.303268328, y1=3.9806125984832725)\nBbox(x0=18297000.500000015, y0=2.299999999999999, x1=24910884.144493297, y1=4.2295922427030135)\nBbox(x0=15810425.000000015, y0=2.299999999999999, x1=22388750.130275592, y1=4.219218090860526)\nBbox(x0=2493695.0, y0=2.299999999999999, x1=8965344.587622449, y1=4.188095635333056)\nBbox(x0=74007178.49999999, y0=2.299999999999999, x1=78309758.72034238, y1=3.5552723729412072)\nBbox(x0=136179030.5, y0=2.299999999999999, x1=141477249.11843812, y1=3.845748624530909)\nBbox(x0=81157805.99999999, y0=2.299999999999999, x1=88269508.84354116, y1=4.374830368497864)\nBbox(x0=140783972.0, y0=2.299999999999999, x1=146473334.2748329, y1=3.959864294798294)\nBbox(x0=53273589.000000015, y0=2.299999999999999, x1=60456408.8719766, y1=4.395578672182843)\nBbox(x0=47223928.500000015, y0=2.299999999999999, x1=53695578.08762245, y1=4.188095635333056)\nBbox(x0=72036297.50000001, y0=2.299999999999999, x1=78543505.60184015, y1=4.198469787175547)\nBbox(x0=16854822.500000015, y0=2.299999999999999, x1=23397589.116057888, y1=4.208843939018035)\nBbox(x0=73836686.00000001, y0=2.299999999999999, x1=78743760.96204342, y1=3.731632954263528)\nBbox(x0=24066878.000000015, y0=2.299999999999999, x1=30751878.672928706, y1=4.250340546387992)\nBbox(x0=1389132.5, y0=2.299999999999999, x1=9567590.770072356, y1=4.686054923772543)\nBbox(x0=17555597.000000015, y0=2.299999999999999, x1=22320437.9051726, y1=3.6901363468935706)\nBbox(x0=24182714.000000015, y0=2.299999999999999, x1=28591969.762995526, y1=3.586394828468677)\nBbox(x0=138918752.0, y0=2.299999999999999, x1=145248167.53075165, y1=4.146599027963099)\nBbox(x0=68835590.50000001, y0=2.299999999999999, x1=75342798.60184018, y1=4.198469787175547)\nBbox(x0=78954529.50000001, y0=2.299999999999999, x1=86208466.40041198, y1=4.416326975867822)\nBbox(x0=1499883.000000015, y0=2.299999999999999, x1=7864857.044969365, y1=4.156973179805588)\nBbox(x0=1359652.5, y0=2.299999999999999, x1=7155690.317486033, y1=3.9909867503257583)\nBbox(x0=3658994.5, y0=2.299999999999999, x1=9348356.774832949, y1=3.959864294798294)\nBbox(x0=153932152.5, y0=2.299999999999999, x1=160403802.08762246, y1=4.188095635333056)\nBbox(x0=71105338.50000001, y0=2.299999999999999, x1=78394833.91462971, y1=4.426701127710309)\nBbox(x0=77903407.99999999, y0=2.299999999999999, x1=84659525.70136409, y1=4.271088850072971)\nBbox(x0=7912993.000000015, y0=2.299999999999999, x1=15344722.47150053, y1=4.468197735080267)\nBbox(x0=48514886.500000015, y0=2.299999999999999, x1=55591030.829323485, y1=4.364456216655377)\nBbox(x0=153959687.5, y0=2.299999999999999, x1=160680246.68714643, y1=4.260714698230483)\nBbox(x0=79160003.00000001, y0=2.299999999999999, x1=86627290.9857182, y1=4.478571886922758)\nBbox(x0=289839.0000000149, y0=2.299999999999999, x1=7792685.49993594, y1=4.488946038765246)\nBbox(x0=132049622.49999999, y0=2.299999999999999, x1=138272362.4880985, y1=4.115476572435632)\nBbox(x0=13756349.000000015, y0=2.299999999999999, x1=19339035.732179835, y1=3.928741839270824)\nBbox(x0=360444.0000000149, y0=2.299999999999999, x1=8823370.383814022, y1=4.769048138512458)\nBbox(x0=53200849.500000015, y0=2.299999999999999, x1=60063642.74401723, y1=4.302211305600441)\nBbox(x0=15738620.500000015, y0=2.299999999999999, x1=21285748.71796213, y1=3.918367687428333)"
  },
  {
    "objectID": "pages/getting_started.html",
    "href": "pages/getting_started.html",
    "title": "Overview",
    "section": "",
    "text": "geneinfo is a compilation of gene information APIs adapted for use in a Jupyter notebook and some additional utilities. Its API lets you retrieve of information about genes and gene ontologies, plot data together with gene structures (genome browser style), show data on chromosome ideograms, perform gene ontology enrichment analyses and more.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/getting_started.html#installation",
    "href": "pages/getting_started.html#installation",
    "title": "Overview",
    "section": "Installation",
    "text": "Installation\nconda install -c conda-forge -c munch-group geneinfo",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/getting_started.html#interpreting-data-in-a-gene-context",
    "href": "pages/getting_started.html#interpreting-data-in-a-gene-context",
    "title": "Overview",
    "section": "Interpreting data in a gene context",
    "text": "Interpreting data in a gene context\nAmong many other things, geneinfo lets you plot data in chromosome coordinates and view overlapping gene annotation using gene_plot.\n\nimport geneinfo as gi\nax = gi.gene_plot('chrX', 76500000, 77500000, assembly='hg19')\nax.scatter(x, y, s=2, c='tab:blue') ;\n\n\n\n\n\n\n\n\nYou can get brief summaries using gene_info.\n\ngi.gene_info(['ATRX', 'MAGT1'])\n\nSymbol: ATRX (protein-coding)         Aliases: JMS, MRX52, RAD54, RAD54L, XH2, XNP, ZNF-HX\nATRX chromatin remodeler\nSummary: The protein encoded by this gene contains an ATPase/helicase domain, and thus it belongs to the SWI/SNF family of chromatin remodeling proteins. This protein is found to undergo cell cycle-dependent phosphorylation, which regulates its nuclear matrix and chromatin association, and suggests its involvement in the gene regulation at interphase and chromosomal segregation in mitosis. Mutations in this gene are associated with X-linked syndromes exhibiting cognitive disabilities as well as alpha-thalassemia (ATRX) syndrome. These mutations have been shown to cause diverse changes in the pattern of DNA methylation, which may provide a link between chromatin remodeling, DNA methylation, and gene expression in developmental processes. Multiple alternatively spliced transcript variants encoding distinct isoforms have been reported. [provided by RefSeq, Jul 2017].\nGenomic position: X:77504880-77786233 (hg38), HG1426_PATCH:76765832-77047170, X:76760356-77041702 (hg19)\nGene card\n\n\n\nSymbol: MAGT1 (protein-coding)         Aliases: CDG1CC, IAP, MRX95, OST3B, PRO0756, SLC58A1, XMEN, bA217H1.1\nmagnesium transporter 1\nSummary: This gene encodes a ubiquitously expressed magnesium cation transporter protein that localizes to the cell membrane. This protein also associates with N-oligosaccharyl transferase and therefore may have a role in N-glycosylation. Mutations in this gene cause a form of X-linked intellectual disability (XLID). This gene may have multiple in-frame translation initiation sites, one of which would encode a shorter protein with an N-terminus containing a signal peptide at amino acids 1-29. [provided by RefSeq, Jul 2017].\nGenomic position: X:77825747-77899271 (hg38), HG1426_PATCH:77087318-77156547, X:77081861-77151090 (hg19)\nGene card\n\n\n\nGet gene ontology terms associated with genes.\n\ngo_terms = gi.get_go_terms_for_genes(['ATRX', 'MAGT1'], evidence=['IDA', 'EXP', 'HTP'])\ngo_terms[:10]\n\n823       546\n5032    84061\nName: GeneID, dtype: int64\n\n\n['GO:0003682',\n 'GO:0005654',\n 'GO:0005783',\n 'GO:0006334',\n 'GO:0006338',\n 'GO:0008250',\n 'GO:0015616',\n 'GO:0016604',\n 'GO:0035064',\n 'GO:0042393']\n\n\nShow graph for those terms.\n\ngi.show_go_dag_for_terms(go_terms)\n\n\n\n\n\n\n\n\nShow definitions of those terms.\n\ngi.go_info(go_terms)\n\nGO:0003682: chromatin binding\nBinding to chromatin, the network of fibers of DNA, protein, and sometimes RNA, that make up the chromosomes of the eukaryotic nucleus during interphase.\n\n\n\nGO:0005654: nucleoplasm\nThat part of the nuclear content other than the chromosomes or the nucleolus.\n\n\n\nGO:0005783: endoplasmic reticulum\nThe irregular network of unit membranes, visible only by electron microscopy, that occurs in the cytoplasm of many eukaryotic cells. The membranes form a complex meshwork of tubular channels, which are often expanded into slitlike cavities called cisternae. The ER takes two forms, rough (or granular), with ribosomes adhering to the outer surface, and smooth (with no ribosomes attached).\n\n\n\nGO:0006334: nucleosome assembly\nThe aggregation, arrangement and bonding together of a nucleosome, the beadlike structural units of eukaryotic chromatin composed of histones and DNA.\n\n\n\nGO:0006338: chromatin remodeling\nA dynamic process of chromatin reorganization resulting in changes to chromatin structure. These changes allow DNA metabolic processes such as transcriptional regulation, DNA recombination, DNA repair, and DNA replication.\n\n\n\nGO:0008250: oligosaccharyltransferase complex\nA protein complex that is found in the endoplasmic reticulum membrane of eukaryotes and transfers lipid-linked oligosaccharide precursor to asparagine residues on nascent proteins. The complex includes at least eight non-identical subunits. Different forms of the complex containing distinct subunits have been detected in mammals.\n\n\n\nGO:0015616: DNA translocase activity\nGeneration of movement along a single- or double-stranded DNA molecule, driven by ATP hydrolysis.\n\n\n\nGO:0016604: nuclear body\nExtra-nucleolar nuclear domains usually visualized by confocal microscopy and fluorescent antibodies to specific proteins.\n\n\n\nGO:0035064: methylated histone binding\nBinding to a histone in which a residue has been modified by methylation.\n\n\n\nGO:0042393: histone binding\nBinding to a histone, any of a group of water-soluble proteins found in association with the DNA of eukaryotic or archaeal chromosomes. They are involved in the condensation and coiling of chromosomes during cell division and have also been implicated in gene regulation and DNA replication. They may be chemically modified (methylated, acetlyated and others) to regulate gene transcription.\n\n\n\nGO:0099115: chromosome, subtelomeric region\nA region of the chromosome, adjacent to the telomere (on the centromeric side) that contains repetitive DNA and sometimes genes. This region is usually heterochromatin.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "pages/caching.html",
    "href": "pages/caching.html",
    "title": "Caching",
    "section": "",
    "text": "geneinfo will cash information queries to make the notebooks run rast on subsequent executions. To clear that cache use:\n\nfrom geneinfo import utils\n\nutils.clear_cache()\n\nCache gene coordinates for gene lists in spreadsheet:\n\n# for label in lists:\n#     names = lists.get(label)\n#     if not names or len(names) &gt; 3000:\n#         names = names[:3000]\n#     gi.gene_coord(names, assembly='hg38', pos_list=True)"
  },
  {
    "objectID": "pages/gene_ids.html",
    "href": "pages/gene_ids.html",
    "title": "ID conversion",
    "section": "",
    "text": "import geneinfo as gi\ngi.email('your@email.com')",
    "crumbs": [
      "Gene information",
      "ID conversion"
    ]
  },
  {
    "objectID": "pages/gene_ids.html#conversion-from-ensembl-ids",
    "href": "pages/gene_ids.html#conversion-from-ensembl-ids",
    "title": "ID conversion",
    "section": "Conversion from ENSEMBL IDs:",
    "text": "Conversion from ENSEMBL IDs:\n\ngi.ensembl2ncbi('ENSG00000128573')\n\n93986\n\n\n\ngi.ensembl2symbol('ENSG00000128573')\n\n'FOXP2'",
    "crumbs": [
      "Gene information",
      "ID conversion"
    ]
  },
  {
    "objectID": "pages/gene_ids.html#conversion-to-ensembl-ids",
    "href": "pages/gene_ids.html#conversion-to-ensembl-ids",
    "title": "ID conversion",
    "section": "Conversion to ENSEMBL IDs:",
    "text": "Conversion to ENSEMBL IDs:\n\ngi.ensembl_id('FOXP2')\n\n['ENSG00000128573']\n\n\n\ngi.ensembl_id(['FOXP2', '93986'])\n\n['ENSG00000128573', 'ENSG00000128573']",
    "crumbs": [
      "Gene information",
      "ID conversion"
    ]
  },
  {
    "objectID": "pages/gene_ids.html#conversion-to-hgcn-gene-symbols",
    "href": "pages/gene_ids.html#conversion-to-hgcn-gene-symbols",
    "title": "ID conversion",
    "section": "Conversion to HGCN gene symbols",
    "text": "Conversion to HGCN gene symbols\n\ngi.hgcn_symbol(['CXorf23', 'BCLAF3', 'ENSG00000173681'])\n\n['BCLAF3', 'BCLAF3', 'BCLAF3']",
    "crumbs": [
      "Gene information",
      "ID conversion"
    ]
  },
  {
    "objectID": "api/gene_coord.html",
    "href": "api/gene_coord.html",
    "title": "gene_coord",
    "section": "",
    "text": "geneinfo.information.gene_coord(\n    query\n    assembly\n    species='homo_sapiens'\n    pos_list=False\n)\nRetrieves genome coordinates one or more genes.\n\n\n\nquery : Union[str, List[str]]\n\nGene symbol or list of gene symbols\n\nassembly : \n\nGenome assembly.\n\nspecies :  = 'homo_sapiens'\n\nSpecies, by default ‘homo_sapiens’.\n\npos_list :  = False\n\nWether to instead return a list of (chrom, position, name) tuples.\n\n\n\n\n\n\n : dict\n\nDictionary with gene names as keys and (chrom, start, end, strand) tuples as values, or a list of (chrom, position, name) tuples.",
    "crumbs": [
      "Gene coordinates",
      "gene_coord"
    ]
  },
  {
    "objectID": "api/gene_coord.html#parameters",
    "href": "api/gene_coord.html#parameters",
    "title": "gene_coord",
    "section": "",
    "text": "query : Union[str, List[str]]\n\nGene symbol or list of gene symbols\n\nassembly : \n\nGenome assembly.\n\nspecies :  = 'homo_sapiens'\n\nSpecies, by default ‘homo_sapiens’.\n\npos_list :  = False\n\nWether to instead return a list of (chrom, position, name) tuples.",
    "crumbs": [
      "Gene coordinates",
      "gene_coord"
    ]
  },
  {
    "objectID": "api/gene_coord.html#returns",
    "href": "api/gene_coord.html#returns",
    "title": "gene_coord",
    "section": "",
    "text": ": dict\n\nDictionary with gene names as keys and (chrom, start, end, strand) tuples as values, or a list of (chrom, position, name) tuples.",
    "crumbs": [
      "Gene coordinates",
      "gene_coord"
    ]
  },
  {
    "objectID": "api/ensembl_id.html",
    "href": "api/ensembl_id.html",
    "title": "ensembl_id",
    "section": "",
    "text": "geneinfo.information.ensembl_id(name, species='homo_sapiens')\nGet ENSEMBL ID for some gene identifier\n\n\n\nname : Union[str, list]\n\nGene identifier\n\nspecies : optional = 'homo_sapiens'\n\nSpecies, by default ‘homo_sapiens’\n\n\n\n\n\n\n : str\n\nENSEMBL ID\n\n\n\n\n\n\n: [](~geneinfo.NotFound)\n\nRaises exception if no ENSEMBL ID can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl_id"
    ]
  },
  {
    "objectID": "api/ensembl_id.html#parameters",
    "href": "api/ensembl_id.html#parameters",
    "title": "ensembl_id",
    "section": "",
    "text": "name : Union[str, list]\n\nGene identifier\n\nspecies : optional = 'homo_sapiens'\n\nSpecies, by default ‘homo_sapiens’",
    "crumbs": [
      "ID conversion",
      "ensembl_id"
    ]
  },
  {
    "objectID": "api/ensembl_id.html#returns",
    "href": "api/ensembl_id.html#returns",
    "title": "ensembl_id",
    "section": "",
    "text": ": str\n\nENSEMBL ID",
    "crumbs": [
      "ID conversion",
      "ensembl_id"
    ]
  },
  {
    "objectID": "api/ensembl_id.html#raises",
    "href": "api/ensembl_id.html#raises",
    "title": "ensembl_id",
    "section": "",
    "text": ": [](~geneinfo.NotFound)\n\nRaises exception if no ENSEMBL ID can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl_id"
    ]
  },
  {
    "objectID": "api/show_go_dag_for_terms.html",
    "href": "api/show_go_dag_for_terms.html",
    "title": "show_go_dag_for_terms",
    "section": "",
    "text": "geneinfo.ontology.show_go_dag_for_terms(terms, add_relationships=True)\nDisplay GO graph for a list of GO terms.\n\n\n\nterms : Union[list, pd.Series]\n\nGo terms\n\nadd_relationships : bool = True\n\nAdd edges representing relationships between GO terms, by default True",
    "crumbs": [
      "GO graphs",
      "show_go_dag_for_terms"
    ]
  },
  {
    "objectID": "api/show_go_dag_for_terms.html#parameters",
    "href": "api/show_go_dag_for_terms.html#parameters",
    "title": "show_go_dag_for_terms",
    "section": "",
    "text": "terms : Union[list, pd.Series]\n\nGo terms\n\nadd_relationships : bool = True\n\nAdd edges representing relationships between GO terms, by default True",
    "crumbs": [
      "GO graphs",
      "show_go_dag_for_terms"
    ]
  },
  {
    "objectID": "api/email.html",
    "href": "api/email.html",
    "title": "email",
    "section": "",
    "text": "geneinfo.ontology.email(email_address)\nRegisters your email address for Entrez queries. Thay way, NCBI will contect you before closeing your connection if you are making too many queries.\n\n\n\nemail_address : str\n\nyour email address",
    "crumbs": [
      "GO graphs",
      "email"
    ]
  },
  {
    "objectID": "api/email.html#parameters",
    "href": "api/email.html#parameters",
    "title": "email",
    "section": "",
    "text": "email_address : str\n\nyour email address",
    "crumbs": [
      "GO graphs",
      "email"
    ]
  },
  {
    "objectID": "api/ensembl2symbol.html",
    "href": "api/ensembl2symbol.html",
    "title": "ensembl2symbol",
    "section": "",
    "text": "geneinfo.information.ensembl2symbol(ensembl_id)\nConverts ENSEMBL ID to gene HGCN gene symbol\n\n\n\nensembl_id : str\n\nENSEMBL ID\n\n\n\n\n\n\n : str\n\nHGCN gene symbol\n\n\n\n\n\n\n: [](~geneinfo.NotFound)\n\nRaises exception if no HGCN gene symbol can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl2symbol"
    ]
  },
  {
    "objectID": "api/ensembl2symbol.html#parameters",
    "href": "api/ensembl2symbol.html#parameters",
    "title": "ensembl2symbol",
    "section": "",
    "text": "ensembl_id : str\n\nENSEMBL ID",
    "crumbs": [
      "ID conversion",
      "ensembl2symbol"
    ]
  },
  {
    "objectID": "api/ensembl2symbol.html#returns",
    "href": "api/ensembl2symbol.html#returns",
    "title": "ensembl2symbol",
    "section": "",
    "text": ": str\n\nHGCN gene symbol",
    "crumbs": [
      "ID conversion",
      "ensembl2symbol"
    ]
  },
  {
    "objectID": "api/ensembl2symbol.html#raises",
    "href": "api/ensembl2symbol.html#raises",
    "title": "ensembl2symbol",
    "section": "",
    "text": ": [](~geneinfo.NotFound)\n\nRaises exception if no HGCN gene symbol can be found.",
    "crumbs": [
      "ID conversion",
      "ensembl2symbol"
    ]
  },
  {
    "objectID": "api/symbols_protein_coding.html",
    "href": "api/symbols_protein_coding.html",
    "title": "symbols_protein_coding",
    "section": "",
    "text": "geneinfo.ontology.symbols_protein_coding(taxid=9606)\nList of protein coding gene symbols for a given taxonomy id.\n\n\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)\n\n\n\n\n\n\n : list\n\nList of gene symbols.",
    "crumbs": [
      "GO enrichment",
      "symbols_protein_coding"
    ]
  },
  {
    "objectID": "api/symbols_protein_coding.html#parameters",
    "href": "api/symbols_protein_coding.html#parameters",
    "title": "symbols_protein_coding",
    "section": "",
    "text": "taxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)",
    "crumbs": [
      "GO enrichment",
      "symbols_protein_coding"
    ]
  },
  {
    "objectID": "api/symbols_protein_coding.html#returns",
    "href": "api/symbols_protein_coding.html#returns",
    "title": "symbols_protein_coding",
    "section": "",
    "text": ": list\n\nList of gene symbols.",
    "crumbs": [
      "GO enrichment",
      "symbols_protein_coding"
    ]
  },
  {
    "objectID": "api/go_enrichment.html",
    "href": "api/go_enrichment.html",
    "title": "go_enrichment",
    "section": "",
    "text": "geneinfo.ontology.go_enrichment(\n    gene_list\n    taxid=9606\n    background_chrom=None\n    background_genes=None\n    terms=None\n    list_study_genes=False\n    alpha=0.05\n)\nRuns a GO enrichment analysis.\n\n\n\ngene_list : list\n\nList of gene symbols or NCBI gene ids.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, 9606 (human) or 1758 (mouse), by default 9606.\n\nbackground_chrom : str = None\n\nName of chromosome, by default None. Limits analysis to this named chromosome\n\nbackground_genes : list = None\n\nList of genes for use as background in GO enrichment analysis, by default None\n\nterms : list = None\n\nList of GO terms for use as background in GO enrichment analysis, by default None\n\nlist_study_genes : list = False\n\nWhether to include lists of genes responsible for enrichment for each identified GO term, by default False\n\nalpha : float = 0.05\n\nFalse discovery significance cut-off, by default 0.05\n\n\n\n\n\n\n : pd.DataFrame\n\npd.DataFrame with columns: - namespace: (BP, MF, CC) - term_id: GO term - e/p: enrichment or depletion - pval_uncorr: uncorrected p-value - p_fdr_bh: Benjamini-Hochberg corrected p-value - ratio: ratio of study genes in GO term - bg_ratio: ratio of background genes in GO term - obj: GOEnrichmentRecord object\n\n\n\n\n\ngene_list = ['TP53', 'BRCA1', 'BRCA2', 'EGFR', 'KRAS', 'PTEN', 'CDH1', 'ATM', 'CHEK2', 'PALB2']\nresults = go_enrichment(gene_list, taxid=9606, alpha=0.05)\nshow_go_dag_enrichment_results(results.obj)",
    "crumbs": [
      "GO enrichment",
      "go_enrichment"
    ]
  },
  {
    "objectID": "api/go_enrichment.html#parameters",
    "href": "api/go_enrichment.html#parameters",
    "title": "go_enrichment",
    "section": "",
    "text": "gene_list : list\n\nList of gene symbols or NCBI gene ids.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, 9606 (human) or 1758 (mouse), by default 9606.\n\nbackground_chrom : str = None\n\nName of chromosome, by default None. Limits analysis to this named chromosome\n\nbackground_genes : list = None\n\nList of genes for use as background in GO enrichment analysis, by default None\n\nterms : list = None\n\nList of GO terms for use as background in GO enrichment analysis, by default None\n\nlist_study_genes : list = False\n\nWhether to include lists of genes responsible for enrichment for each identified GO term, by default False\n\nalpha : float = 0.05\n\nFalse discovery significance cut-off, by default 0.05",
    "crumbs": [
      "GO enrichment",
      "go_enrichment"
    ]
  },
  {
    "objectID": "api/go_enrichment.html#returns",
    "href": "api/go_enrichment.html#returns",
    "title": "go_enrichment",
    "section": "",
    "text": ": pd.DataFrame\n\npd.DataFrame with columns: - namespace: (BP, MF, CC) - term_id: GO term - e/p: enrichment or depletion - pval_uncorr: uncorrected p-value - p_fdr_bh: Benjamini-Hochberg corrected p-value - ratio: ratio of study genes in GO term - bg_ratio: ratio of background genes in GO term - obj: GOEnrichmentRecord object",
    "crumbs": [
      "GO enrichment",
      "go_enrichment"
    ]
  },
  {
    "objectID": "api/go_enrichment.html#examples",
    "href": "api/go_enrichment.html#examples",
    "title": "go_enrichment",
    "section": "",
    "text": "gene_list = ['TP53', 'BRCA1', 'BRCA2', 'EGFR', 'KRAS', 'PTEN', 'CDH1', 'ATM', 'CHEK2', 'PALB2']\nresults = go_enrichment(gene_list, taxid=9606, alpha=0.05)\nshow_go_dag_enrichment_results(results.obj)",
    "crumbs": [
      "GO enrichment",
      "go_enrichment"
    ]
  },
  {
    "objectID": "api/ChromIdeogram.html",
    "href": "api/ChromIdeogram.html",
    "title": "ChromIdeogram",
    "section": "",
    "text": "geneinfo.plot.ChromIdeogram(\n    self\n    chrom\n    axes_height_inches=2\n    axes_width_inches=12\n    hspace=0.3\n    ylim=(0, 10)\n    zooms=[]\n    wspace=0.1\n    rel_font_height=0.05\n    assembly='hg38'\n)\nChild class of GenomeIdeogram for plotting single chromosome ideograms.\n\n\n\n\n\nName\nDescription\n\n\n\n\nzoom_effect\nax1 : the main Axes\n\n\n\n\n\ngeneinfo.plot.ChromIdeogram.zoom_effect(ax1, ax2, **kwargs)\nax1 : the main Axes ax1 : the zoomed Axes\nSimilar to zoom_effect01. The xmin & xmax will be taken from the ax1.viewLim.",
    "crumbs": [
      "Gene plots",
      "ChromIdeogram"
    ]
  },
  {
    "objectID": "api/ChromIdeogram.html#methods",
    "href": "api/ChromIdeogram.html#methods",
    "title": "ChromIdeogram",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\nzoom_effect\nax1 : the main Axes\n\n\n\n\n\ngeneinfo.plot.ChromIdeogram.zoom_effect(ax1, ax2, **kwargs)\nax1 : the main Axes ax1 : the zoomed Axes\nSimilar to zoom_effect01. The xmin & xmax will be taken from the ax1.viewLim.",
    "crumbs": [
      "Gene plots",
      "ChromIdeogram"
    ]
  },
  {
    "objectID": "api/horizon.html",
    "href": "api/horizon.html",
    "title": "horizon",
    "section": "",
    "text": "horizon\ngeneinfo.utils.horizon(\n    df\n    y=None\n    ax=None\n    cut=None\n    quantile_span=None\n    x='start'\n    beginzero=True\n    offset=0\n    height=None\n    colors=['#CCE2DF', '#59A9A8', '#374E9B', 'midnightblue', '#F2DE9A', '#DA8630', '#972428', 'darkred', '#D3D3D3']\n    **kwargs\n)\nHorizon bar plot made allowing multiple chromosomes and multiple samples.",
    "crumbs": [
      "Utilities",
      "horizon"
    ]
  },
  {
    "objectID": "api/get_terms_for_go_regex.html",
    "href": "api/get_terms_for_go_regex.html",
    "title": "get_terms_for_go_regex",
    "section": "",
    "text": "geneinfo.ontology.get_terms_for_go_regex(regex, taxid=9606, add_children=False)\nGet GO terms for terms matching a regular expression in their description string.\n\n\n\nregex : str\n\nRegular expression to match GO term descriptions.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)\n\nadd_children : bool = False\n\nAdd GO terms nested under GO terms found, by default False\n\n\n\n\n\n\n : list\n\nList of GO terms.",
    "crumbs": [
      "GO information",
      "get_terms_for_go_regex"
    ]
  },
  {
    "objectID": "api/get_terms_for_go_regex.html#parameters",
    "href": "api/get_terms_for_go_regex.html#parameters",
    "title": "get_terms_for_go_regex",
    "section": "",
    "text": "regex : str\n\nRegular expression to match GO term descriptions.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)\n\nadd_children : bool = False\n\nAdd GO terms nested under GO terms found, by default False",
    "crumbs": [
      "GO information",
      "get_terms_for_go_regex"
    ]
  },
  {
    "objectID": "api/get_terms_for_go_regex.html#returns",
    "href": "api/get_terms_for_go_regex.html#returns",
    "title": "get_terms_for_go_regex",
    "section": "",
    "text": ": list\n\nList of GO terms.",
    "crumbs": [
      "GO information",
      "get_terms_for_go_regex"
    ]
  },
  {
    "objectID": "api/show_go_dag_enrichment_results.html",
    "href": "api/show_go_dag_enrichment_results.html",
    "title": "show_go_dag_enrichment_results",
    "section": "",
    "text": "geneinfo.ontology.show_go_dag_enrichment_results(results)\nDisplays a GO enrichment analysis results.\n\n\n\nresults : Union[List[GOEnrichmentRecord], pd.Series]\n\nList or Series of GO result objejcts from obj column in the pd.DataFrame returned by go_enrichment().\n\n\n\n\n\ngene_list = ['TP53', 'BRCA1', 'BRCA2', 'EGFR', 'KRAS', 'PTEN', 'CDH1', 'ATM', 'CHEK2', 'PALB2']\nresults = go_enrichment(gene_list, taxid=9606, alpha=0.05)\nshow_go_dag_enrichment_results(results.obj)",
    "crumbs": [
      "GO graphs",
      "show_go_dag_enrichment_results"
    ]
  },
  {
    "objectID": "api/show_go_dag_enrichment_results.html#parameters",
    "href": "api/show_go_dag_enrichment_results.html#parameters",
    "title": "show_go_dag_enrichment_results",
    "section": "",
    "text": "results : Union[List[GOEnrichmentRecord], pd.Series]\n\nList or Series of GO result objejcts from obj column in the pd.DataFrame returned by go_enrichment().",
    "crumbs": [
      "GO graphs",
      "show_go_dag_enrichment_results"
    ]
  },
  {
    "objectID": "api/show_go_dag_enrichment_results.html#examples",
    "href": "api/show_go_dag_enrichment_results.html#examples",
    "title": "show_go_dag_enrichment_results",
    "section": "",
    "text": "gene_list = ['TP53', 'BRCA1', 'BRCA2', 'EGFR', 'KRAS', 'PTEN', 'CDH1', 'ATM', 'CHEK2', 'PALB2']\nresults = go_enrichment(gene_list, taxid=9606, alpha=0.05)\nshow_go_dag_enrichment_results(results.obj)",
    "crumbs": [
      "GO graphs",
      "show_go_dag_enrichment_results"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_regex.html",
    "href": "api/get_genes_for_go_regex.html",
    "title": "get_genes_for_go_regex",
    "section": "",
    "text": "geneinfo.ontology.get_genes_for_go_regex(regex, taxid=9606)\nGet gene information for GO terms matching a regular expression in their description string.\n\n\n\nregex : str\n\nRegular expression to match GO term descriptions.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)\n\n\n\n\n\n\n : pd.DataFrame\n\nColumns: symbol, name, chrom, start, end.",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_regex"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_regex.html#parameters",
    "href": "api/get_genes_for_go_regex.html#parameters",
    "title": "get_genes_for_go_regex",
    "section": "",
    "text": "regex : str\n\nRegular expression to match GO term descriptions.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606 (which is human)",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_regex"
    ]
  },
  {
    "objectID": "api/get_genes_for_go_regex.html#returns",
    "href": "api/get_genes_for_go_regex.html#returns",
    "title": "get_genes_for_go_regex",
    "section": "",
    "text": ": pd.DataFrame\n\nColumns: symbol, name, chrom, start, end.",
    "crumbs": [
      "Gene annotation",
      "get_genes_for_go_regex"
    ]
  },
  {
    "objectID": "api/get_go_terms_for_genes.html",
    "href": "api/get_go_terms_for_genes.html",
    "title": "get_go_terms_for_genes",
    "section": "",
    "text": "geneinfo.ontology.get_go_terms_for_genes(genes, taxid=9606, evidence=None)\nGet the union of GO terms for a list of genes.\n\n\n\ngenes : Union[str, list]\n\nGene name or list of gene names.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human.\n\nevidence : list = None\n\nEvidence codes, by default None\n\n\n\n\n\n\n : list\n\nGo terms for the specified genes.",
    "crumbs": [
      "GO information",
      "get_go_terms_for_genes"
    ]
  },
  {
    "objectID": "api/get_go_terms_for_genes.html#parameters",
    "href": "api/get_go_terms_for_genes.html#parameters",
    "title": "get_go_terms_for_genes",
    "section": "",
    "text": "genes : Union[str, list]\n\nGene name or list of gene names.\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human.\n\nevidence : list = None\n\nEvidence codes, by default None",
    "crumbs": [
      "GO information",
      "get_go_terms_for_genes"
    ]
  },
  {
    "objectID": "api/get_go_terms_for_genes.html#returns",
    "href": "api/get_go_terms_for_genes.html#returns",
    "title": "get_go_terms_for_genes",
    "section": "",
    "text": ": list\n\nGo terms for the specified genes.",
    "crumbs": [
      "GO information",
      "get_go_terms_for_genes"
    ]
  },
  {
    "objectID": "api/clear_cache.html",
    "href": "api/clear_cache.html",
    "title": "clear_cache",
    "section": "",
    "text": "clear_cache\ngeneinfo.utils.clear_cache(func_name=None)\nClear the cache of a shelve file.",
    "crumbs": [
      "Utilities",
      "clear_cache"
    ]
  },
  {
    "objectID": "api/get_genes_region.html",
    "href": "api/get_genes_region.html",
    "title": "get_genes_region",
    "section": "",
    "text": "geneinfo.information.get_genes_region(\n    chrom\n    window_start\n    window_end\n    assembly='GRCh38'\n    db='ncbiRefSeq'\n)\nGets gene structure information for genes in a chromosomal region.\n\n\n\nchrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : str = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : str = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’\n\n\n\n\n\n\n : list\n\nList of gene information. Each gene is a tuple with the following elements: - gene name - gene start - gene end - gene strand - list of exons (start, end)",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region"
    ]
  },
  {
    "objectID": "api/get_genes_region.html#parameters",
    "href": "api/get_genes_region.html#parameters",
    "title": "get_genes_region",
    "section": "",
    "text": "chrom : str\n\nChromosome identifier\n\nwindow_start : int\n\nStart of region\n\nwindow_end : int\n\nEnd of region (end base not included)\n\nassembly : str = 'GRCh38'\n\nGenome assembly, by default ‘GRCh38’\n\ndb : str = 'ncbiRefSeq'\n\nDatabase, by default ‘ncbiRefSeq’",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region"
    ]
  },
  {
    "objectID": "api/get_genes_region.html#returns",
    "href": "api/get_genes_region.html#returns",
    "title": "get_genes_region",
    "section": "",
    "text": ": list\n\nList of gene information. Each gene is a tuple with the following elements: - gene name - gene start - gene end - gene strand - list of exons (start, end)",
    "crumbs": [
      "Gene coordinates",
      "get_genes_region"
    ]
  },
  {
    "objectID": "api/GeneList.html",
    "href": "api/GeneList.html",
    "title": "GeneList",
    "section": "",
    "text": "GeneList\ngeneinfo.utils.GeneList(self, *args, **kwargs)",
    "crumbs": [
      "Utilities",
      "GeneList"
    ]
  },
  {
    "objectID": "api/go_annotation_table.html",
    "href": "api/go_annotation_table.html",
    "title": "go_annotation_table",
    "section": "",
    "text": "geneinfo.ontology.go_annotation_table(taxid=9606)\nGO annotations for a given taxonomy id as a pandas.DataFrame.\n\n\n\ntaxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human\n\n\n\n\n\n\n : pd.DataFrame\n\nGO annotations for the specified taxonomy id.",
    "crumbs": [
      "GO information",
      "go_annotation_table"
    ]
  },
  {
    "objectID": "api/go_annotation_table.html#parameters",
    "href": "api/go_annotation_table.html#parameters",
    "title": "go_annotation_table",
    "section": "",
    "text": "taxid : int = 9606\n\nNCBI taxonomy ID, by default 9606, which is human",
    "crumbs": [
      "GO information",
      "go_annotation_table"
    ]
  },
  {
    "objectID": "api/go_annotation_table.html#returns",
    "href": "api/go_annotation_table.html#returns",
    "title": "go_annotation_table",
    "section": "",
    "text": ": pd.DataFrame\n\nGO annotations for the specified taxonomy id.",
    "crumbs": [
      "GO information",
      "go_annotation_table"
    ]
  },
  {
    "objectID": "api/hgcn_symbol.html",
    "href": "api/hgcn_symbol.html",
    "title": "hgcn_symbol",
    "section": "",
    "text": "geneinfo.information.hgcn_symbol(name)\nGet HGCN gene symbol for some gene identifier\n\n\n\nname : str\n\nGene identifier\n\n\n\n\n\n\n : str\n\nHGCN gene symbol\n\n\n\n\n\n\n: [](~geneinfo.NotFound)\n\nRaises exception if no HGCN gene symbol can be found.",
    "crumbs": [
      "ID conversion",
      "hgcn_symbol"
    ]
  },
  {
    "objectID": "api/hgcn_symbol.html#parameters",
    "href": "api/hgcn_symbol.html#parameters",
    "title": "hgcn_symbol",
    "section": "",
    "text": "name : str\n\nGene identifier",
    "crumbs": [
      "ID conversion",
      "hgcn_symbol"
    ]
  },
  {
    "objectID": "api/hgcn_symbol.html#returns",
    "href": "api/hgcn_symbol.html#returns",
    "title": "hgcn_symbol",
    "section": "",
    "text": ": str\n\nHGCN gene symbol",
    "crumbs": [
      "ID conversion",
      "hgcn_symbol"
    ]
  },
  {
    "objectID": "api/hgcn_symbol.html#raises",
    "href": "api/hgcn_symbol.html#raises",
    "title": "hgcn_symbol",
    "section": "",
    "text": ": [](~geneinfo.NotFound)\n\nRaises exception if no HGCN gene symbol can be found.",
    "crumbs": [
      "ID conversion",
      "hgcn_symbol"
    ]
  },
  {
    "objectID": "api/go_name2term.html",
    "href": "api/go_name2term.html",
    "title": "go_name2term",
    "section": "",
    "text": "geneinfo.ontology.go_name2term(name)\nConverts a GO term name to its term.\n\n\n\nname : str\n\nGO term name\n\n\n\n\n\n\n : str\n\nGO term.",
    "crumbs": [
      "GO information",
      "go_name2term"
    ]
  },
  {
    "objectID": "api/go_name2term.html#parameters",
    "href": "api/go_name2term.html#parameters",
    "title": "go_name2term",
    "section": "",
    "text": "name : str\n\nGO term name",
    "crumbs": [
      "GO information",
      "go_name2term"
    ]
  },
  {
    "objectID": "api/go_name2term.html#returns",
    "href": "api/go_name2term.html#returns",
    "title": "go_name2term",
    "section": "",
    "text": ": str\n\nGO term.",
    "crumbs": [
      "GO information",
      "go_name2term"
    ]
  }
]